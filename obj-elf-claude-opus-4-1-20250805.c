/* ELF object file format
   Copyright (C) 1992-2025 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 3,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#define OBJ_HEADER "obj-elf.h"
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "obstack.h"
#include "dwarf2dbg.h"
#include "ginsn.h"

#ifndef ECOFF_DEBUGGING
#define ECOFF_DEBUGGING 0
#else
#define NEED_ECOFF_DEBUG
#endif

#ifdef NEED_ECOFF_DEBUG
#include "ecoff.h"
#include "bfd/ecoff-bfd.h"
#endif

#ifdef TC_ALPHA
#include "elf/alpha.h"
#endif

#ifdef TC_MIPS
#include "elf/mips.h"
#endif

#ifdef TC_PPC
#include "elf/ppc.h"
#endif

#ifdef TC_I386
#include "elf/x86-64.h"
#endif

#ifdef TC_MEP
#include "elf/mep.h"
#endif

#ifdef TC_PRU
#include "elf/pru.h"
#endif

static void obj_elf_line (int);
static void obj_elf_size (int);
static void obj_elf_type (int);
static void obj_elf_ident (int);
static void obj_elf_weak (int);
static void obj_elf_local (int);
static void obj_elf_visibility (int);
static void obj_elf_symver (int);
static void obj_elf_subsection (int);
static void obj_elf_popsection (int);
static void obj_elf_gnu_attribute (int);
static void obj_elf_tls_common (int);
static void obj_elf_lcomm (int);
static void obj_elf_struct (int);
static void obj_elf_attach_to_group (int);

static const pseudo_typeS elf_pseudo_table[] =
{
  {"attach_to_group", obj_elf_attach_to_group, 0},
  {"comm", obj_elf_common, 0},
  {"common", obj_elf_common, 1},
  {"ident", obj_elf_ident, 0},
  {"lcomm", obj_elf_lcomm, 0},
  {"local", obj_elf_local, 0},
  {"previous", obj_elf_previous, 0},
  {"section", obj_elf_section, 0},
  {"section.s", obj_elf_section, 0},
  {"sect", obj_elf_section, 0},
  {"sect.s", obj_elf_section, 0},
  {"pushsection", obj_elf_section, 1},
  {"popsection", obj_elf_popsection, 0},
  {"size", obj_elf_size, 0},
  {"type", obj_elf_type, 0},
  {"version", obj_elf_version, 0},
  {"weak", obj_elf_weak, 0},

  /* These define symbol visibility.  */
  {"internal", obj_elf_visibility, STV_INTERNAL},
  {"hidden", obj_elf_visibility, STV_HIDDEN},
  {"protected", obj_elf_visibility, STV_PROTECTED},

  /* These are used for stabs-in-elf configurations.  */
  {"line", obj_elf_line, 0},

  /* This is a GNU extension to handle symbol versions.  */
  {"symver", obj_elf_symver, 0},

  /* A GNU extension to change subsection only.  */
  {"subsection", obj_elf_subsection, 0},

  /* These are GNU extensions to aid in garbage collecting C++ vtables.  */
  {"vtable_inherit", obj_elf_vtable_inherit, 0},
  {"vtable_entry", obj_elf_vtable_entry, 0},

  /* A GNU extension for object attributes.  */
  {"gnu_attribute", obj_elf_gnu_attribute, 0},

  /* These are used for dwarf2.  */
  { "file", dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },
  { "loc_mark_labels", dwarf2_directive_loc_mark_labels, 0 },

  /* We need to trap the section changing calls to handle .previous.  */
  {"data", obj_elf_data, 0},
  {"offset", obj_elf_struct, 0},
  {"struct", obj_elf_struct, 0},
  {"text", obj_elf_text, 0},
  {"bss", obj_elf_bss, 0},

  {"tls_common", obj_elf_tls_common, 0},

  /* End sentinel.  */
  {NULL, NULL, 0},
};

static const pseudo_typeS ecoff_debug_pseudo_table[] =
{
#ifdef NEED_ECOFF_DEBUG
  /* COFF style debugging information for ECOFF. .ln is not used; .loc
     is used instead.  */
  { "def",	ecoff_directive_def,	0 },
  { "dim",	ecoff_directive_dim,	0 },
  { "endef",	ecoff_directive_endef,	0 },
  { "file",	ecoff_directive_file,	0 },
  { "scl",	ecoff_directive_scl,	0 },
  { "tag",	ecoff_directive_tag,	0 },
  { "val",	ecoff_directive_val,	0 },

  /* COFF debugging requires pseudo-ops .size and .type, but ELF
     already has meanings for those.  We use .esize and .etype
     instead.  These are only generated by gcc anyhow.  */
  { "esize",	ecoff_directive_size,	0 },
  { "etype",	ecoff_directive_type,	0 },

  /* ECOFF specific debugging information.  */
  { "aent",	ecoff_directive_ent,	1 },
  { "begin",	ecoff_directive_begin,	0 },
  { "bend",	ecoff_directive_bend,	0 },
  { "end",	ecoff_directive_end,	0 },
  { "ent",	ecoff_directive_ent,	0 },
  { "fmask",	ecoff_directive_fmask,	0 },
  { "frame",	ecoff_directive_frame,	0 },
  { "loc",	ecoff_directive_loc,	0 },
  { "mask",	ecoff_directive_mask,	0 },

  /* Other ECOFF directives.  */
  { "extern",	ecoff_directive_extern,	0 },

  /* These are used on Irix.  I don't know how to implement them.  */
  { "alias",	s_ignore,		0 },
  { "bgnb",	s_ignore,		0 },
  { "endb",	s_ignore,		0 },
  { "lab",	s_ignore,		0 },
  { "noalias",	s_ignore,		0 },
  { "verstamp",	s_ignore,		0 },
  { "vreg",	s_ignore,		0 },
#endif

  {NULL, NULL, 0}			/* end sentinel */
};

#undef NO_RELOC
#include "aout/aout64.h"

asection *elf_com_section_ptr;

void elf_pop_insert(void)
{
    pop_insert(elf_pseudo_table);
    
    if (ECOFF_DEBUGGING)
    {
        pop_insert(ecoff_debug_pseudo_table);
    }
}

void
elf_file_symbol (const char *s)
{
  if (s == NULL) {
    return;
  }

  symbolS *sym = symbol_new (s, absolute_section, &zero_address_frag, 0);
  if (sym == NULL) {
    return;
  }

  size_t name_length = strlen (s);
  const char *current_name = S_GET_NAME (sym);
  
  if (current_name == NULL) {
    return;
  }

  if (name_length > strlen (current_name))
    {
      obstack_grow (&notes, s, name_length + 1);
      S_SET_NAME (sym, obstack_finish (&notes));
    }
  else
    {
      char *dest = (char *) S_GET_NAME (sym);
      strncpy (dest, s, name_length);
      dest[name_length] = '\0';
    }

  symbol_get_bfdsym (sym)->flags |= BSF_FILE;

  if (symbol_rootP != sym)
    {
      asymbol *bsym = symbol_get_bfdsym (symbol_rootP);
      if (bsym == NULL || (bsym->flags & BSF_FILE) == 0)
        {
          symbol_remove (sym, &symbol_rootP, &symbol_lastP);
          symbol_insert (sym, symbol_rootP, &symbol_rootP, &symbol_lastP);
        }
    }

#ifdef DEBUG
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif

#ifdef NEED_ECOFF_DEBUG
  ecoff_new_file (s);
#endif
}

/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

symbolS *
elf_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size)
{
  addressT align = 0;
  int is_local;
  
  if (symbolP == NULL)
    return NULL;
    
  is_local = symbol_get_obj (symbolP)->local;

  if (*input_line_pointer == ',')
    {
      char *save = input_line_pointer;

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '"')
	{
	  if (!parse_segment_specifier())
	    return NULL;
	  is_local = 0;
	}
      else
	{
	  input_line_pointer = save;
	  align = parse_align (is_local);
	  if (align == (addressT) -1)
	    return NULL;
	}
    }

  if (is_local)
    {
      bss_alloc (symbolP, size, align);
      S_CLEAR_EXTERNAL (symbolP);
    }
  else
    {
      S_SET_VALUE (symbolP, size);
      S_SET_ALIGN (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, elf_com_section_ptr);
    }

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  return symbolP;
}

static int
parse_segment_specifier (void)
{
  char *p;
  char c;
  
  input_line_pointer++;
  
  if (*input_line_pointer == '.')
    input_line_pointer++;
    
  if (startswith (input_line_pointer, "bss\""))
    {
      input_line_pointer += 4;
      return 1;
    }
    
  if (startswith (input_line_pointer, "data\""))
    {
      input_line_pointer += 5;
      return 1;
    }
    
  p = input_line_pointer;
  while (*--p != '"' && p > input_line_pointer - 100)
    ;
    
  while (!is_end_of_stmt (*input_line_pointer))
    {
      if (*input_line_pointer++ == '"')
        break;
    }
    
  c = *input_line_pointer;
  *input_line_pointer = '\0';
  as_bad (_("bad .common segment %s"), p);
  *input_line_pointer = c;
  ignore_rest_of_line ();
  
  return 0;
}

void obj_elf_common(int is_common)
{
    if (flag_mri && is_common) {
        s_mri_common(0);
        return;
    }
    
    s_comm_internal(0, elf_common_parse);
}

static void
obj_elf_tls_common (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, elf_common_parse);

  if (symbolP != NULL)
    {
      asymbol *bfdsym = symbol_get_bfdsym (symbolP);
      if (bfdsym != NULL)
        bfdsym->flags |= BSF_THREAD_LOCAL;
    }
}

static void
obj_elf_lcomm (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, s_lcomm_internal);

  if (symbolP != NULL)
    {
      bfd_symbol_info *bfdsym = symbol_get_bfdsym (symbolP);
      if (bfdsym != NULL)
        bfdsym->flags |= BSF_OBJECT;
    }
}

static symbolS *
get_sym_from_input_line_and_check (void)
{
  char *name;
  char c;
  symbolS *sym;

  c = get_symbol_name (&name);
  
  if (name == input_line_pointer)
    {
      restore_line_pointer (c);
      as_bad (_("Missing symbol name in directive"));
      return NULL;
    }
  
  sym = symbol_find_or_make (name);
  restore_line_pointer (c);
  SKIP_WHITESPACE ();
  
  return sym;
}

static void
obj_elf_local (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;
  
  for (;;)
    {
      symbolP = get_sym_from_input_line_and_check ();
      if (symbolP == NULL)
        break;
        
      S_CLEAR_EXTERNAL (symbolP);
      symbol_get_obj (symbolP)->local = 1;
      
      if (*input_line_pointer != ',')
        break;
        
      input_line_pointer++;
      SKIP_WHITESPACE ();
      
      if (*input_line_pointer == '\n')
        break;
    }
  
  demand_empty_rest_of_line ();
}

static void
obj_elf_weak (int ignore ATTRIBUTE_UNUSED)
{
  while (1)
    {
      symbolS *symbolP = get_sym_from_input_line_and_check ();
      S_SET_WEAK (symbolP);
      
      if (*input_line_pointer != ',')
        break;
        
      input_line_pointer++;
      SKIP_WHITESPACE ();
      
      if (*input_line_pointer == '\n')
        break;
    }
  
  demand_empty_rest_of_line ();
}

static void
obj_elf_visibility (int visibility)
{
  symbolS *symbolP;
  asymbol *bfdsym;
  elf_symbol_type *elfsym;

  while (1)
    {
      symbolP = get_sym_from_input_line_and_check ();
      if (symbolP == NULL)
        break;

      bfdsym = symbol_get_bfdsym (symbolP);
      if (bfdsym == NULL)
        break;

      elfsym = elf_symbol_from (bfdsym);
      if (elfsym == NULL)
        break;

      elfsym->internal_elf_sym.st_other &= ~3;
      elfsym->internal_elf_sym.st_other |= visibility;

      if (*input_line_pointer != ',')
        break;

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '\n')
        break;
    }

  demand_empty_rest_of_line ();
}

static segT previous_section;
static int previous_subsection;

struct section_stack
{
  struct section_stack *next;
  segT seg, prev_seg;
  int subseg, prev_subseg;
};

static struct section_stack *section_stack;

/* ELF section flags for unique sections.  */
#define SEC_ASSEMBLER_SHF_MASK SHF_GNU_RETAIN

struct group_list
{
  asection **head;		/* Section lists.  */
  unsigned int num_group;	/* Number of lists.  */
  htab_t indexes; /* Maps group name to index in head array.  */
};

static struct group_list groups;

static bool
match_section (const asection *sec, const struct elf_section_match *match)
{
  if (sec == NULL || match == NULL) {
    return false;
  }

  const struct elf_internal_shdr *hdr = &elf_section_data (sec)->this_hdr;
  unsigned int sh_info = hdr->sh_info;
  bfd_vma sh_flags = hdr->sh_flags & SEC_ASSEMBLER_SHF_MASK;

  if (sh_info != match->sh_info || sh_flags != match->sh_flags) {
    return false;
  }

  if (sec->section_id != match->section_id) {
    return false;
  }

  bfd_vma sec_flags = bfd_section_flags (sec) & SEC_ASSEMBLER_SECTION_ID;
  bfd_vma match_flags = match->flags & SEC_ASSEMBLER_SECTION_ID;
  if (sec_flags != match_flags) {
    return false;
  }

  const char *linked_to_symbol_name = sec->map_head.linked_to_symbol_name;
  const char *match_linked_name = match->linked_to_symbol_name;

  if (linked_to_symbol_name == match_linked_name) {
    return true;
  }

  if (linked_to_symbol_name == NULL || match_linked_name == NULL) {
    return false;
  }

  return strcmp (linked_to_symbol_name, match_linked_name) == 0;
}

/* Return TRUE iff SEC matches the section info INF.  */

static bool
get_section_by_match (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  struct elf_section_match *match = inf;
  const char *gname = match->group_name;
  const char *group_name = elf_group_name (sec);

  if (group_name != gname) {
    if (group_name == NULL || gname == NULL) {
      return false;
    }
    if (strcmp (group_name, gname) != 0) {
      return false;
    }
  }

  return match_section (sec, match);
}

/* Go look in section lists kept per group for SEC_NAME with
   properties given by MATCH.  If info for the group named by
   MATCH->GROUP_NAME has been initialised, set GROUP_IDX.  */

static asection *
group_section_find (const struct elf_section_match *match,
		    const char *sec_name,
		    unsigned int *group_idx)
{
  if (match == NULL || sec_name == NULL || group_idx == NULL)
    return NULL;

  if (groups.indexes == NULL)
    {
      groups.num_group = 0;
      groups.head = NULL;
      groups.indexes = htab_create_alloc (16, hash_string_tuple, eq_string_tuple,
					  NULL, notes_calloc, NULL);
      *group_idx = ~0u;
      return NULL;
    }

  if (match->group_name == NULL)
    {
      *group_idx = ~0u;
      return NULL;
    }

  *group_idx = str_hash_find_int (groups.indexes, match->group_name);
  if (*group_idx == ~0u)
    return NULL;

  if (groups.head == NULL)
    return NULL;

  asection *current_section = groups.head[*group_idx];
  
  while (current_section != NULL)
    {
      if (current_section->name != NULL &&
          (current_section->name == sec_name || 
           strcmp (current_section->name, sec_name) == 0) &&
          match_section (current_section, match))
        {
          return current_section;
        }
      current_section = elf_next_in_group (current_section);
    }
  
  return NULL;
}

/* Insert SEC into section lists kept per group.  MATCH and GROUP_IDX
   must be from a prior call to group_section_find.  */

static void
group_section_insert (const struct elf_section_match *match,
		      asection *sec,
		      unsigned int *group_idx)
{
  if (*group_idx != ~0u)
    {
      elf_next_in_group (sec) = groups.head[*group_idx];
      groups.head[*group_idx] = sec;
      return;
    }

  unsigned int new_index = groups.num_group;
  unsigned int current_capacity = (new_index + 127) & ~127u;
  unsigned int required_capacity = new_index + 1;
  
  if (required_capacity > current_capacity)
    {
      groups.head = XRESIZEVEC (asection *, groups.head, current_capacity + 128);
    }
  
  groups.head[new_index] = sec;
  groups.num_group = required_capacity;
  *group_idx = new_index;
  
  str_hash_insert_int (groups.indexes, match->group_name, new_index, 0);
}

/* Handle the .section pseudo-op.  This code supports two different
   syntaxes.

   The first is found on Solaris, and looks like
       .section ".sec1",#alloc,#execinstr,#write
   Here the names after '#' are the SHF_* flags to turn on for the
   section.  I'm not sure how it determines the SHT_* type (BFD
   doesn't really give us control over the type, anyhow).

   The second format is found on UnixWare, and probably most SVR4
   machines, and looks like
       .section .sec1,"a",@progbits
   The quoted string may contain any combination of a, w, x, and
   represents the SHF_* flags to turn on for the section.  The string
   beginning with '@' can be progbits or nobits.  There should be
   other possibilities, but I don't know what they are.  In any case,
   BFD doesn't really let us set the section type.  */

static void
change_section (const char *name,
		unsigned int type,
		bfd_vma attr,
		int entsize,
		struct elf_section_match *match_p,
		bool linkonce,
		bool push,
		subsegT new_subsection)
{
  static struct elf_section_match unused_match;
  asection *old_sec;
  segT sec;
  flagword flags;
  const struct elf_backend_data *bed;
  const struct bfd_elf_special_section *ssect;
  unsigned int group_idx = ~0u;

  if (match_p == NULL)
    match_p = &unused_match;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (push)
    {
      struct section_stack *elt = XNEW (struct section_stack);
      elt->next = section_stack;
      elt->seg = now_seg;
      elt->prev_seg = previous_section;
      elt->subseg = now_subseg;
      elt->prev_subseg = previous_subsection;
      section_stack = elt;
    }

  obj_elf_section_change_hook ();

  if (match_p->group_name)
    old_sec = group_section_find (match_p, name, &group_idx);
  else
    old_sec = bfd_get_section_by_name_if (stdoutput, name, get_section_by_match,
					  match_p);
  if (old_sec)
    {
      sec = old_sec;
      subseg_set (sec, new_subsection);
    }
  else
    {
      sec = subseg_force_new (name, new_subsection);
      if (match_p->group_name)
	group_section_insert (match_p, sec, &group_idx);
    }

  bed = get_elf_backend_data (stdoutput);
  ssect = (*bed->get_sec_type_attr) (stdoutput, sec);

  if (ssect != NULL)
    {
      process_special_section(ssect, old_sec, name, &type, &attr, match_p);
    }

  flags = convert_to_bfd_flags(attr, type, linkonce);
  
  if ((flags & SEC_ALLOC) == 0 && name[0] == '.')
    {
      if (is_debug_section(name))
	flags |= SEC_ELF_OCTETS;
    }

  if (old_sec == NULL)
    {
      setup_new_section(sec, type, attr, entsize, flags, match_p, name);
    }
  else
    {
      validate_existing_section(old_sec, sec, type, attr, entsize, flags, ssect, name);
    }

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void process_special_section(const struct bfd_elf_special_section *ssect,
                                   asection *old_sec,
                                   const char *name,
                                   unsigned int *type,
                                   bfd_vma *attr,
                                   struct elf_section_match *match_p)
{
  bool override = false;

  if (*type == SHT_NULL)
    *type = ssect->type;
  else if (*type != ssect->type)
    {
      if (should_warn_incorrect_type(old_sec, ssect))
        {
          if (ssect->type != SHT_NOTE && *type < SHT_LOPROC)
            as_warn (_("setting incorrect section type for %s"), name);
        }
      else
        {
          as_warn (_("ignoring incorrect section type for %s"), name);
          *type = ssect->type;
        }
    }

  if (old_sec == NULL)
    {
      override = check_section_attributes(ssect, name, *attr);
      if (!override)
        *attr |= ssect->attr;
      else if (match_p->group_name == NULL)
        as_warn (_("setting incorrect section attributes for %s"), name);
    }
}

static bool should_warn_incorrect_type(asection *old_sec,
                                      const struct bfd_elf_special_section *ssect)
{
  if (old_sec != NULL)
    return false;

#ifdef TC_I386
  const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
  if (bed->s->arch_size == 64 && (ssect->attr & SHF_X86_64_LARGE))
    return false;
#endif

  return ssect->type != SHT_INIT_ARRAY &&
         ssect->type != SHT_FINI_ARRAY &&
         ssect->type != SHT_PREINIT_ARRAY;
}

static bool check_section_attributes(const struct bfd_elf_special_section *ssect,
                                    const char *name,
                                    bfd_vma attr)
{
  bfd_vma masked_attr = (attr & ~(SHF_LINK_ORDER | SHF_MASKOS | SHF_MASKPROC)) & ~ssect->attr;
  
  if (masked_attr == 0)
    return false;

  bfd_vma generic_attr = attr;
  if (elf_tdata (stdoutput)->has_gnu_osabi)
    generic_attr &= ~SHF_GNU_RETAIN;

  if (ssect->type == SHT_NOTE &&
      (generic_attr == SHF_ALLOC || generic_attr == SHF_EXECINSTR))
    return false;

  if (ssect->suffix_length == -2 && name[ssect->prefix_length] == '.' &&
      (generic_attr & ~ssect->attr & ~SHF_MERGE & ~SHF_STRINGS) == 0)
    return false;

  if (generic_attr == SHF_ALLOC &&
      (strcmp (name, ".interp") == 0 ||
       strcmp (name, ".strtab") == 0 ||
       strcmp (name, ".symtab") == 0))
    return true;

  if (generic_attr == SHF_EXECINSTR && strcmp (name, ".note.GNU-stack") == 0)
    return true;

#ifdef TC_ALPHA
  if ((generic_attr & ~ssect->attr) == SHF_ALPHA_GPREL)
    return true;
#endif

#ifdef TC_RX
  if (generic_attr == (SHF_EXECINSTR | SHF_WRITE | SHF_ALLOC) &&
      (ssect->type == SHT_INIT_ARRAY ||
       ssect->type == SHT_FINI_ARRAY ||
       ssect->type == SHT_PREINIT_ARRAY))
    return false;
#endif

  return true;
}

static flagword convert_to_bfd_flags(bfd_vma attr, unsigned int type, bool linkonce)
{
  flagword flags = SEC_RELOC;
  
  if (!(attr & SHF_WRITE))
    flags |= SEC_READONLY;
  if (attr & SHF_ALLOC)
    flags |= SEC_ALLOC;
  if ((attr & SHF_ALLOC) && type != SHT_NOBITS)
    flags |= SEC_LOAD;
  if (attr & SHF_EXECINSTR)
    flags |= SEC_CODE;
  if (attr & SHF_MERGE)
    flags |= SEC_MERGE;
  if (attr & SHF_STRINGS)
    flags |= SEC_STRINGS;
  if (attr & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;
  if (attr & SHF_TLS)
    flags |= SEC_THREAD_LOCAL;

#ifdef md_elf_section_flags
  flags = md_elf_section_flags (flags, attr, type);
#endif

  if (linkonce)
    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

  return flags;
}

static bool is_debug_section(const char *name)
{
  return startswith (name, ".debug") ||
         startswith (name, ".zdebug") ||
         startswith (name, ".gnu.debuglto_.debug_") ||
         startswith (name, ".gnu.linkonce.wi.") ||
         startswith (name, GNU_BUILD_ATTRS_SECTION_NAME) ||
         startswith (name, ".note.gnu");
}

static void setup_new_section(segT sec,
                             unsigned int type,
                             bfd_vma attr,
                             int entsize,
                             flagword flags,
                             struct elf_section_match *match_p,
                             const char *name)
{
  symbolS *secsym;

  if (type == SHT_NULL)
    type = bfd_elf_get_default_section_type (flags);
    
  elf_section_type (sec) = type;
  elf_section_flags (sec) = attr;
  elf_section_data (sec)->this_hdr.sh_info = match_p->sh_info;

  if (type == SHT_NOBITS)
    seg_info (sec)->bss = 1;

  sec->section_id = match_p->section_id;
  flags |= match_p->flags;
  sec->map_head.linked_to_symbol_name = match_p->linked_to_symbol_name;

  bfd_set_section_flags (sec, flags);
  
  if (entsize != 0)
    sec->entsize = entsize;
    
  elf_group_name (sec) = match_p->group_name;

  secsym = symbol_find (name);
  if (secsym != NULL)
    {
      static const expressionS exp = { .X_op = O_constant };
      symbol_set_value_expression (secsym, &exp);
      symbol_set_bfdsym (secsym, sec->symbol);
    }
  else
    {
      symbol_table_insert (section_symbol (sec));
    }
}

static void validate_existing_section(asection *old_sec,
                                     segT sec,
                                     unsigned int type,
                                     bfd_vma attr,
                                     int entsize,
                                     flagword flags,
                                     const struct bfd_elf_special_section *ssect,
                                     const char *name)
{
  if (type != SHT_NULL && (unsigned) type != elf_section_type (old_sec))
    {
      if (ssect != NULL)
        as_warn (_("ignoring changed section type for %s"), name);
      else
        as_bad (_("changed section type for %s"), name);
    }

  if (attr != 0)
    {
      flagword flag_diff = old_sec->flags ^ flags;
      flagword important_flags = SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE |
                                SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | 
                                SEC_STRINGS | SEC_LINK_ONCE | 
                                SEC_LINK_DUPLICATES_DISCARD | SEC_THREAD_LOCAL;
                                
      if (flag_diff & important_flags)
        {
          if (ssect != NULL)
            as_warn (_("ignoring changed section attributes for %s"), name);
          else
            as_bad (_("changed section attributes for %s"), name);
        }
      else
        {
          elf_section_flags (sec) = attr;
        }

      if (entsize != 0 && old_sec->entsize != (unsigned) entsize)
        as_bad (_("changed section entity size for %s"), name);
    }
}

void obj_elf_change_section(const char *name, unsigned int type, bfd_vma attr,
                            int entsize, struct elf_section_match *match_p,
                            bool linkonce)
{
    change_section(name, type, attr, entsize, match_p, linkonce, false, 0);
}

static bfd_vma
obj_elf_parse_section_letters (char *str, size_t len, bool push,
			       bool *is_clone, int *inherit, bfd_vma *gnu_attr,
			       bool *has_entsize)
{
  bfd_vma attr = 0;

  *is_clone = false;
  *inherit = 0;

  while (len > 0)
    {
      char current = *str;
      
      if (current == 'a')
        {
          attr |= SHF_ALLOC;
          if (len > 1 && str[1] == 'm')
            {
              attr |= SHF_MERGE;
              str++;
              len--;
              if (len > 1 && str[1] == 's')
                {
                  attr |= SHF_STRINGS;
                  str++;
                  len--;
                }
            }
        }
      else if (current == 'd')
        {
          if (gnu_attr != NULL)
            *gnu_attr |= SHF_GNU_MBIND;
          else
            goto unrecognized;
        }
      else if (current == 'e')
        attr |= SHF_EXCLUDE;
      else if (current == 'o')
        attr |= SHF_LINK_ORDER;
      else if (current == 'w')
        attr |= SHF_WRITE;
      else if (current == 'x')
        attr |= SHF_EXECINSTR;
      else if (current == 'E')
        *has_entsize = true;
      else if (current == 'G')
        attr |= SHF_GROUP;
      else if (current == 'M')
        attr |= SHF_MERGE;
      else if (current == 'R')
        {
          if (gnu_attr != NULL)
            *gnu_attr |= SHF_GNU_RETAIN;
          else
            goto unrecognized;
        }
      else if (current == 'S')
        attr |= SHF_STRINGS;
      else if (current == 'T')
        attr |= SHF_TLS;
      else if (current == '?')
        *is_clone = true;
      else
        {
        unrecognized:
          {
            const char *md_extra = "";

#ifdef md_elf_section_letter
            bfd_vma md_attr = md_elf_section_letter (current, &md_extra);
            if (md_attr != (bfd_vma) -1)
              attr |= md_attr;
            else
#endif
              if (ISDIGIT (current))
                {
                  char *end;
                  bfd_vma numeric_flags = strtoul (str, &end, 0);

                  attr |= numeric_flags;

                  if (gnu_attr != NULL)
                    *gnu_attr |= (numeric_flags & SHF_MASKOS);

                  end--;
                  len -= (end - str);
                  str = end;
                }
              else if (*inherit == 0 && attr == 0
                       && (gnu_attr == NULL || *gnu_attr == 0)
                       && (current == '+' || current == '-'))
                *inherit = (current == '+') ? 1 : -1;
              else
                {
                  as_bad (_("unrecognized .%ssection attribute: want %s%s%s,? or number"),
                    push ? "push" : "",
                    gnu_attr != NULL ? "a,d,e,o,w,x,E,G,M,R,S,T"
                                     : "a,e,o,w,x,E,G,M,S,T",
                    md_extra != NULL ? "," : "", md_extra);
                  return attr;
                }
          }
        }
      
      str++;
      len--;
    }

  return attr;
}

static int
obj_elf_section_type (char *str, size_t len, bool warn)
{
  static const struct {
    const char *name;
    size_t len;
    int type;
  } section_types[] = {
    {"progbits", 8, SHT_PROGBITS},
    {"nobits", 6, SHT_NOBITS},
    {"note", 4, SHT_NOTE},
    {"init_array", 10, SHT_INIT_ARRAY},
    {"fini_array", 10, SHT_FINI_ARRAY},
    {"preinit_array", 13, SHT_PREINIT_ARRAY}
  };

  if (str == NULL || len == 0) {
    if (warn)
      as_warn (_("invalid section type"));
    return 0;
  }

  for (size_t i = 0; i < sizeof(section_types) / sizeof(section_types[0]); i++) {
    if (len == section_types[i].len && startswith(str, section_types[i].name))
      return section_types[i].type;
  }

#ifdef md_elf_section_type
  {
    int md_type = md_elf_section_type(str, len);
    if (md_type >= 0)
      return md_type;
  }
#endif

  if (ISDIGIT(*str)) {
    char *end = NULL;
    unsigned long type_value = strtoul(str, &end, 0);
    
    if (end != NULL && warn && (size_t)(end - str) != len)
      as_warn(_("extraneous characters at end of numeric section type"));
    
    if (type_value > INT_MAX) {
      if (warn)
        as_warn(_("section type value out of range"));
      return 0;
    }
    
    return (int)type_value;
  }

  if (warn)
    as_warn(_("unrecognized section type"));
  
  return 0;
}

#ifdef TC_SPARC
static bfd_vma
obj_elf_section_word (char *str, size_t len, int *type)
{
  int ret;

  if (len == 5 && startswith (str, "write"))
    return SHF_WRITE;
  if (len == 5 && startswith (str, "alloc"))
    return SHF_ALLOC;
  if (len == 9 && startswith (str, "execinstr"))
    return SHF_EXECINSTR;
  if (len == 7 && startswith (str, "exclude"))
    return SHF_EXCLUDE;
  if (len == 3 && startswith (str, "tls"))
    return SHF_TLS;

  ret = obj_elf_section_type (str, len, false);
  if (ret != 0)
    *type = ret;
  else
    as_warn (_("unrecognized section attribute"));

  return 0;
}
#endif

/* Get name of section.  */
const char *
obj_elf_section_name (void)
{
  char *name;

  SKIP_WHITESPACE ();
  
  if (*input_line_pointer == '"')
    {
      int dummy;
      name = demand_copy_C_string (&dummy);
      if (name == NULL)
        {
          ignore_rest_of_line ();
          return NULL;
        }
    }
  else
    {
      name = parse_unquoted_section_name ();
      if (name == NULL)
        return NULL;
      
      if (flag_sectname_subst)
        name = substitute_section_name (name);
      
      obstack_finish (&notes);
      
#ifdef tc_canonicalize_section_name
      name = tc_canonicalize_section_name (name);
#endif
    }
  
  SKIP_WHITESPACE ();
  return name;
}

static char *
parse_unquoted_section_name (void)
{
  char *end = input_line_pointer;
  
  while (!is_whitespace (*end) && !is_end_of_stmt (*end) && *end != ',')
    end++;
  
  if (end == input_line_pointer)
    {
      as_bad (_("missing name"));
      ignore_rest_of_line ();
      return NULL;
    }
  
  obstack_grow0 (&notes, input_line_pointer, end - input_line_pointer);
  input_line_pointer = end;
  return obstack_base (&notes);
}

static char *
substitute_section_name (char *name)
{
  char *subst;
  
  while ((subst = strchr (name, '%')) != NULL)
    {
      if (subst[1] != 'S')
        break;
      
      size_t head = subst - name;
      size_t tail = strlen (subst + 2) + 1;
      size_t slen = strlen (now_seg->name);
      
      if (slen > 2)
        {
          obstack_blank (&notes, slen - 2);
          name = obstack_base (&notes);
        }
      
      memmove (name + head + slen, name + head + 2, tail);
      memcpy (name + head, now_seg->name, slen);
    }
  
  return name;
}

/* Arrange to put SEC, known to be in group GNAME into the per-group
   section lists kept by gas.  */

void
elf_set_group_name (asection *sec, const char *gname)
{
  if (sec == NULL || gname == NULL) {
    return;
  }

  elf_group_name (sec) = gname;
  elf_section_flags (sec) |= SHF_GROUP;

  struct elf_section_match match = {
    .group_name = gname,
    .linked_to_symbol_name = sec->map_head.linked_to_symbol_name,
    .section_id = sec->section_id,
    .sh_info = elf_section_data (sec)->this_hdr.sh_info,
    .sh_flags = elf_section_data (sec)->this_hdr.sh_flags & SEC_ASSEMBLER_SHF_MASK,
    .flags = bfd_section_flags (sec) & SEC_ASSEMBLER_SECTION_ID
  };

  unsigned int group_idx = 0;
  if (!group_section_find (&match, sec->name, &group_idx)) {
    group_section_insert (&match, sec, &group_idx);
  }
}

static void
obj_elf_attach_to_group (int dummy ATTRIBUTE_UNUSED)
{
  const char * gname = obj_elf_section_name ();

  if (gname == NULL)
    {
      as_warn (_("group name not parseable"));
      return;
    }

  const char * current_group = elf_group_name (now_seg);
  
  if (current_group != NULL)
    {
      if (strcmp (current_group, gname) != 0)
        {
          as_warn (_("section %s already has a group (%s)"),
                   bfd_section_name (now_seg), current_group);
        }
      return;
    }
  
  elf_set_group_name (now_seg, gname);
}

/* Handle section related directives.

   Note on support for SFrame sections: These are generally expected to be
   generated by the assembler.  However, this function permits their direct
   creation by the user.  At the moment though, we go no extra mile by adding
   an explicit @sframe for SHT_GNU_SFRAME (using the numeric value of section
   type should suffice); Nor do we implement any outright refusal for
   non-supported targets via ELFOSABI-specific checks.  */

void
obj_elf_section (int push)
{
  const char *name;
  char *beg;
  int type, dummy;
  bfd_vma attr;
  bfd_vma gnu_attr;
  int entsize;
  bool linkonce, has_entsize;
  subsegT new_subsection = 0;
  struct elf_section_match match;
  unsigned long linked_to_section_index = -1UL;

  if (flag_mri)
    {
      char mri_type;

#ifdef md_flush_pending_output
      md_flush_pending_output ();
#endif

      obj_elf_section_change_hook ();

      s_mri_sect (&mri_type);

#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif

      return;
    }

  name = obj_elf_section_name ();
  if (name == NULL)
    return;

  memset (&match, 0, sizeof (match));

  symbolS * sym;
  if ((sym = symbol_find (name)) != NULL
      && ! symbol_section_p (sym)
      && S_IS_DEFINED (sym)
      && ! S_IS_VOLATILE (sym)
      && ! S_CAN_BE_REDEFINED (sym))
    {
      as_bad (_("section name '%s' already defined as another symbol"), name);
      ignore_rest_of_line ();
      return;
    }
  type = SHT_NULL;
  attr = 0;
  gnu_attr = 0;
  entsize = 0;
  has_entsize = false;
  linkonce = 0;

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (push && ISDIGIT (*input_line_pointer))
	{
	  new_subsection = get_absolute_expression ();

	  SKIP_WHITESPACE ();

	  if (*input_line_pointer != ',')
	    goto done;

	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	}

      if (*input_line_pointer == '"')
	{
	  if (!parse_section_attributes(name, push, &type, &attr, &gnu_attr,
					&entsize, &has_entsize, &linkonce,
					&match, &linked_to_section_index))
	    return;
	}
#ifdef TC_SPARC
      else
	{
	  parse_sparc_section_attributes(&attr, &type);
	}
#endif
    }

 done:
  demand_empty_rest_of_line ();

  if ((gnu_attr & (SHF_GNU_MBIND | SHF_GNU_RETAIN)) != 0)
    {
      bool mbind_p = (gnu_attr & SHF_GNU_MBIND) != 0;

      if (mbind_p && (attr & SHF_ALLOC) == 0)
	as_bad (_("SHF_ALLOC isn't set for GNU_MBIND section: %s"), name);

      if (mbind_p)
	elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_mbind;
      if ((gnu_attr & SHF_GNU_RETAIN) != 0)
	elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_retain;

      attr |= gnu_attr;
    }

  change_section (name, type, attr, entsize, &match, linkonce, push,
		  new_subsection);

  if (linked_to_section_index != -1UL)
    {
      elf_section_flags (now_seg) |= SHF_LINK_ORDER;
      elf_section_data (now_seg)->this_hdr.sh_link = linked_to_section_index;
    }
}

static bool
parse_section_attributes(const char *name, int push, int *type, bfd_vma *attr,
			bfd_vma *gnu_attr, int *entsize, bool *has_entsize,
			int *linkonce, struct elf_section_match *match,
			unsigned long *linked_to_section_index)
{
  bool is_clone;
  int inherit;
  char *beg;
  int dummy;

  beg = demand_copy_C_string (&dummy);
  if (beg == NULL)
    {
      ignore_rest_of_line ();
      return false;
    }

  const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
  *attr = obj_elf_parse_section_letters (beg, strlen (beg), push,
					&is_clone, &inherit,
					bed->elf_osabi == ELFOSABI_NONE
					|| (bed->elf_osabi
					    == ELFOSABI_GNU)
					|| (bed->elf_osabi
					    == ELFOSABI_FREEBSD)
					? gnu_attr : NULL,
					has_entsize);

  if (inherit > 0)
    *attr |= elf_section_flags (now_seg);
  else if (inherit < 0)
    *attr = elf_section_flags (now_seg) & ~*attr;
  if (inherit)
    *type = elf_section_type (now_seg);

  if ((*attr & (SHF_MERGE | SHF_STRINGS)) != 0)
    *has_entsize = true;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      if (!parse_section_type(type))
	return false;
    }

  SKIP_WHITESPACE ();
  parse_entity_size(attr, entsize, has_entsize, inherit);

  if ((*attr & (SHF_MERGE | SHF_STRINGS)) != 0 && *type == SHT_NOBITS)
    as_warn (_("bogus SHF_MERGE / SHF_STRINGS for SHT_NOBITS section"));

  parse_link_order(attr, match, linked_to_section_index, inherit);
  parse_group_info(name, attr, match, linkonce, is_clone, inherit);

  if ((gnu_attr != NULL) && ((*gnu_attr) & SHF_GNU_MBIND) != 0)
    parse_mbind_info(match);

  if ((gnu_attr != NULL) && ((*gnu_attr) & SHF_GNU_RETAIN) != 0)
    match->sh_flags |= SHF_GNU_RETAIN;

  parse_unique_section(match);

  return true;
}

static bool
parse_section_type(int *type)
{
  char c;
  char *beg;
  int dummy;
  char *save = input_line_pointer;

  ++input_line_pointer;
  SKIP_WHITESPACE ();
  c = *input_line_pointer;
  if (c == '"')
    {
      beg = demand_copy_C_string (&dummy);
      if (beg == NULL)
	{
	  ignore_rest_of_line ();
	  return false;
	}
      *type = obj_elf_section_type (beg, strlen (beg), true);
    }
  else if (c == '@' || c == '%')
    {
      ++input_line_pointer;

      if (ISDIGIT (* input_line_pointer))
	*type = strtoul (input_line_pointer, &input_line_pointer, 0);
      else
	{
	  c = get_symbol_name (& beg);
	  (void) restore_line_pointer (c);
	  *type = obj_elf_section_type (beg,
				       input_line_pointer - beg,
				       true);
	}
    }
  else
    input_line_pointer = save;

  return true;
}

static void
parse_entity_size(bfd_vma *attr, int *entsize, bool *has_entsize, int inherit)
{
  if (*has_entsize && *input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (inherit && *input_line_pointer == ','
	  && ((bfd_section_flags (now_seg)
	       & (SEC_MERGE | SEC_STRINGS)) != 0
	      || now_seg->entsize))
	{
	  *entsize = now_seg->entsize;
	  return;
	}
      if (is_end_of_stmt (*input_line_pointer)
	  && (bfd_section_flags (now_seg)
	      & (SEC_MERGE | SEC_STRINGS)) != 0)
	{
	  as_tsktsk (_("missing section entity size, 1 assumed"));
	  *entsize = 1;
	}
      else
	{
	  *entsize = get_absolute_expression ();
	  SKIP_WHITESPACE ();
	  if (*entsize <= 0)
	    {
	      as_warn (_("invalid section entity size"));
	      *attr &= ~(SHF_MERGE | SHF_STRINGS);
	      *has_entsize = false;
	      *entsize = 0;
	    }
	}
    }
  else if (*has_entsize && inherit
	    && ((bfd_section_flags (now_seg)
		 & (SEC_MERGE | SEC_STRINGS)) != 0
		|| now_seg->entsize))
    {
      *entsize = now_seg->entsize;
    }
  else if ((*attr & SHF_MERGE) != 0)
    {
      as_warn (_("entity size for SHF_MERGE not specified"));
      *attr &= ~(SHF_MERGE | SHF_STRINGS);
      *has_entsize = false;
    }
  else if ((*attr & SHF_STRINGS) != 0)
    {
      *entsize = 1;
    }
  else if (*has_entsize)
    {
      as_warn (_("entity size not specified"));
      *has_entsize = false;
    }
}

static void
parse_link_order(bfd_vma *attr, struct elf_section_match *match,
		unsigned long *linked_to_section_index, int inherit)
{
  if ((*attr & SHF_LINK_ORDER) != 0 && *input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (ISDIGIT (* input_line_pointer))
	{
	  *linked_to_section_index = strtoul (input_line_pointer, & input_line_pointer, 0);
	}
      else if (inherit && *input_line_pointer == ','
	       && (elf_section_flags (now_seg) & SHF_LINK_ORDER) != 0)
	{
	  if (now_seg->map_head.linked_to_symbol_name)
	    match->linked_to_symbol_name =
	      now_seg->map_head.linked_to_symbol_name;
	  else
	    *linked_to_section_index =
	      elf_section_data (now_seg)->this_hdr.sh_link;
	}
      else
	{
	  char c;
	  unsigned int length;
	  char *beg;

	  c = get_symbol_name (& beg);
	  (void) restore_line_pointer (c);
	  length = input_line_pointer - beg;
	  if (length)
	    match->linked_to_symbol_name
	      = notes_memdup (beg, length, length + 1);
	}
    }
  else if ((*attr & SHF_LINK_ORDER) != 0 && inherit
	   && (elf_section_flags (now_seg) & SHF_LINK_ORDER) != 0)
    {
      if (now_seg->map_head.linked_to_symbol_name)
	match->linked_to_symbol_name =
	  now_seg->map_head.linked_to_symbol_name;
      else
	*linked_to_section_index =
	  elf_section_data (now_seg)->this_hdr.sh_link;
    }
}

static void
parse_group_info(const char *name, bfd_vma *attr, struct elf_section_match *match,
		int *linkonce, bool is_clone, int inherit)
{
  if ((*attr & SHF_GROUP) != 0 && is_clone)
    {
      as_warn (_("? section flag ignored with G present"));
      is_clone = false;
    }

  if ((*attr & SHF_GROUP) != 0 && *input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (inherit && *input_line_pointer == ','
	  && (elf_section_flags (now_seg) & SHF_GROUP) != 0)
	{
	  match->group_name = elf_group_name (now_seg);
	  *linkonce = (bfd_section_flags (now_seg) & SEC_LINK_ONCE) != 0;
	}
      else
	{
	  match->group_name = obj_elf_section_name ();
	  if (match->group_name == NULL)
	    *attr &= ~SHF_GROUP;
	  else if (*input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      if (startswith (input_line_pointer, "comdat"))
		{
		  input_line_pointer += 6;
		  *linkonce = 1;
		}
	    }
	  else if (startswith (name, ".gnu.linkonce"))
	    *linkonce = 1;
	}
    }
  else if ((*attr & SHF_GROUP) != 0 && inherit
	   && (elf_section_flags (now_seg) & SHF_GROUP) != 0)
    {
      match->group_name = elf_group_name (now_seg);
      *linkonce = (bfd_section_flags (now_seg) & SEC_LINK_ONCE) != 0;
    }
  else if ((*attr & SHF_GROUP) != 0)
    {
      as_warn (_("group name for SHF_GROUP not specified"));
      *attr &= ~SHF_GROUP;
    }

  if (is_clone)
    {
      const char *now_group = elf_group_name (now_seg);
      if (now_group != NULL)
	{
	  match->group_name = now_group;
	  *linkonce = (now_seg->flags & SEC_LINK_ONCE) != 0;
	}
    }
}

static void
parse_mbind_info(struct elf_section_match *match)
{
  if (*input_line_pointer == ',')
    {
      char *save = input_line_pointer;
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (ISDIGIT (* input_line_pointer))
	{
	  char *t = input_line_pointer;
	  match->sh_info = strtoul (input_line_pointer,
				&input_line_pointer, 0);
	  if (match->sh_info == -1u)
	    {
	      as_warn (_("unsupported mbind section info: %s"), t);
	      match->sh_info = 0;
	    }
	}
      else
	input_line_pointer = save;
    }
}

static void
parse_unique_section(struct elf_section_match *match)
{
  if (*input_line_pointer == ',')
    {
      char *save = input_line_pointer;

      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (startswith (input_line_pointer, "unique"))
	{
	  input_line_pointer += 6;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      if (ISDIGIT (* input_line_pointer))
		{
		  bfd_vma id;
		  bool overflow;
		  char *t = input_line_pointer;
		  if (sizeof (bfd_vma) <= sizeof (unsigned long))
		    {
		      errno = 0;
		      id = strtoul (input_line_pointer,
				    &input_line_pointer, 0);
		      overflow = id == -1ul && errno == ERANGE;
		    }
		  else
		    {
		      id = bfd_scan_vma
			(input_line_pointer,
			 (const char **) &input_line_pointer, 0);
		      overflow = id == ~(bfd_vma) 0;
		    }
		  if (overflow || id > -1u)
		    {
		      char *linefeed, saved_char = 0;
		      if ((linefeed = strchr (t, '\n')) != NULL)
			{
			  saved_char = *linefeed;
			  *linefeed = '\0';
			}
		      as_bad (_("unsupported section id: %s"), t);
		      if (saved_char)
			*linefeed = saved_char;
		    }
		  else
		    {
		      match->section_id = id;
		      match->flags |= SEC_ASSEMBLER_SECTION_ID;
		    }
		}
	    }
	}
      else
	input_line_pointer = save;
    }
}

#ifdef TC_SPARC
static void
parse_sparc_section_attributes(bfd_vma *attr, int *type)
{
  do
    {
      char c;
      char *beg;

      SKIP_WHITESPACE ();
      if (*input_line_pointer != '#')
	{
	  as_bad (_("character following name is not '#'"));
	  ignore_rest_of_line ();
	  return;
	}
      ++input_line_pointer;
      c = get_symbol_name (& beg);
      (void) restore_line_pointer (c);

      *attr |= obj_elf_section_word (beg, input_line_pointer - beg,
				    type);

      SKIP_WHITESPACE ();
    }
  while (*input_line_pointer++ == ',');
  --input_line_pointer;
}
#endif

/* Change to the .bss section.  */

void obj_elf_bss(int i ATTRIBUTE_UNUSED)
{
    int subsection;

#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();

    subsection = get_absolute_expression();
    subseg_set(bss_section, subsection);
    demand_empty_rest_of_line();

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

/* Change to the .data section.  */

void obj_elf_data(int i)
{
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();
    s_data(i);

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

/* Change to the .text section.  */

void obj_elf_text(int i)
{
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();
    s_text(i);

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

/* Change to the *ABS* section.  */

void obj_elf_struct(int i)
{
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();
    s_struct(i);

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

static void
obj_elf_subsection (int ignore ATTRIBUTE_UNUSED)
{
  int subsection_number;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();

  subsection_number = get_absolute_expression ();
  subseg_set (now_seg, subsection_number);
  demand_empty_rest_of_line ();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* This can be called from the processor backends if they change
   sections.  */

void obj_elf_section_change_hook(void)
{
    previous_section = now_seg;
    previous_subsection = now_subseg;
}

void
obj_elf_previous (int ignore ATTRIBUTE_UNUSED)
{
  if (previous_section == NULL)
    {
      as_warn (_(".previous without corresponding .section; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();
  subseg_set (previous_section, previous_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_popsection (int xxx ATTRIBUTE_UNUSED)
{
  struct section_stack *top = section_stack;

  if (top == NULL)
    {
      as_warn (_(".popsection without corresponding .pushsection; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  section_stack = top->next;
  previous_section = top->prev_seg;
  previous_subsection = top->prev_subseg;
  subseg_set (top->seg, top->subseg);
  free (top);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_line (int ignore ATTRIBUTE_UNUSED)
{
  int line_number = get_absolute_expression ();
  new_logical_line (NULL, line_number);
  demand_empty_rest_of_line ();
}

static struct elf_versioned_name_list *
obj_elf_find_and_add_versioned_name (const char *version_name,
				     const char *sym_name,
				     const char *ver,
				     struct elf_obj_sy *sy_obj)
{
  struct elf_versioned_name_list *versioned_name;
  const char *p;
  int ver_char_count;

  if (!version_name || !sym_name || !ver || !sy_obj)
    return NULL;

  p = ver + 1;
  while (*p == ELF_VER_CHR)
    p++;

  ver_char_count = p - ver;

  if (ver_char_count != 1 && ver_char_count != 2 && ver_char_count != 3)
    {
      as_bad (_("invalid version name '%s' for symbol `%s'"),
	      version_name, sym_name);
      return NULL;
    }

  if (ver_char_count == 3)
    {
      if (sy_obj->rename)
	{
	  if (sy_obj->versioned_name && 
	      strcmp (sy_obj->versioned_name->name, version_name) == 0)
	    return sy_obj->versioned_name;
	  
	  as_bad (_("only one version name with `@@@' is allowed "
		    "for symbol `%s'"), sym_name);
	  return NULL;
	}
      sy_obj->rename = true;
    }

  versioned_name = sy_obj->versioned_name;
  while (versioned_name != NULL)
    {
      if (strcmp (versioned_name->name, version_name) == 0)
	return versioned_name;
      versioned_name = versioned_name->next;
    }

  versioned_name = notes_alloc (sizeof (*versioned_name));
  if (!versioned_name)
    return NULL;
    
  versioned_name->name = notes_strdup (version_name);
  if (!versioned_name->name)
    return NULL;
    
  versioned_name->next = sy_obj->versioned_name;
  sy_obj->versioned_name = versioned_name;

  return versioned_name;
}

/* This handles the .symver pseudo-op, which is used to specify a
   symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.
   SYMVERNAME may contain ELF_VER_CHR ('@') characters.  This
   pseudo-op causes the assembler to emit a symbol named SYMVERNAME
   with the same value as the symbol NAME.  */

static void
obj_elf_symver (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  const char *sym_name;
  char c;
  char old_lexat;
  symbolS *sym;
  struct elf_obj_sy *sy_obj;
  char *p;

  sym = get_sym_from_input_line_and_check ();
  if (!sym)
    {
      ignore_rest_of_line ();
      return;
    }

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .symver"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  old_lexat = lex_type[(unsigned char) '@'];
  lex_type[(unsigned char) '@'] |= LEX_NAME;
  c = get_symbol_name (&name);
  lex_type[(unsigned char) '@'] = old_lexat;
  
  if (!name)
    {
      ignore_rest_of_line ();
      return;
    }

  sym_name = S_GET_NAME (sym);
  if (!sym_name)
    {
      restore_line_pointer (c);
      ignore_rest_of_line ();
      return;
    }

  if (S_IS_COMMON (sym))
    {
      as_bad (_("`%s' can't be versioned to common symbol '%s'"),
              name, sym_name);
      restore_line_pointer (c);
      ignore_rest_of_line ();
      return;
    }

  p = strchr (name, ELF_VER_CHR);
  if (!p)
    {
      as_bad (_("missing version name in `%s' for symbol `%s'"),
              name, sym_name);
      restore_line_pointer (c);
      ignore_rest_of_line ();
      return;
    }

  sy_obj = symbol_get_obj (sym);
  if (!sy_obj)
    {
      restore_line_pointer (c);
      ignore_rest_of_line ();
      return;
    }

  if (!obj_elf_find_and_add_versioned_name (name, sym_name, p, sy_obj))
    {
      sy_obj->bad_version = true;
      restore_line_pointer (c);
      ignore_rest_of_line ();
      return;
    }

  restore_line_pointer (c);

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      
      if (startswith (input_line_pointer, "local"))
        {
          input_line_pointer += 5;
          sy_obj->visibility = visibility_local;
        }
      else if (startswith (input_line_pointer, "hidden"))
        {
          input_line_pointer += 6;
          sy_obj->visibility = visibility_hidden;
        }
      else if (startswith (input_line_pointer, "remove"))
        {
          input_line_pointer += 6;
          sy_obj->visibility = visibility_remove;
        }
      else
        {
          --input_line_pointer;
        }
    }

  demand_empty_rest_of_line ();
}

/* This handles the .vtable_inherit pseudo-op, which is used to indicate
   to the linker the hierarchy in which a particular table resides.  The
   syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */

struct fix *
obj_elf_get_vtable_inherit (void)
{
  char *cname, *pname;
  symbolS *csym, *psym;
  char c;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  c = get_symbol_name (&cname);
  csym = symbol_find (cname);
  restore_line_pointer (c);

  if (csym == NULL || symbol_get_frag (csym) == NULL)
    {
      as_bad (_("expected `%s' to have already been set for .vtable_inherit"),
              cname);
      ignore_rest_of_line ();
      return NULL;
    }

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .vtable_inherit"));
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  if (input_line_pointer[0] == '0'
      && (is_end_of_stmt (input_line_pointer[1])
          || is_whitespace (input_line_pointer[1])))
    {
      psym = section_symbol (absolute_section);
      ++input_line_pointer;
    }
  else
    {
      c = get_symbol_name (&pname);
      psym = symbol_find_or_make (pname);
      restore_line_pointer (c);
    }

  demand_empty_rest_of_line ();

  gas_assert (symbol_get_value_expression (csym)->X_op == O_constant);
  return fix_new (symbol_get_frag (csym),
                  symbol_get_value_expression (csym)->X_add_number,
                  0, psym, 0, 0, BFD_RELOC_VTABLE_INHERIT);
}

/* This is a version of obj_elf_get_vtable_inherit() that is
   suitable for use in struct _pseudo_type tables.  */

void obj_elf_vtable_inherit(int ignore ATTRIBUTE_UNUSED)
{
  obj_elf_get_vtable_inherit();
}

/* This handles the .vtable_entry pseudo-op, which is used to indicate
   to the linker that a vtable slot was used.  The syntax is
   ".vtable_entry tablename, offset".  */

struct fix *
obj_elf_get_vtable_entry (void)
{
  symbolS *sym;
  offsetT offset;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  sym = get_sym_from_input_line_and_check ();
  if (sym == NULL)
    return NULL;

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .vtable_entry"));
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;
  if (*input_line_pointer == '#')
    ++input_line_pointer;

  offset = get_absolute_expression ();

  demand_empty_rest_of_line ();

  return fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
		  BFD_RELOC_VTABLE_ENTRY);
}

/* This is a version of obj_elf_get_vtable_entry() that is
   suitable for use in struct _pseudo_type tables.  */

void obj_elf_vtable_entry(int ignore ATTRIBUTE_UNUSED)
{
    obj_elf_get_vtable_entry();
}

#define skip_whitespace(str)  do { if (is_whitespace (*(str))) ++(str); } while (0)

static inline int skip_past_char(char **str, char c)
{
    if (str == NULL || *str == NULL) {
        return -1;
    }
    
    if (**str == c) {
        (*str)++;
        return 0;
    }
    
    return -1;
}
#define skip_past_comma(str) skip_past_char (str, ',')

/* A list of attributes that have been explicitly set by the assembly code.
   VENDOR is the vendor id, BASE is the tag shifted right by the number
   of bits in MASK, and bit N of MASK is set if tag BASE+N has been set.  */
struct recorded_attribute_info {
  struct recorded_attribute_info *next;
  int vendor;
  unsigned int base;
  unsigned long mask;
};
static struct recorded_attribute_info *recorded_attributes;

/* Record that we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

static void
record_attribute (int vendor, unsigned int tag)
{
  const size_t bits_per_mask = 8 * sizeof(unsigned long);
  unsigned int base = tag / bits_per_mask;
  unsigned long mask = 1UL << (tag % bits_per_mask);
  struct recorded_attribute_info *rai = NULL;

  for (rai = recorded_attributes; rai != NULL; rai = rai->next)
    {
      if (rai->vendor == vendor && rai->base == base)
        {
          rai->mask |= mask;
          return;
        }
    }

  rai = XNEW (struct recorded_attribute_info);
  if (rai == NULL)
    return;

  rai->next = recorded_attributes;
  rai->vendor = vendor;
  rai->base = base;
  rai->mask = mask;
  recorded_attributes = rai;
}

/* Return true if we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

bool
obj_elf_seen_attribute (int vendor, unsigned int tag)
{
  const unsigned int bits_per_mask = 8 * sizeof(unsigned long);
  unsigned int base = tag / bits_per_mask;
  unsigned long mask = 1UL << (tag % bits_per_mask);
  
  for (struct recorded_attribute_info *rai = recorded_attributes; rai != NULL; rai = rai->next)
  {
    if (rai->vendor == vendor && rai->base == base)
    {
      return (rai->mask & mask) != 0;
    }
  }
  
  return false;
}

/* Parse an attribute directive for VENDOR.
   Returns the attribute number read, or zero on error.  */

int
obj_elf_vendor_attribute (int vendor)
{
  expressionS exp;
  int type;
  int tag;
  unsigned int i = 0;
  char *s = NULL;

  skip_whitespace (input_line_pointer);
  s = input_line_pointer;
  
  if (ISDIGIT (*input_line_pointer))
    {
      expression (&exp);
      if (exp.X_op != O_constant)
        {
          as_bad (_("expected <tag> , <value>"));
          ignore_rest_of_line ();
          return 0;
        }
      tag = exp.X_add_number;
    }
  else
    {
      char *name;
      
      for (; ISALNUM (*input_line_pointer) || *input_line_pointer == '_';
           ++input_line_pointer)
        i++;
        
      if (i == 0)
        {
          as_bad (_("expected <tag> , <value>"));
          ignore_rest_of_line ();
          return 0;
        }

      name = xmemdup0 (s, i);

#ifndef CONVERT_SYMBOLIC_ATTRIBUTE
#define CONVERT_SYMBOLIC_ATTRIBUTE(a) -1
#endif

      tag = CONVERT_SYMBOLIC_ATTRIBUTE (name);
      if (tag == -1)
        {
          as_bad (_("Attribute name not recognised: %s"), name);
          ignore_rest_of_line ();
          free (name);
          return 0;
        }
      free (name);
    }

  type = _bfd_elf_obj_attrs_arg_type (stdoutput, vendor, tag);

  if (skip_past_comma (&input_line_pointer) == -1)
    {
      as_bad (_("expected <tag> , <value>"));
      ignore_rest_of_line ();
      return 0;
    }
    
  if (type & 1)
    {
      expression (&exp);
      if (exp.X_op != O_constant)
        {
          as_bad (_("expected numeric constant"));
          ignore_rest_of_line ();
          return 0;
        }
      i = exp.X_add_number;
    }
    
  if ((type & 3) == 3 && skip_past_comma (&input_line_pointer) == -1)
    {
      as_bad (_("expected comma"));
      ignore_rest_of_line ();
      return 0;
    }
    
  if (type & 2)
    {
      int len;
      skip_whitespace (input_line_pointer);
      if (*input_line_pointer != '"')
        {
          as_bad (_("bad string constant"));
          ignore_rest_of_line ();
          return 0;
        }
      s = demand_copy_C_string (&len);
    }

  record_attribute (vendor, tag);
  
  bool ok = false;
  switch (type & 3)
    {
    case 3:
      ok = bfd_elf_add_obj_attr_int_string (stdoutput, vendor, tag, i, s);
      break;
    case 2:
      ok = bfd_elf_add_obj_attr_string (stdoutput, vendor, tag, s);
      break;
    case 1:
      ok = bfd_elf_add_obj_attr_int (stdoutput, vendor, tag, i);
      break;
    default:
      abort ();
    }
    
  if (!ok)
    as_fatal (_("error adding attribute: %s"), bfd_errmsg (bfd_get_error ()));

  demand_empty_rest_of_line ();
  return tag;
}

/* Parse a .gnu_attribute directive.  */

static void obj_elf_gnu_attribute(int ignored ATTRIBUTE_UNUSED)
{
    obj_elf_vendor_attribute(OBJ_ATTR_GNU);
}

void elf_obj_read_begin_hook(void)
{
#ifdef NEED_ECOFF_DEBUG
    if (ECOFF_DEBUGGING) {
        ecoff_read_begin_hook();
    }
#endif
}

void
elf_obj_symbol_new_hook (symbolS *symbolP)
{
  struct elf_obj_sy *sy_obj;

  if (symbolP == NULL)
    return;

  sy_obj = symbol_get_obj (symbolP);
  if (sy_obj != NULL)
  {
    sy_obj->size = NULL;
    sy_obj->versioned_name = NULL;
  }

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_symbol_new_hook (symbolP);
#endif
}

/* If size is unset, copy size from src.  Because we don't track whether
   .size has been used, we can't differentiate .size dest, 0 from the case
   where dest's size is unset.  */
void
elf_copy_symbol_size (symbolS *dest, symbolS *src)
{
  struct elf_obj_sy *srcelf;
  struct elf_obj_sy *destelf;
  
  if (dest == NULL || src == NULL)
    return;
    
  srcelf = symbol_get_obj (src);
  destelf = symbol_get_obj (dest);
  
  if (srcelf == NULL || destelf == NULL)
    return;
    
  if (destelf->size == NULL && S_GET_SIZE (dest) == 0)
    {
      destelf->size = srcelf->size;
      S_SET_SIZE (dest, S_GET_SIZE (src));
    }
}

void elf_copy_symbol_attributes(symbolS *dest, symbolS *src)
{
    if (dest == NULL || src == NULL) {
        return;
    }
    
    elf_copy_symbol_size(dest, src);
    
    unsigned char dest_visibility = ELF_ST_VISIBILITY(S_GET_OTHER(dest));
    unsigned char src_other_without_visibility = S_GET_OTHER(src) & ~ELF_ST_VISIBILITY(-1);
    unsigned char new_other = dest_visibility | src_other_without_visibility;
    
    S_SET_OTHER(dest, new_other);
}

void
obj_elf_version (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  unsigned int c;
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  Elf_Internal_Note i_note;
  Elf_External_Note e_note;
  asection *note_secp = NULL;
  unsigned int len;

  SKIP_WHITESPACE ();
  
  if (*input_line_pointer != '\"')
    {
      as_bad (_("expected quoted string"));
      demand_empty_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  name = input_line_pointer;

  while (is_a_char (c = next_char_of_string ()))
    ;
    
  c = *input_line_pointer;
  *input_line_pointer = '\0';
  *(input_line_pointer - 1) = '\0';
  *input_line_pointer = c;

  note_secp = subseg_new (".note", 0);
  if (note_secp == NULL)
    {
      subseg_set (seg, subseg);
      demand_empty_rest_of_line ();
      return;
    }
    
  bfd_set_section_flags (note_secp, SEC_HAS_CONTENTS | SEC_READONLY);
  record_alignment (note_secp, 2);

  len = strlen (name) + 1;

  i_note.namesz = len;
  i_note.descsz = 0;
  i_note.type = NT_VERSION;
  
  p = frag_more (sizeof (e_note.namesz));
  md_number_to_chars (p, i_note.namesz, sizeof (e_note.namesz));
  
  p = frag_more (sizeof (e_note.descsz));
  md_number_to_chars (p, i_note.descsz, sizeof (e_note.descsz));
  
  p = frag_more (sizeof (e_note.type));
  md_number_to_chars (p, i_note.type, sizeof (e_note.type));
  
  p = frag_more (len);
  memcpy (p, name, len);

  frag_align (2, 0, 0);

  subseg_set (seg, subseg);
  demand_empty_rest_of_line ();
}

static void
obj_elf_size (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c = get_symbol_name (&name);
  char *p = input_line_pointer;
  expressionS exp;
  symbolS *sym;

  restore_line_pointer (c);
  SKIP_WHITESPACE ();
  
  if (*input_line_pointer != ',')
    {
      *p = 0;
      as_bad (_("expected comma after name `%s' in .size directive"), name);
      *p = c;
      ignore_rest_of_line ();
      return;
    }
  
  input_line_pointer++;
  expression (&exp);
  
  if (exp.X_op == O_absent)
    {
      as_bad (_("missing expression in .size directive"));
      exp.X_op = O_constant;
      exp.X_add_number = 0;
    }
  
  *p = 0;
  sym = symbol_find_or_make (name);
  *p = c;
  
  if (sym == NULL)
    {
      as_bad (_("failed to create symbol"));
      ignore_rest_of_line ();
      return;
    }
  
  if (exp.X_op == O_constant)
    {
      S_SET_SIZE (sym, exp.X_add_number);
      symbol_get_obj (sym)->size = NULL;
    }
  else
    {
      expressionS *size_exp = notes_alloc (sizeof (expressionS));
      if (size_exp != NULL)
        {
          *size_exp = exp;
          symbol_get_obj (sym)->size = size_exp;
        }
    }

  if (flag_synth_cfi && S_IS_FUNCTION (sym) && sym == ginsn_data_func_symbol ())
    {
      ginsn_data_end (symbol_temp_new_now ());
    }

  demand_empty_rest_of_line ();
}

/* Handle the ELF .type pseudo-op.  This sets the type of a symbol.
   There are six syntaxes:

   The first (used on Solaris) is
       .type SYM,#function
   The second (used on UnixWare) is
       .type SYM,@function
   The third (reportedly to be used on Irix 6.0) is
       .type SYM STT_FUNC
   The fourth (used on NetBSD/Arm and Linux/ARM) is
       .type SYM,%function
   The fifth (used on SVR4/860) is
       .type SYM,"function"
   The sixth (emitted by recent SunPRO under Solaris) is
       .type SYM,[0-9]
   where the integer is the STT_* value.
   */

static char *
obj_elf_type_name (char *cp)
{
  char *p = input_line_pointer;
  
  if (*p >= '0' && *p <= '9')
    {
      while (*input_line_pointer >= '0' && *input_line_pointer <= '9')
        {
          ++input_line_pointer;
        }
      *cp = *input_line_pointer;
      *input_line_pointer = '\0';
    }
  else
    {
      *cp = get_symbol_name (&p);
    }

  return p;
}

static void
obj_elf_type (int ignore ATTRIBUTE_UNUSED)
{
  char c;
  int type;
  const char *type_name;
  symbolS *sym;
  elf_symbol_type *elfsym;

  sym = get_sym_from_input_line_and_check ();
  if (!sym)
    return;
    
  c = *input_line_pointer;
  elfsym = (elf_symbol_type *) symbol_get_bfdsym (sym);
  if (!elfsym)
    return;

  if (*input_line_pointer == ',')
    ++input_line_pointer;

  SKIP_WHITESPACE ();
  
  const char *type_prefixes = "#@\"%";
  if (strchr(type_prefixes, *input_line_pointer))
    ++input_line_pointer;

  type_name = obj_elf_type_name (&c);
  if (!type_name)
    {
      *input_line_pointer = c;
      return;
    }

  type = get_symbol_type(type_name, sym, elfsym);
  
  *input_line_pointer = c;

  if (*input_line_pointer == '"')
    ++input_line_pointer;

  apply_symbol_type(sym, elfsym, type);
  
  handle_function_symbol_cfi(sym);

  demand_empty_rest_of_line ();
}

static int
get_symbol_type(const char *type_name, symbolS *sym, elf_symbol_type *elfsym)
{
  if (!type_name)
    return 0;
    
  if (is_function_type(type_name))
    return BSF_FUNCTION;
    
  if (is_object_type(type_name))
    return BSF_OBJECT;
    
  if (is_tls_type(type_name))
    return BSF_OBJECT | BSF_THREAD_LOCAL;
    
  if (is_notype(type_name))
    return 0;
    
  if (is_common_type(type_name))
    return handle_common_type(sym);
    
  if (is_gnu_indirect_function(type_name))
    return handle_gnu_indirect_function(type_name);
    
  if (is_gnu_unique_object(type_name))
    return handle_gnu_unique_object(type_name);

#ifdef md_elf_symbol_type
  int md_type = md_elf_symbol_type(type_name, sym, elfsym);
  if (md_type != -1)
    return md_type;
#endif

  as_bad(_("unrecognized symbol type \"%s\""), type_name);
  return 0;
}

static int
is_function_type(const char *type_name)
{
  return strcmp(type_name, "function") == 0 ||
         strcmp(type_name, "2") == 0 ||
         strcmp(type_name, "STT_FUNC") == 0;
}

static int
is_object_type(const char *type_name)
{
  return strcmp(type_name, "object") == 0 ||
         strcmp(type_name, "1") == 0 ||
         strcmp(type_name, "STT_OBJECT") == 0;
}

static int
is_tls_type(const char *type_name)
{
  return strcmp(type_name, "tls_object") == 0 ||
         strcmp(type_name, "6") == 0 ||
         strcmp(type_name, "STT_TLS") == 0;
}

static int
is_notype(const char *type_name)
{
  return strcmp(type_name, "notype") == 0 ||
         strcmp(type_name, "0") == 0 ||
         strcmp(type_name, "STT_NOTYPE") == 0;
}

static int
is_common_type(const char *type_name)
{
  return strcmp(type_name, "common") == 0 ||
         strcmp(type_name, "5") == 0 ||
         strcmp(type_name, "STT_COMMON") == 0;
}

static int
is_gnu_indirect_function(const char *type_name)
{
  return strcmp(type_name, "gnu_indirect_function") == 0 ||
         strcmp(type_name, "10") == 0 ||
         strcmp(type_name, "STT_GNU_IFUNC") == 0;
}

static int
is_gnu_unique_object(const char *type_name)
{
  return strcmp(type_name, "gnu_unique_object") == 0;
}

static int
handle_common_type(symbolS *sym)
{
  if (S_IS_COMMON(sym))
    return BSF_OBJECT;
    
  if (S_IS_VOLATILE(sym))
    {
      sym = symbol_clone(sym, 1);
      S_SET_SEGMENT(sym, bfd_com_section_ptr);
      S_SET_VALUE(sym, 0);
      S_SET_EXTERNAL(sym);
      symbol_set_frag(sym, &zero_address_frag);
      S_CLEAR_VOLATILE(sym);
    }
  else if (S_IS_DEFINED(sym) || symbol_equated_p(sym))
    {
      as_bad(_("symbol '%s' is already defined"), S_GET_NAME(sym));
    }
  else
    {
      S_SET_SEGMENT(sym, bfd_com_section_ptr);
      S_SET_VALUE(sym, 0);
      S_SET_EXTERNAL(sym);
    }
    
  return BSF_OBJECT;
}

static int
handle_gnu_indirect_function(const char *type_name)
{
  const struct elf_backend_data *bed = get_elf_backend_data(stdoutput);
  
  if (!bed)
    return 0;
    
  if (bed->elf_osabi != ELFOSABI_NONE &&
      bed->elf_osabi != ELFOSABI_GNU &&
      bed->elf_osabi != ELFOSABI_FREEBSD)
    {
      as_bad(_("symbol type \"%s\" is supported only by GNU "
               "and FreeBSD targets"), type_name);
      return 0;
    }
    
  if (bed->target_id == MIPS_ELF_DATA)
    {
      as_bad(_("symbol type \"%s\" is not supported by "
               "MIPS targets"), type_name);
      return 0;
    }
    
  elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
  return BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION;
}

static int
handle_gnu_unique_object(const char *type_name)
{
  const struct elf_backend_data *bed = get_elf_backend_data(stdoutput);
  
  if (!bed)
    return 0;
    
  if (bed->elf_osabi != ELFOSABI_NONE &&
      bed->elf_osabi != ELFOSABI_GNU)
    {
      as_bad(_("symbol type \"%s\" is supported only by GNU targets"),
             type_name);
      return 0;
    }
    
  elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_unique;
  return BSF_OBJECT | BSF_GNU_UNIQUE;
}

static void
apply_symbol_type(symbolS *sym, elf_symbol_type *elfsym, int type)
{
#ifdef md_elf_symbol_type_change
  if (md_elf_symbol_type_change(sym, elfsym, type))
    return;
#endif

  flagword mask = BSF_FUNCTION | BSF_OBJECT;

  if (type != BSF_FUNCTION)
    mask |= BSF_GNU_INDIRECT_FUNCTION;
    
  if (type != BSF_OBJECT)
    {
      mask |= BSF_GNU_UNIQUE | BSF_THREAD_LOCAL;

      if (S_IS_COMMON(sym))
        {
          as_bad(_("cannot change type of common symbol '%s'"),
                 S_GET_NAME(sym));
          return;
        }
    }

  if (type)
    {
      flagword new_flags = (elfsym->symbol.flags & ~mask) | type;

      if (new_flags != (elfsym->symbol.flags | type))
        as_warn(_("symbol '%s' already has its type set"), S_GET_NAME(sym));
        
      elfsym->symbol.flags = new_flags;
    }
  else
    {
      elfsym->symbol.flags &= ~mask;
    }
}

static void
handle_function_symbol_cfi(symbolS *sym)
{
  if (!S_IS_FUNCTION(sym) || !flag_synth_cfi)
    return;
    
  if (frchain_now->frch_ginsn_data)
    ginsn_data_end(symbol_temp_new_now());
    
  ginsn_data_begin(sym);
}

static segT comment_section;

static void
obj_elf_ident (int ignore ATTRIBUTE_UNUSED)
{
  segT old_section = now_seg;
  int old_subsection = now_subseg;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (!comment_section)
    {
      char *p;
      comment_section = subseg_new (".comment", 0);
      bfd_set_section_flags (comment_section, (SEC_READONLY | SEC_HAS_CONTENTS
					       | SEC_MERGE | SEC_STRINGS));
      comment_section->entsize = 1;
      p = frag_more (1);
      *p = 0;
    }
  else
    {
      subseg_set (comment_section, 0);
    }

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif

  stringer (8 + 1);
  subseg_set (old_section, old_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

#ifdef INIT_STAB_SECTION

/* The first entry in a .stabs section is special.  */

void
obj_elf_init_stab_section (segT stab, segT stabstr)
{
  char *file;
  char *p;
  unsigned int stroff;

  /* Force the section to align to a longword boundary.  Without this,
     UnixWare ar crashes.  */
  bfd_set_section_alignment (stab, 2);

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  file = remap_debug_filename (as_where (NULL));
  stroff = get_stab_string_offset (file, stabstr);
  know (stroff == 1 || (stroff == 0 && file[0] == '\0'));
  md_number_to_chars (p, stroff, 4);
  seg_info (stab)->stabu.p = p;
  free (file);
}

#endif

/* Called via bfd_map_over_sections.  If SEC's linked_to_symbol_name
   isn't NULL, set up its linked-to section.
   For .stabs section, fill in the counts in the first entry.  */

static void
set_additional_section_info (bfd *abfd,
			     asection *sec,
			     void *inf ATTRIBUTE_UNUSED)
{
  if (sec->map_head.linked_to_symbol_name)
    {
      symbolS *linked_to_sym;
      linked_to_sym = symbol_find (sec->map_head.linked_to_symbol_name);
      if (!linked_to_sym || !S_IS_DEFINED (linked_to_sym))
	as_bad (_("undefined linked-to symbol `%s' on section `%s'"),
		sec->map_head.linked_to_symbol_name,
		bfd_section_name (sec));
      else
	elf_linked_to_section (sec) = S_GET_SEGMENT (linked_to_sym);
    }

  if (!startswith (sec->name, ".stab"))
    return;
  
  size_t name_len = strlen (sec->name);
  if (name_len >= 3 && !strcmp ("str", sec->name + name_len - 3))
    return;

  char *name = concat (sec->name, "str", (const char *) NULL);
  if (!name)
    return;
  
  asection *strsec = bfd_get_section_by_name (abfd, name);
  int strsz = strsec ? bfd_section_size (strsec) : 0;
  int nsyms = bfd_section_size (sec) / 12 - 1;

  char *p = seg_info (sec)->stabu.p;
  gas_assert (p != 0);

  bfd_h_put_16 (abfd, nsyms, p + 6);
  bfd_h_put_32 (abfd, strsz, p + 8);
  free (name);
}

#ifdef NEED_ECOFF_DEBUG

/* This function is called by the ECOFF code.  It is supposed to
   record the external symbol information so that the backend can
   write it out correctly.  The ELF backend doesn't actually handle
   this at the moment, so we do it ourselves.  We save the information
   in the symbol.  */

#ifdef OBJ_MAYBE_ELF
static
#endif
void
elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)
{
  symbol_get_bfdsym (sym)->udata.p = ext;
}

/* This function is called by bfd_ecoff_debug_externals.  It is
   supposed to *EXT to the external symbol information, and return
   whether the symbol should be used at all.  */

static bool
elf_get_extr (asymbol *sym, EXTR *ext)
{
  if (sym->udata.p == NULL)
    return false;
  *ext = *(EXTR *) sym->udata.p;
  return true;
}

/* This function is called by bfd_ecoff_debug_externals.  It has
   nothing to do for ELF.  */

static void
elf_set_index (asymbol *sym ATTRIBUTE_UNUSED,
	       bfd_size_type indx ATTRIBUTE_UNUSED)
{
}

#endif /* NEED_ECOFF_DEBUG */

void
elf_frob_symbol (symbolS *symp, int *puntp)
{
  struct elf_obj_sy *sy_obj;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_frob_symbol (symp);
#endif

  sy_obj = symbol_get_obj (symp);

  if (sy_obj->size != NULL)
    {
      process_symbol_size(symp, sy_obj);
    }

  if (sy_obj->versioned_name)
    {
      process_versioned_symbol(symp, sy_obj, puntp);
    }

  validate_weak_symbol(symp);
}

static void
process_symbol_size(symbolS *symp, struct elf_obj_sy *sy_obj)
{
  expressionS *size = sy_obj->size;
  
  if (resolve_expression (size) && size->X_op == O_constant)
    {
      S_SET_SIZE (symp, size->X_add_number);
    }
  else
    {
      const char *msg = _(".size expression for %s does not evaluate to a constant");
      if (!flag_allow_nonconst_size)
        as_bad (msg, S_GET_NAME (symp));
      else
        as_warn (msg, S_GET_NAME (symp));
    }
  
  sy_obj->size = NULL;
}

static void
process_versioned_symbol(symbolS *symp, struct elf_obj_sy *sy_obj, int *puntp)
{
  struct elf_versioned_name_list *versioned_name = sy_obj->versioned_name;
  
  if (sy_obj->bad_version)
    {
      *puntp = true;
      return;
    }
  
  if (sy_obj->rename)
    {
      S_SET_NAME (symp, versioned_name->name);
      return;
    }
  
  if (S_IS_COMMON (symp))
    {
      as_bad (_("`%s' can't be versioned to common symbol '%s'"),
              versioned_name->name, S_GET_NAME (symp));
      *puntp = true;
      return;
    }
  
  create_version_aliases(symp, versioned_name);
  apply_visibility_settings(symp, sy_obj);
}

static void
create_version_aliases(symbolS *symp, struct elf_versioned_name_list *versioned_name)
{
  for (; versioned_name != NULL; versioned_name = versioned_name->next)
    {
      symbolS *symp2 = symbol_find_or_make (versioned_name->name);
      
      S_SET_SEGMENT (symp2, S_GET_SEGMENT (symp));
      S_SET_VALUE (symp2,
                   (S_GET_VALUE (symp)
                    - (symbol_get_frag (symp)->fr_address / OCTETS_PER_BYTE)));
      
      symbol_set_frag (symp2, symbol_get_frag (symp));
      copy_symbol_attributes (symp2, symp);
      S_SET_OTHER (symp2, S_GET_OTHER (symp));
      
      if (S_IS_WEAK (symp))
        S_SET_WEAK (symp2);
      
      if (S_IS_EXTERNAL (symp))
        S_SET_EXTERNAL (symp2);
    }
}

static void
apply_visibility_settings(symbolS *symp, struct elf_obj_sy *sy_obj)
{
  switch (sy_obj->visibility)
    {
    case visibility_unchanged:
      break;
      
    case visibility_hidden:
      set_symbol_hidden(symp);
      break;
      
    case visibility_remove:
      handle_symbol_removal(symp, sy_obj);
      break;
      
    case visibility_local:
      S_CLEAR_EXTERNAL (symp);
      break;
    }
}

static void
set_symbol_hidden(symbolS *symp)
{
  asymbol *bfdsym = symbol_get_bfdsym (symp);
  elf_symbol_type *elfsym = elf_symbol_from (bfdsym);
  elfsym->internal_elf_sym.st_other &= ~3;
  elfsym->internal_elf_sym.st_other |= STV_HIDDEN;
}

static void
handle_symbol_removal(symbolS *symp, struct elf_obj_sy *sy_obj)
{
  if (symbol_used_in_reloc_p (symp))
    {
      if (sy_obj->versioned_name->next != NULL)
        {
          as_bad (_("symbol '%s' with multiple versions cannot be used in relocation"),
                  S_GET_NAME (symp));
        }
      symbol_mark_removed (symp);
    }
  else
    {
      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
    }
}

static void
validate_weak_symbol(symbolS *symp)
{
  if (S_IS_WEAK (symp) && S_IS_COMMON (symp))
    {
      as_bad (_("symbol `%s' can not be both weak and common"),
              S_GET_NAME (symp));
    }
}

/* Fix up SYMPP which has been marked to be removed by .symver.  */

void
elf_fixup_removed_symbol (symbolS **sympp)
{
  symbolS *symp;
  struct elf_obj_sy *sy_obj;
  
  if (sympp == NULL || *sympp == NULL)
    return;
    
  symp = *sympp;
  sy_obj = symbol_get_obj (symp);
  
  if (sy_obj == NULL || sy_obj->versioned_name == NULL || sy_obj->versioned_name->name == NULL)
    return;
    
  symp = symbol_find (sy_obj->versioned_name->name);
  if (symp != NULL)
    *sympp = symp;
}

/* Create symbols for group signature.  */

void
elf_adjust_symtab (void)
{
  unsigned int i;

  for (i = 0; i < groups.num_group; i++)
    {
      const char *group_name = elf_group_name (groups.head[i]);
      asection *s;
      flagword flags;
      struct symbol *sy;

      flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;
      
      for (s = groups.head[i]; s != NULL; s = elf_next_in_group (s))
        {
          if ((s->flags ^ flags) & SEC_LINK_ONCE)
            {
              flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
              if (s != groups.head[i])
                {
                  as_warn (_("assuming all members of group `%s' are COMDAT"),
                           group_name);
                }
              break;
            }
        }

      s = subseg_force_new (".group", 0);
      if (s == NULL)
        {
          as_fatal (_("can't create group: %s"),
                    bfd_errmsg (bfd_get_error ()));
        }
      
      if (!bfd_set_section_flags (s, flags))
        {
          as_fatal (_("can't create group: %s"),
                    bfd_errmsg (bfd_get_error ()));
        }
      
      if (!bfd_set_section_alignment (s, 2))
        {
          as_fatal (_("can't create group: %s"),
                    bfd_errmsg (bfd_get_error ()));
        }
      
      elf_section_type (s) = SHT_GROUP;
      elf_next_in_group (s) = groups.head[i];
      elf_sec_group (groups.head[i]) = s;
      
      sy = symbol_find_exact (group_name);
      if (sy == NULL || !symbol_on_chain (sy, symbol_rootP, symbol_lastP))
        {
          sy = symbol_new (group_name, now_seg, frag_now, 0);
#ifdef TE_SOLARIS
          symbol_get_bfdsym (sy)->flags |= BSF_WEAK;
          S_SET_OTHER (sy, STV_HIDDEN);
#else
          symbol_get_obj (sy)->local = 1;
#endif
          symbol_table_insert (sy);
        }
      
      elf_group_id (s) = symbol_get_bfdsym (sy);
      symbol_mark_used_in_reloc (sy);
    }
}

void
elf_frob_file (void)
{
  if (stdoutput != NULL)
  {
    bfd_map_over_sections (stdoutput, set_additional_section_info, NULL);
  }

#ifdef elf_tc_final_processing
  elf_tc_final_processing ();
#endif
}

/* It removes any unneeded versioned symbols from the symbol table.  */

void
elf_frob_file_before_adjust (void)
{
  if (!symbol_rootP)
    return;

  symbolS *symp = symbol_rootP;
  while (symp)
    {
      symbolS *next_sym = symbol_next (symp);
      struct elf_obj_sy *sy_obj = symbol_get_obj (symp);
      int is_defined = S_IS_DEFINED (symp) ? 1 : 0;

      if (sy_obj->versioned_name)
        {
          char *p = strchr (sy_obj->versioned_name->name, ELF_VER_CHR);
          
          if (p == NULL)
            {
              symp = next_sym;
              continue;
            }

          if (sy_obj->rename)
            {
              size_t l = strlen (&p[3]) + 1;
              memmove (&p[1 + is_defined], &p[3], l);
            }
          else if (!is_defined)
            {
              if (p[1] == ELF_VER_CHR)
                {
                  as_bad (_("invalid attempt to declare external "
                            "version name as default in symbol `%s'"),
                          sy_obj->versioned_name->name);
                  return;
                }

              if (sy_obj->versioned_name->next)
                {
                  as_bad (_("multiple versions [`%s'|`%s'] for "
                            "symbol `%s'"),
                          sy_obj->versioned_name->name,
                          sy_obj->versioned_name->next->name,
                          S_GET_NAME (symp));
                  return;
                }

              sy_obj->rename = true;
            }
        }

      if (!is_defined
          && (sy_obj->versioned_name || S_IS_WEAK (symp))
          && symbol_used_p (symp) == 0
          && symbol_used_in_reloc_p (symp) == 0)
        {
          symbol_remove (symp, &symbol_rootP, &symbol_lastP);
        }

      symp = next_sym;
    }
}

/* It is required that we let write_relocs have the opportunity to
   optimize away fixups before output has begun, since it is possible
   to eliminate all fixups for a section and thus we never should
   have generated the relocation section.  */

void
elf_frob_file_after_relocs (void)
{
  unsigned int i;

  for (i = 0; i < groups.num_group; i++)
    {
      asection *s, *head, *group;
      bfd_size_type size;

      head = groups.head[i];
      size = 4;
      for (s = head; s != NULL; s = elf_next_in_group (s))
	size += (s->flags & SEC_RELOC) != 0 ? 8 : 4;

      group = elf_sec_group (head);
      subseg_set (group, 0);
      bfd_set_section_size (group, size);
      group->contents = (unsigned char *) frag_more (size);
      group->alloced = 1;
      frag_now->fr_fix = frag_now_fix_octets ();
      frag_wane (frag_now);
    }

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    {
      const struct ecoff_debug_swap *debug_swap;
      struct ecoff_debug_info debug;
      char *buf;
      asection *sec;

      debug_swap
	= get_elf_backend_data (stdoutput)->elf_backend_ecoff_debug_swap;
      know (debug_swap != NULL);
      ecoff_build_debug (&debug.symbolic_header, &buf, debug_swap);

      debug.alloc_syments = true;
      debug.line = (unsigned char *) (buf + debug.symbolic_header.cbLineOffset);
      debug.external_dnr = (void *) (buf + debug.symbolic_header.cbDnOffset);
      debug.external_pdr = (void *) (buf + debug.symbolic_header.cbPdOffset);
      debug.external_sym = (void *) (buf + debug.symbolic_header.cbSymOffset);
      debug.external_opt = (void *) (buf + debug.symbolic_header.cbOptOffset);
      debug.external_aux = (union aux_ext *) (buf + debug.symbolic_header.cbAuxOffset);
      debug.ss = (char *) (buf + debug.symbolic_header.cbSsOffset);
      debug.external_fdr = (void *) (buf + debug.symbolic_header.cbFdOffset);
      debug.external_rfd = (void *) (buf + debug.symbolic_header.cbRfdOffset);

      debug.ssext = debug.ssext_end = NULL;
      debug.external_ext = debug.external_ext_end = NULL;
      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, true,
				       elf_get_extr, elf_set_index))
	as_fatal (_("failed to set up debugging information: %s"),
		  bfd_errmsg (bfd_get_error ()));

      sec = bfd_get_section_by_name (stdoutput, ".mdebug");
      gas_assert (sec != NULL);

      know (!stdoutput->output_has_begun);

      bfd_set_section_size (sec, bfd_ecoff_debug_size (stdoutput, &debug,
						       debug_swap));

      if (! bfd_set_section_contents (stdoutput, sec, buf, 0, 0))
	as_fatal (_("can't start writing .mdebug section: %s"),
		  bfd_errmsg (bfd_get_error ()));

      know (stdoutput->output_has_begun);
      know (sec->filepos != 0);

      if (! bfd_ecoff_write_debug (stdoutput, &debug, debug_swap,
				   sec->filepos))
	as_fatal (_("could not write .mdebug section: %s"),
		  bfd_errmsg (bfd_get_error ()));
    }
#endif
}

/* This is called when the assembler starts.  */

void
elf_begin (void)
{
  static const char *const section_names[] = {
    TEXT_SECTION_NAME,
    DATA_SECTION_NAME,
    BSS_SECTION_NAME
  };
  
  for (size_t i = 0; i < sizeof(section_names) / sizeof(section_names[0]); i++)
  {
    asection *section = bfd_get_section_by_name (stdoutput, section_names[i]);
    if (section != NULL)
    {
      symbol_table_insert (section_symbol (section));
    }
  }
  
  elf_com_section_ptr = bfd_com_section_ptr;
  previous_section = NULL;
  previous_subsection = 0;
  comment_section = NULL;
  memset (&groups, 0, sizeof (groups));
}

void elf_end(void)
{
    struct section_stack *current_section = section_stack;
    struct section_stack *next_section = NULL;
    
    while (current_section != NULL)
    {
        next_section = current_section->next;
        free(current_section);
        current_section = next_section;
    }
    section_stack = NULL;
    
    struct recorded_attribute_info *current_attr = recorded_attributes;
    struct recorded_attribute_info *next_attr = NULL;
    
    while (current_attr != NULL)
    {
        next_attr = current_attr->next;
        free(current_attr);
        current_attr = next_attr;
    }
    recorded_attributes = NULL;
    
    if (groups.indexes != NULL)
    {
        htab_delete(groups.indexes);
        groups.indexes = NULL;
    }
    
    if (groups.head != NULL)
    {
        free(groups.head);
        groups.head = NULL;
    }
}

#ifdef USE_EMULATIONS

static bfd_vma
elf_s_get_size (symbolS *sym)
{
  return S_GET_SIZE (sym);
}

static void
elf_s_set_size (symbolS *sym, bfd_vma sz)
{
  S_SET_SIZE (sym, sz);
}

static bfd_vma
elf_s_get_align (symbolS *sym)
{
  return S_GET_ALIGN (sym);
}

static void
elf_s_set_align (symbolS *sym, bfd_vma align)
{
  S_SET_ALIGN (sym, align);
}

int
elf_s_get_other (symbolS *sym)
{
  return elf_symbol (symbol_get_bfdsym (sym))->internal_elf_sym.st_other;
}

static void
elf_s_set_other (symbolS *sym, int other)
{
  S_SET_OTHER (sym, other);
}

static int
elf_sec_sym_ok_for_reloc (asection *sec)
{
  return obj_sec_sym_ok_for_reloc (sec);
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_process_stab (int what ATTRIBUTE_UNUSED,
		  const char *string ATTRIBUTE_UNUSED,
		  int type ATTRIBUTE_UNUSED,
		  int other ATTRIBUTE_UNUSED,
		  int desc ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_stab (what, string, type, other, desc);
}
#else
# define elf_process_stab NULL
#endif

static int
elf_separate_stab_sections (void)
{
#ifdef NEED_ECOFF_DEBUG
  return (!ECOFF_DEBUGGING);
#else
  return 1;
#endif
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_init_stab_section (segT stab, segT stabstr)
{
  if (!ECOFF_DEBUGGING)
    obj_elf_init_stab_section (stab, stabstr);
}
#endif

const struct format_ops elf_format_ops =
{
  bfd_target_elf_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  elf_begin,
  elf_end,
  elf_file_symbol,
  NULL, /* assign_symbol */
  elf_frob_symbol,
  elf_frob_file,
  elf_frob_file_before_adjust,
  0,	/* obj_frob_file_before_fix */
  elf_frob_file_after_relocs,
  elf_s_get_size, elf_s_set_size,
  elf_s_get_align, elf_s_set_align,
  elf_s_get_other,
  elf_s_set_other,
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  elf_copy_symbol_attributes,
  elf_process_stab,
  elf_separate_stab_sections,
#ifdef NEED_ECOFF_DEBUG
  elf_init_stab_section,
#else
  obj_elf_init_stab_section,
#endif
  elf_sec_sym_ok_for_reloc,
  elf_pop_insert,
#ifdef NEED_ECOFF_DEBUG
  elf_ecoff_set_ext,
#else
  0,	/* ecoff_set_ext */
#endif
  elf_obj_read_begin_hook,
  elf_obj_symbol_new_hook,
  0,
  elf_adjust_symtab
};

#endif /* USE_EMULATIONS */
