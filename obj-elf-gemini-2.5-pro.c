/* ELF object file format
   Copyright (C) 1992-2025 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 3,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#define OBJ_HEADER "obj-elf.h"
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "obstack.h"
#include "dwarf2dbg.h"
#include "ginsn.h"

#ifndef ECOFF_DEBUGGING
#define ECOFF_DEBUGGING 0
#else
#define NEED_ECOFF_DEBUG
#endif

#ifdef NEED_ECOFF_DEBUG
#include "ecoff.h"
#include "bfd/ecoff-bfd.h"
#endif

#ifdef TC_ALPHA
#include "elf/alpha.h"
#endif

#ifdef TC_MIPS
#include "elf/mips.h"
#endif

#ifdef TC_PPC
#include "elf/ppc.h"
#endif

#ifdef TC_I386
#include "elf/x86-64.h"
#endif

#ifdef TC_MEP
#include "elf/mep.h"
#endif

#ifdef TC_PRU
#include "elf/pru.h"
#endif

static void obj_elf_line (int);
static void obj_elf_size (int);
static void obj_elf_type (int);
static void obj_elf_ident (int);
static void obj_elf_weak (int);
static void obj_elf_local (int);
static void obj_elf_visibility (int);
static void obj_elf_symver (int);
static void obj_elf_subsection (int);
static void obj_elf_popsection (int);
static void obj_elf_gnu_attribute (int);
static void obj_elf_tls_common (int);
static void obj_elf_lcomm (int);
static void obj_elf_struct (int);
static void obj_elf_attach_to_group (int);

static const pseudo_typeS elf_pseudo_table[] =
{
  {"attach_to_group", obj_elf_attach_to_group, 0},
  {"comm", obj_elf_common, 0},
  {"common", obj_elf_common, 1},
  {"ident", obj_elf_ident, 0},
  {"lcomm", obj_elf_lcomm, 0},
  {"local", obj_elf_local, 0},
  {"previous", obj_elf_previous, 0},
  {"section", obj_elf_section, 0},
  {"section.s", obj_elf_section, 0},
  {"sect", obj_elf_section, 0},
  {"sect.s", obj_elf_section, 0},
  {"pushsection", obj_elf_section, 1},
  {"popsection", obj_elf_popsection, 0},
  {"size", obj_elf_size, 0},
  {"type", obj_elf_type, 0},
  {"version", obj_elf_version, 0},
  {"weak", obj_elf_weak, 0},

  /* These define symbol visibility.  */
  {"internal", obj_elf_visibility, STV_INTERNAL},
  {"hidden", obj_elf_visibility, STV_HIDDEN},
  {"protected", obj_elf_visibility, STV_PROTECTED},

  /* These are used for stabs-in-elf configurations.  */
  {"line", obj_elf_line, 0},

  /* This is a GNU extension to handle symbol versions.  */
  {"symver", obj_elf_symver, 0},

  /* A GNU extension to change subsection only.  */
  {"subsection", obj_elf_subsection, 0},

  /* These are GNU extensions to aid in garbage collecting C++ vtables.  */
  {"vtable_inherit", obj_elf_vtable_inherit, 0},
  {"vtable_entry", obj_elf_vtable_entry, 0},

  /* A GNU extension for object attributes.  */
  {"gnu_attribute", obj_elf_gnu_attribute, 0},

  /* These are used for dwarf2.  */
  { "file", dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },
  { "loc_mark_labels", dwarf2_directive_loc_mark_labels, 0 },

  /* We need to trap the section changing calls to handle .previous.  */
  {"data", obj_elf_data, 0},
  {"offset", obj_elf_struct, 0},
  {"struct", obj_elf_struct, 0},
  {"text", obj_elf_text, 0},
  {"bss", obj_elf_bss, 0},

  {"tls_common", obj_elf_tls_common, 0},

  /* End sentinel.  */
  {NULL, NULL, 0},
};

static const pseudo_typeS ecoff_debug_pseudo_table[] =
{
#ifdef NEED_ECOFF_DEBUG
  /* COFF style debugging information for ECOFF. .ln is not used; .loc
     is used instead.  */
  { "def",	ecoff_directive_def,	0 },
  { "dim",	ecoff_directive_dim,	0 },
  { "endef",	ecoff_directive_endef,	0 },
  { "file",	ecoff_directive_file,	0 },
  { "scl",	ecoff_directive_scl,	0 },
  { "tag",	ecoff_directive_tag,	0 },
  { "val",	ecoff_directive_val,	0 },

  /* COFF debugging requires pseudo-ops .size and .type, but ELF
     already has meanings for those.  We use .esize and .etype
     instead.  These are only generated by gcc anyhow.  */
  { "esize",	ecoff_directive_size,	0 },
  { "etype",	ecoff_directive_type,	0 },

  /* ECOFF specific debugging information.  */
  { "aent",	ecoff_directive_ent,	1 },
  { "begin",	ecoff_directive_begin,	0 },
  { "bend",	ecoff_directive_bend,	0 },
  { "end",	ecoff_directive_end,	0 },
  { "ent",	ecoff_directive_ent,	0 },
  { "fmask",	ecoff_directive_fmask,	0 },
  { "frame",	ecoff_directive_frame,	0 },
  { "loc",	ecoff_directive_loc,	0 },
  { "mask",	ecoff_directive_mask,	0 },

  /* Other ECOFF directives.  */
  { "extern",	ecoff_directive_extern,	0 },

  /* These are used on Irix.  I don't know how to implement them.  */
  { "alias",	s_ignore,		0 },
  { "bgnb",	s_ignore,		0 },
  { "endb",	s_ignore,		0 },
  { "lab",	s_ignore,		0 },
  { "noalias",	s_ignore,		0 },
  { "verstamp",	s_ignore,		0 },
  { "vreg",	s_ignore,		0 },
#endif

  {NULL, NULL, 0}			/* end sentinel */
};

#undef NO_RELOC
#include "aout/aout64.h"

asection *elf_com_section_ptr;

void elf_pop_insert(void)
{
    pop_insert(elf_pseudo_table);
    if (ECOFF_DEBUGGING)
    {
        pop_insert(ecoff_debug_pseudo_table);
    }
}

void
elf_file_symbol (const char *s)
{
  if (!s)
    {
      return;
    }

  symbolS *sym = symbol_new (s, absolute_section, &zero_address_frag, 0);
  if (!sym)
    {
      return;
    }

  size_t name_length = strlen (s);
  const char *current_name = S_GET_NAME (sym);
  if (name_length > strlen (current_name))
    {
      obstack_grow (&notes, s, name_length + 1);
      S_SET_NAME (sym, obstack_finish (&notes));
    }
  else if (s != current_name)
    {
      memcpy ((char *) current_name, s, name_length + 1);
    }

  asymbol *bsym = symbol_get_bfdsym (sym);
  if (bsym)
    {
      bsym->flags |= BSF_FILE;
    }

  bool root_is_file_symbol = false;
  if (symbol_rootP)
    {
      asymbol *root_bsym = symbol_get_bfdsym (symbol_rootP);
      if (root_bsym && (root_bsym->flags & BSF_FILE))
        {
          root_is_file_symbol = true;
        }
    }

  if (symbol_rootP != sym && !root_is_file_symbol)
    {
      symbol_remove (sym, &symbol_rootP, &symbol_lastP);
      symbol_insert (sym, symbol_rootP, &symbol_rootP, &symbol_lastP);
    }

#ifdef DEBUG
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif

#ifdef NEED_ECOFF_DEBUG
  ecoff_new_file (s);
#endif
}

/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

symbolS *
elf_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size)
{
  addressT align = 0;
  int is_local = symbol_get_obj (symbolP)->local;

  if (*input_line_pointer == ',')
    {
      char *const save_at_comma = input_line_pointer;
      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '"')
        {
          input_line_pointer++;
          char *p = input_line_pointer;
          int parsed_segment = 0;

          if (*p == '.')
            {
              p++;
            }

          if (startswith (p, "bss\""))
            {
              input_line_pointer = p + 4;
              parsed_segment = 1;
            }
          else if (startswith (p, "data\""))
            {
              input_line_pointer = p + 5;
              parsed_segment = 1;
            }

          if (parsed_segment)
            {
              is_local = 0;
            }
          else
            {
              char *const segment_start_for_msg = input_line_pointer - 1;
              char *segment_end = input_line_pointer;

              while (!is_end_of_stmt (*segment_end) && *segment_end != '"')
                {
                  segment_end++;
                }

              char original_char = *segment_end;
              *segment_end = '\0';
              as_bad (_("bad .common segment %s"), segment_start_for_msg);
              *segment_end = original_char;

              input_line_pointer = segment_end;
              if (*input_line_pointer == '"')
                {
                  input_line_pointer++;
                }
              ignore_rest_of_line ();
              return NULL;
            }
        }
      else
        {
          input_line_pointer = save_at_comma;
          align = parse_align (is_local);
          if (align == (addressT) -1)
            {
              return NULL;
            }
        }
    }

  if (is_local)
    {
      bss_alloc (symbolP, size, align);
      S_CLEAR_EXTERNAL (symbolP);
    }
  else
    {
      S_SET_VALUE (symbolP, size);
      S_SET_ALIGN (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, elf_com_section_ptr);
    }

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  return symbolP;
}

void
obj_elf_common (int is_common)
{
  if (flag_mri && (is_common != 0))
    {
      s_mri_common (0);
    }
  else
    {
      s_comm_internal (0, elf_common_parse);
    }
}

static void
obj_elf_tls_common (int ATTRIBUTE_UNUSED)
{
  symbolS * const symbol = s_comm_internal (0, elf_common_parse);

  if (symbol)
    {
      symbol_get_bfdsym (symbol)->flags |= BSF_THREAD_LOCAL;
    }
}

static void
obj_elf_lcomm (void)
{
  symbolS *symbolP = s_comm_internal (0, s_lcomm_internal);

  if (symbolP != NULL)
    {
      bfd_symbol *bfdsym = symbol_get_bfdsym (symbolP);
      bfdsym->flags |= BSF_OBJECT;
    }
}

static symbolS *
get_sym_from_input_line_and_check (void)
{
  char *name;
  const char c = get_symbol_name (&name);

  if (name == input_line_pointer)
    {
      as_bad (_("Missing symbol name in directive"));
    }

  symbolS *sym = symbol_find_or_make (name);
  restore_line_pointer (c);
  SKIP_WHITESPACE ();

  return sym;
}

static void
obj_elf_local (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;

  for (;;)
    {
      symbolP = get_sym_from_input_line_and_check ();
      S_CLEAR_EXTERNAL (symbolP);
      symbol_get_obj (symbolP)->local = 1;

      if (*input_line_pointer != ',')
	{
	  break;
	}

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '\n' || *input_line_pointer == '\0')
	{
	  break;
	}
    }

  demand_empty_rest_of_line ();
}

static void
obj_elf_weak (int ignore ATTRIBUTE_UNUSED)
{
  for (;;)
    {
      symbolS *symbolP = get_sym_from_input_line_and_check ();
      S_SET_WEAK (symbolP);

      if (*input_line_pointer != ',')
	{
	  break;
	}

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '\n' || *input_line_pointer == '\0')
	{
	  break;
	}
    }

  demand_empty_rest_of_line ();
}

static void
obj_elf_visibility (int visibility)
{
  for (;;)
    {
      symbolS *symbolP = get_sym_from_input_line_and_check ();
      asymbol *bfdsym = symbol_get_bfdsym (symbolP);
      elf_symbol_type *elfsym = elf_symbol_from (bfdsym);

      gas_assert (elfsym);

      elfsym->internal_elf_sym.st_other =
        (elfsym->internal_elf_sym.st_other & ~3) | visibility;

      if (*input_line_pointer != ',')
        {
          break;
        }

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '\n')
        {
          break;
        }
    }

  demand_empty_rest_of_line ();
}

static segT previous_section;
static int previous_subsection;

struct section_stack
{
  struct section_stack *next;
  segT seg, prev_seg;
  int subseg, prev_subseg;
};

static struct section_stack *section_stack;

/* ELF section flags for unique sections.  */
#define SEC_ASSEMBLER_SHF_MASK SHF_GNU_RETAIN

struct group_list
{
  asection **head;		/* Section lists.  */
  unsigned int num_group;	/* Number of lists.  */
  htab_t indexes; /* Maps group name to index in head array.  */
};

static struct group_list groups;

static bool
match_section (const asection *sec, const struct elf_section_match *match)
{
  const struct elf_section_data *elf_sec_data = elf_section_data (sec);
  if (elf_sec_data == NULL)
    {
      return false;
    }

  const Elf_Internal_Shdr *hdr = &elf_sec_data->this_hdr;

  if (hdr->sh_info != match->sh_info)
    {
      return false;
    }

  bfd_vma sh_flags = hdr->sh_flags & SEC_ASSEMBLER_SHF_MASK;
  if (sh_flags != match->sh_flags)
    {
      return false;
    }

  bfd_vma sec_id_flags = bfd_section_flags (sec) & SEC_ASSEMBLER_SECTION_ID;
  bfd_vma match_id_flags = match->flags & SEC_ASSEMBLER_SECTION_ID;
  if (sec_id_flags != match_id_flags)
    {
      return false;
    }

  if (sec->section_id != match->section_id)
    {
      return false;
    }

  const char *sec_symbol_name = sec->map_head.linked_to_symbol_name;
  const char *match_symbol_name = match->linked_to_symbol_name;

  if (sec_symbol_name == match_symbol_name)
    {
      return true;
    }

  if (sec_symbol_name != NULL && match_symbol_name != NULL)
    {
      return strcmp (sec_symbol_name, match_symbol_name) == 0;
    }

  return false;
}

/* Return TRUE iff SEC matches the section info INF.  */

static bool
are_strings_equal (const char *s1, const char *s2)
{
  if (s1 == s2)
    {
      return true;
    }

  if (s1 == NULL || s2 == NULL)
    {
      return false;
    }

  return strcmp (s1, s2) == 0;
}

static bool
get_section_by_match (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  struct elf_section_match *match = inf;
  const char *gname = match->group_name;
  const char *group_name = elf_group_name (sec);

  return are_strings_equal (group_name, gname) && match_section (sec, match);
}

/* Go look in section lists kept per group for SEC_NAME with
   properties given by MATCH.  If info for the group named by
   MATCH->GROUP_NAME has been initialised, set GROUP_IDX.  */

static asection *
group_section_find (const struct elf_section_match *match,
		    const char *sec_name,
		    unsigned int *group_idx)
{
  if (!match || !match->group_name || !sec_name || !group_idx)
    {
      if (group_idx)
	*group_idx = ~0u;
      return NULL;
    }

  if (!groups.indexes)
    {
      groups.num_group = 0;
      groups.head = NULL;
      groups.indexes = htab_create_alloc (16, hash_string_tuple, eq_string_tuple,
					  NULL, notes_calloc, NULL);
    }

  *group_idx = str_hash_find_int (groups.indexes, match->group_name);
  if (*group_idx == ~0u)
    return NULL;

  for (asection *s = groups.head[*group_idx]; s != NULL; s = elf_next_in_group (s))
    {
      int name_matches = (s->name == sec_name) || (strcmp (s->name, sec_name) == 0);
      if (name_matches && match_section (s, match))
	return s;
    }

  return NULL;
}

/* Insert SEC into section lists kept per group.  MATCH and GROUP_IDX
   must be from a prior call to group_section_find.  */

static void
group_section_insert (const struct elf_section_match *match,
		      asection *sec,
		      unsigned int *group_idx)
{
  const unsigned int invalid_group_index = ~0u;

  if (*group_idx != invalid_group_index)
    {
      elf_next_in_group (sec) = groups.head[*group_idx];
      groups.head[*group_idx] = sec;
      return;
    }

  const unsigned int new_group_idx = groups.num_group;
  const unsigned int group_alloc_chunk_size = 128;

  if (new_group_idx % group_alloc_chunk_size == 0)
    {
      groups.head = XRESIZEVEC (asection *, groups.head,
				new_group_idx + group_alloc_chunk_size);
    }

  groups.head[new_group_idx] = sec;
  groups.num_group += 1;

  str_hash_insert_int (groups.indexes, match->group_name, new_group_idx, 0);
}

/* Handle the .section pseudo-op.  This code supports two different
   syntaxes.

   The first is found on Solaris, and looks like
       .section ".sec1",#alloc,#execinstr,#write
   Here the names after '#' are the SHF_* flags to turn on for the
   section.  I'm not sure how it determines the SHT_* type (BFD
   doesn't really give us control over the type, anyhow).

   The second format is found on UnixWare, and probably most SVR4
   machines, and looks like
       .section .sec1,"a",@progbits
   The quoted string may contain any combination of a, w, x, and
   represents the SHF_* flags to turn on for the section.  The string
   beginning with '@' can be progbits or nobits.  There should be
   other possibilities, but I don't know what they are.  In any case,
   BFD doesn't really let us set the section type.  */

static void
handle_section_stack (bool push)
{
  if (!push)
    return;

  struct section_stack *elt = XNEW (struct section_stack);
  elt->next = section_stack;
  elt->seg = now_seg;
  elt->prev_seg = previous_section;
  elt->subseg = now_subseg;
  elt->prev_subseg = previous_subsection;
  section_stack = elt;
}

static asection *
find_or_create_section (const char *name,
			struct elf_section_match *match_p,
			subsegT new_subsection,
			unsigned int *group_idx_p,
			bool *is_new_p)
{
  asection *sec;
  if (match_p->group_name)
    sec = group_section_find (match_p, name, group_idx_p);
  else
    sec = bfd_get_section_by_name_if (stdoutput, name, get_section_by_match,
				      match_p);

  *is_new_p = (sec == NULL);
  if (*is_new_p)
    {
      sec = subseg_force_new (name, new_subsection);
      if (match_p->group_name)
	group_section_insert (match_p, sec, group_idx_p);
    }
  else
    {
      subseg_set (sec, new_subsection);
    }
  return sec;
}

static unsigned int
resolve_section_type (const char *name, unsigned int type,
		      const struct bfd_elf_special_section *ssect,
		      bool is_new_section)
{
  if (ssect == NULL || type == ssect->type)
    return type;
  if (type == SHT_NULL)
    return ssect->type;

  bool use_special_type = !is_new_section;
  if (is_new_section)
    {
      if (ssect->type == SHT_INIT_ARRAY
	  || ssect->type == SHT_FINI_ARRAY
	  || ssect->type == SHT_PREINIT_ARRAY)
	use_special_type = true;
#ifdef TC_I386
      const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
      if (bed->s->arch_size == 64 && (ssect->attr & SHF_X86_64_LARGE))
	use_special_type = true;
#endif
      if (!use_special_type
	  && ssect->type != SHT_NOTE
	  && type < SHT_LOPROC)
	as_warn (_("setting incorrect section type for %s"), name);
    }

  if (use_special_type)
    {
      as_warn (_("ignoring incorrect section type for %s"), name);
      return ssect->type;
    }

  return type;
}

static bool
should_use_user_attributes_only (const char *name, bfd_vma generic_attr,
				 const struct bfd_elf_special_section *ssect,
				 const struct elf_section_match *match_p)
{
  if (ssect->type == SHT_NOTE
      && (generic_attr == SHF_ALLOC || generic_attr == SHF_EXECINSTR))
    return false;

  if (ssect->suffix_length == -2 && name[ssect->prefix_length] == '.'
      && (generic_attr & ~ssect->attr & ~SHF_MERGE & ~SHF_STRINGS) == 0)
    return false;

#ifdef TC_RX
  if (generic_attr == (SHF_EXECINSTR | SHF_WRITE | SHF_ALLOC)
      && (ssect->type == SHT_INIT_ARRAY
	  || ssect->type == SHT_FINI_ARRAY
	  || ssect->type == SHT_PREINIT_ARRAY))
    return false;
#endif

  if ((generic_attr == SHF_ALLOC
       && (strcmp (name, ".interp") == 0
	   || strcmp (name, ".strtab") == 0
	   || strcmp (name, ".symtab") == 0))
      || (generic_attr == SHF_EXECINSTR
	  && strcmp (name, ".note.GNU-stack") == 0))
    return true;

#ifdef TC_ALPHA
  if ((generic_attr & ~ssect->attr) == SHF_ALPHA_GPREL)
    return true;
#endif

  if (match_p->group_name == NULL)
    as_warn (_("setting incorrect section attributes for %s"), name);
  return true;
}

static bfd_vma
resolve_new_section_attributes (const char *name, bfd_vma attr,
				const struct bfd_elf_special_section *ssect,
				const struct elf_section_match *match_p)
{
  if (ssect == NULL)
    return attr;

  bfd_vma allowed_mask = SHF_LINK_ORDER | SHF_MASKOS | SHF_MASKPROC;
  if (((attr & ~allowed_mask) & ~ssect->attr) == 0)
    return attr | ssect->attr;

  bfd_vma generic_attr = attr;
  if (elf_tdata (stdoutput)->has_gnu_osabi)
    generic_attr &= ~SHF_GNU_RETAIN;

  if (should_use_user_attributes_only (name, generic_attr, ssect, match_p))
    return attr;

  return attr | ssect->attr;
}

static flagword
convert_elf_to_bfd_flags (bfd_vma attr, unsigned int type, bool linkonce)
{
  flagword flags = SEC_RELOC;
  if (!(attr & SHF_WRITE))
    flags |= SEC_READONLY;
  if (attr & SHF_ALLOC)
    flags |= SEC_ALLOC;
  if ((attr & SHF_ALLOC) && type != SHT_NOBITS)
    flags |= SEC_LOAD;
  if (attr & SHF_EXECINSTR)
    flags |= SEC_CODE;
  if (attr & SHF_MERGE)
    flags |= SEC_MERGE;
  if (attr & SHF_STRINGS)
    flags |= SEC_STRINGS;
  if (attr & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;
  if (attr & SHF_TLS)
    flags |= SEC_THREAD_LOCAL;

  if (linkonce)
    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

#ifdef md_elf_section_flags
  flags = md_elf_section_flags (flags, attr, type);
#endif

  return flags;
}

static flagword
add_debugging_flags (flagword flags, const char *name)
{
  if ((flags & SEC_ALLOC) == 0 && name[0] == '.')
    {
      if (startswith (name, ".debug")
	  || startswith (name, ".zdebug")
	  || startswith (name, ".gnu.debuglto_.debug_")
	  || startswith (name, ".gnu.linkonce.wi.")
	  || startswith (name, GNU_BUILD_ATTRS_SECTION_NAME)
	  || startswith (name, ".note.gnu"))
	flags |= SEC_ELF_OCTETS;
    }
  return flags;
}

static void
initialize_new_section (asection *sec, const char *name,
			unsigned int type, bfd_vma attr, int entsize,
			flagword flags, struct elf_section_match *match_p)
{
  symbolS *secsym;
  unsigned int final_type = type;

  if (final_type == SHT_NULL)
    final_type = bfd_elf_get_default_section_type (flags);
  elf_section_type (sec) = final_type;
  elf_section_flags (sec) = attr;
  elf_section_data (sec)->this_hdr.sh_info = match_p->sh_info;

  if (final_type == SHT_NOBITS)
    seg_info (sec)->bss = 1;

  sec->section_id = match_p->section_id;
  flags |= match_p->flags;

  sec->map_head.linked_to_symbol_name = match_p->linked_to_symbol_name;

  bfd_set_section_flags (sec, flags);
  if (entsize != 0)
    sec->entsize = entsize;
  elf_group_name (sec) = match_p->group_name;

  secsym = symbol_find (name);
  if (secsym != NULL)
    {
      static const expressionS exp = { .X_op = O_constant };
      symbol_set_value_expression (secsym, &exp);
      symbol_set_bfdsym (secsym, sec->symbol);
    }
  else
    {
      symbol_table_insert (section_symbol (sec));
    }
}

static void
update_existing_section (asection *sec, const char *name, unsigned int type,
			 bfd_vma attr, int entsize, flagword flags,
			 const struct bfd_elf_special_section *ssect)
{
  if (type != SHT_NULL && type != elf_section_type (sec))
    {
      if (ssect != NULL)
	as_warn (_("ignoring changed section type for %s"), name);
      else
	as_bad (_("changed section type for %s"), name);
    }

  if (attr != 0)
    {
      const flagword check_flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
				    | SEC_CODE | SEC_EXCLUDE
				    | SEC_SORT_ENTRIES | SEC_MERGE
				    | SEC_STRINGS | SEC_LINK_ONCE
				    | SEC_LINK_DUPLICATES_DISCARD
				    | SEC_THREAD_LOCAL);

      if ((sec->flags ^ flags) & check_flags)
	{
	  if (ssect != NULL)
	    as_warn (_("ignoring changed section attributes for %s"), name);
	  else
	    as_bad (_("changed section attributes for %s"), name);
	}
      else
	{
	  elf_section_flags (sec) = attr;
	}
    }

  if (entsize != 0 && sec->entsize != (unsigned) entsize)
    as_bad (_("changed section entity size for %s"), name);
}

static void
change_section (const char *name,
		unsigned int type,
		bfd_vma attr,
		int entsize,
		struct elf_section_match *match_p,
		bool linkonce,
		bool push,
		subsegT new_subsection)
{
  asection *sec;
  flagword flags;
  const struct bfd_elf_special_section *ssect;
  bool is_new_section;
  unsigned int group_idx = ~0u;
  unsigned int final_type;
  bfd_vma final_attr = attr;

  if (match_p == NULL)
    {
      static struct elf_section_match unused_match;
      match_p = &unused_match;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  handle_section_stack (push);
  obj_elf_section_change_hook ();

  sec = find_or_create_section (name, match_p, new_subsection,
				&group_idx, &is_new_section);

  ssect = (*get_elf_backend_data (stdoutput)->get_sec_type_attr) (stdoutput,
								  sec);

  final_type = resolve_section_type (name, type, ssect, is_new_section);
  if (is_new_section)
    final_attr = resolve_new_section_attributes (name, attr, ssect, match_p);

  flags = convert_elf_to_bfd_flags (final_attr, final_type, linkonce);
  flags = add_debugging_flags (flags, name);

  if (is_new_section)
    initialize_new_section (sec, name, final_type, final_attr, entsize, flags,
			    match_p);
  else
    update_existing_section (sec, name, type, attr, entsize, flags, ssect);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

void
obj_elf_change_section (const char *name,
                        unsigned int type,
                        bfd_vma attr,
                        int entsize,
                        struct elf_section_match *match_p,
                        bool linkonce)
{
  const bool is_comdat = false;
  const bfd_vma comdat_alignment = 0;

  change_section (name, type, attr, entsize, match_p, linkonce, is_comdat,
                  comdat_alignment);
}

static void
report_unrecognized_attribute_error (bool push, bool has_gnu_attr,
				     const char *md_extra)
{
  as_bad (_("unrecognized .%ssection attribute: want %s%s%s,? or number"),
	  push ? "push" : "",
	  has_gnu_attr ? "a,d,e,o,w,x,E,G,M,R,S,T" : "a,e,o,w,x,E,G,M,S,T",
	  md_extra && *md_extra ? "," : "", md_extra);
}

static bfd_vma
obj_elf_parse_section_letters (char *str, size_t len, bool push,
			       bool *is_clone, int *inherit, bfd_vma *gnu_attr,
			       bool *has_entsize)
{
  bfd_vma attr = 0;

  *is_clone = false;
  *inherit = 0;
  *has_entsize = false;

  while (len > 0)
    {
      size_t consumed = 1;
      bool is_recognized = true;

      switch (*str)
	{
	case 'a':
	  attr |= SHF_ALLOC;
	  if (len > 1 && str[1] == 'm')
	    {
	      attr |= SHF_MERGE;
	      consumed++;
	      if (len > 2 && str[2] == 's')
		{
		  attr |= SHF_STRINGS;
		  consumed++;
		}
	    }
	  break;
	case 'd':
	  if (gnu_attr)
	    *gnu_attr |= SHF_GNU_MBIND;
	  else
	    is_recognized = false;
	  break;
	case 'e': attr |= SHF_EXCLUDE; break;
	case 'o': attr |= SHF_LINK_ORDER; break;
	case 'w': attr |= SHF_WRITE; break;
	case 'x': attr |= SHF_EXECINSTR; break;
	case 'E': *has_entsize = true; break;
	case 'G': attr |= SHF_GROUP; break;
	case 'M': attr |= SHF_MERGE; break;
	case 'R':
	  if (gnu_attr)
	    *gnu_attr |= SHF_GNU_RETAIN;
	  else
	    is_recognized = false;
	  break;
	case 'S': attr |= SHF_STRINGS; break;
	case 'T': attr |= SHF_TLS; break;
	case '?': *is_clone = true; break;
	default:
	  is_recognized = false;
	  break;
	}

      if (!is_recognized)
	{
	  const char *md_extra = "";
#ifdef md_elf_section_letter
	  bfd_vma md_attr = md_elf_section_letter (*str, &md_extra);
	  if (md_attr != (bfd_vma) -1)
	    {
	      attr |= md_attr;
	    }
	  else
#endif
	  if (ISDIGIT (*str))
	    {
	      char *end = NULL;
	      bfd_vma numeric_flags = strtoul (str, &end, 0);

	      if (end > str)
		{
		  attr |= numeric_flags;
		  if (gnu_attr)
		    *gnu_attr |= (numeric_flags & SHF_MASKOS);
		  consumed = (size_t) (end - str);
		}
	      else
		{
		  report_unrecognized_attribute_error (push, gnu_attr != NULL,
						       md_extra);
		  return attr;
		}
	    }
	  else if (!*inherit && !attr
		   && (gnu_attr == NULL || !*gnu_attr)
		   && (*str == '+' || *str == '-'))
	    {
	      *inherit = (*str == '+') ? 1 : -1;
	    }
	  else
	    {
	      report_unrecognized_attribute_error (push, gnu_attr != NULL,
						   md_extra);
	      return attr;
	    }
	}

      str += consumed;
      len -= consumed;
    }

  return attr;
}

#include <string.h>
#include <stdlib.h>
#include <ctype.h>

struct section_type_map {
    const char *name;
    size_t len;
    int type;
};

static const struct section_type_map section_types[] = {
    {"progbits",      8,  SHT_PROGBITS},
    {"nobits",        6,  SHT_NOBITS},
    {"note",          4,  SHT_NOTE},
    {"init_array",    10, SHT_INIT_ARRAY},
    {"fini_array",    10, SHT_FINI_ARRAY},
    {"preinit_array", 13, SHT_PREINIT_ARRAY}
};

static int
obj_elf_section_type (char *str, size_t len, bool warn)
{
    for (size_t i = 0; i < sizeof(section_types) / sizeof(section_types[0]); ++i) {
        if (len == section_types[i].len && memcmp(str, section_types[i].name, len) == 0) {
            return section_types[i].type;
        }
    }

#ifdef md_elf_section_type
    int md_type = md_elf_section_type (str, len);
    if (md_type >= 0) {
        return md_type;
    }
#endif

    if (len > 0 && ISDIGIT ((unsigned char)*str)) {
        char temp_str[len + 1];
        memcpy (temp_str, str, len);
        temp_str[len] = '\0';

        char *end;
        unsigned long type = strtoul (temp_str, &end, 0);

        if (warn && *end != '\0') {
            as_warn (_("extraneous characters at end of numeric section type"));
        }
        return (int)type;
    }

    if (warn) {
        as_warn (_("unrecognized section type"));
    }
    return 0;
}

#ifdef TC_SPARC
static bfd_vma
obj_elf_section_word (char *str, size_t len, int *type)
{
  int ret;

  if (len == 5 && startswith (str, "write"))
    return SHF_WRITE;
  if (len == 5 && startswith (str, "alloc"))
    return SHF_ALLOC;
  if (len == 9 && startswith (str, "execinstr"))
    return SHF_EXECINSTR;
  if (len == 7 && startswith (str, "exclude"))
    return SHF_EXCLUDE;
  if (len == 3 && startswith (str, "tls"))
    return SHF_TLS;

  ret = obj_elf_section_type (str, len, false);
  if (ret != 0)
    *type = ret;
  else
    as_warn (_("unrecognized section attribute"));

  return 0;
}
#endif

/* Get name of section.  */
const char *
obj_elf_section_name (void)
{
  char *name;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      int dummy;
      name = demand_copy_C_string (&dummy);
      if (name == NULL)
	{
	  ignore_rest_of_line ();
	  return NULL;
	}
    }
  else
    {
      const char *start = input_line_pointer;
      char *end = (char *) start;

      while (*end && !is_whitespace (*end) && !is_end_of_stmt (*end) && *end != ',')
	{
	  end++;
	}

      if (end == start)
	{
	  as_bad (_("missing name"));
	  ignore_rest_of_line ();
	  return NULL;
	}

      obstack_grow0 (&notes, start, end - start);
      name = obstack_base (&notes);

      if (flag_sectname_subst)
	{
	  while (1)
	    {
	      char *subst = strchr (name, '%');
	      if (!subst || subst[1] != 'S')
		{
		  break;
		}

	      const size_t placeholder_len = 2;	/* %S */
	      const size_t segment_name_len = strlen (now_seg->name);
	      const size_t head_len = subst - name;
	      const size_t tail_len = strlen (subst + placeholder_len) + 1;

	      if (segment_name_len > placeholder_len)
		{
		  obstack_blank (&notes, segment_name_len - placeholder_len);
		  name = obstack_base (&notes);
		}

	      char *insert_point = name + head_len;
	      memmove (insert_point + segment_name_len,
		       insert_point + placeholder_len, tail_len);
	      memcpy (insert_point, now_seg->name, segment_name_len);
	    }
	}

      obstack_finish (&notes);

#ifdef tc_canonicalize_section_name
      name = tc_canonicalize_section_name (name);
#endif
      input_line_pointer = end;
    }

  SKIP_WHITESPACE ();
  return name;
}

/* Arrange to put SEC, known to be in group GNAME into the per-group
   section lists kept by gas.  */

void
elf_set_group_name (asection *sec, const char *gname)
{
  if (sec == NULL || gname == NULL)
    {
      return;
    }

  const struct elf_section_data *elf_data = elf_section_data (sec);
  if (elf_data == NULL)
    {
      return;
    }

  elf_group_name (sec) = gname;
  elf_section_flags (sec) |= SHF_GROUP;

  struct elf_section_match match;
  match.group_name = gname;
  match.linked_to_symbol_name = sec->map_head.linked_to_symbol_name;
  match.section_id = sec->section_id;
  match.sh_info = elf_data->this_hdr.sh_info;
  match.sh_flags = (elf_data->this_hdr.sh_flags
		    & SEC_ASSEMBLER_SHF_MASK);
  match.flags = bfd_section_flags (sec) & SEC_ASSEMBLER_SECTION_ID;

  unsigned int group_idx;
  if (!group_section_find (&match, sec->name, &group_idx))
    {
      group_section_insert (&match, sec, &group_idx);
    }
}

static void
obj_elf_attach_to_group (void)
{
  const char *gname = obj_elf_section_name ();

  if (gname == NULL)
    {
      as_warn (_("group name not parseable"));
      return;
    }

  const char *existing_gname = elf_group_name (now_seg);
  if (existing_gname)
    {
      if (strcmp (existing_gname, gname) != 0)
	{
	  as_warn (_("section %s already has a group (%s)"),
		   bfd_section_name (now_seg), existing_gname);
	}
    }
  else
    {
      elf_set_group_name (now_seg, gname);
    }
}

/* Handle section related directives.

   Note on support for SFrame sections: These are generally expected to be
   generated by the assembler.  However, this function permits their direct
   creation by the user.  At the moment though, we go no extra mile by adding
   an explicit @sframe for SHT_GNU_SFRAME (using the numeric value of section
   type should suffice); Nor do we implement any outright refusal for
   non-supported targets via ELFOSABI-specific checks.  */

#include <errno.h>

#define INVALID_SECTION_INDEX ((unsigned long)-1UL)

struct section_params
{
  const char *name;
  int type;
  bfd_vma attr;
  bfd_vma gnu_attr;
  int entsize;
  bool has_entsize;
  bool linkonce;
  bool is_clone;
  int inherit;
  subsegT new_subsection;
  struct elf_section_match match;
  unsigned long linked_to_section_index;
};

static void
init_section_params (struct section_params *p, const char *name)
{
  memset (p, 0, sizeof (*p));
  p->name = name;
  p->type = SHT_NULL;
  p->linked_to_section_index = INVALID_SECTION_INDEX;
}

static bool
advance_past_comma (void)
{
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    return false;
  ++input_line_pointer;
  SKIP_WHITESPACE ();
  return true;
}

static int
parse_section_type_value (void)
{
  char *beg;
  char c = *input_line_pointer;
  if (c == '"')
    {
      int dummy;
      beg = demand_copy_C_string (&dummy);
      if (beg == NULL)
	return SHT_NULL;
      return obj_elf_section_type (beg, strlen (beg), true);
    }
  else if (c == '@' || c == '%')
    {
      ++input_line_pointer;
      if (ISDIGIT (*input_line_pointer))
	return strtoul (input_line_pointer, &input_line_pointer, 0);

      c = get_symbol_name (&beg);
      (void) restore_line_pointer (c);
      return obj_elf_section_type (beg, input_line_pointer - beg, true);
    }
  return SHT_NULL;
}

static void
parse_entity_size (struct section_params *p)
{
  bool should_inherit = p->inherit
			&& ((bfd_section_flags (now_seg)
			     & (SEC_MERGE | SEC_STRINGS)) != 0
			    || now_seg->entsize);

  if (!p->has_entsize)
    return;

  if (advance_past_comma ())
    {
      if (p->inherit && *input_line_pointer == ',' && should_inherit)
	{
	  p->entsize = now_seg->entsize;
	  return;
	}

      if (is_end_of_stmt (*input_line_pointer)
	  && (bfd_section_flags (now_seg)
	      & (SEC_MERGE | SEC_STRINGS)) != 0)
	{
	  as_tsktsk (_("missing section entity size, 1 assumed"));
	  p->entsize = 1;
	}
      else
	{
	  p->entsize = get_absolute_expression ();
	  SKIP_WHITESPACE ();
	  if (p->entsize <= 0)
	    {
	      as_warn (_("invalid section entity size"));
	      p->attr &= ~(SHF_MERGE | SHF_STRINGS);
	      p->has_entsize = false;
	      p->entsize = 0;
	    }
	}
    }
  else if (should_inherit)
    {
      p->entsize = now_seg->entsize;
    }
  else if ((p->attr & SHF_MERGE) != 0)
    {
      as_warn (_("entity size for SHF_MERGE not specified"));
      p->attr &= ~(SHF_MERGE | SHF_STRINGS);
      p->has_entsize = false;
    }
  else if ((p->attr & SHF_STRINGS) != 0)
    {
      p->entsize = 1;
    }
  else
    {
      as_warn (_("entity size not specified"));
      p->has_entsize = false;
    }
}

static void
parse_link_order (struct section_params *p)
{
  bool should_inherit = p->inherit
			&& (elf_section_flags (now_seg) & SHF_LINK_ORDER) != 0;

  if ((p->attr & SHF_LINK_ORDER) == 0)
    return;

  if (advance_past_comma ())
    {
      if (ISDIGIT (*input_line_pointer))
	{
	  p->linked_to_section_index
	    = strtoul (input_line_pointer, &input_line_pointer, 0);
	}
      else if (p->inherit && *input_line_pointer == ',' && should_inherit)
	{
	  if (now_seg->map_head.linked_to_symbol_name)
	    p->match.linked_to_symbol_name
	      = now_seg->map_head.linked_to_symbol_name;
	  else
	    p->linked_to_section_index
	      = elf_section_data (now_seg)->this_hdr.sh_link;
	}
      else
	{
	  char c;
	  char *beg;
	  unsigned int length;
	  c = get_symbol_name (&beg);
	  (void) restore_line_pointer (c);
	  length = input_line_pointer - beg;
	  if (length)
	    p->match.linked_to_symbol_name
	      = notes_memdup (beg, length, length + 1);
	}
    }
  else if (should_inherit)
    {
      if (now_seg->map_head.linked_to_symbol_name)
	p->match.linked_to_symbol_name
	  = now_seg->map_head.linked_to_symbol_name;
      else
	p->linked_to_section_index
	  = elf_section_data (now_seg)->this_hdr.sh_link;
    }
}

static void
parse_group (struct section_params *p)
{
  bool should_inherit = p->inherit
			&& (elf_section_flags (now_seg) & SHF_GROUP) != 0;

  if ((p->attr & SHF_GROUP) == 0)
    {
      if (p->is_clone)
	{
	  const char *now_group = elf_group_name (now_seg);
	  if (now_group != NULL)
	    {
	      p->match.group_name = now_group;
	      p->linkonce = (now_seg->flags & SEC_LINK_ONCE) != 0;
	    }
	}
      return;
    }

  if (p->is_clone)
    as_warn (_("? section flag ignored with G present"));

  if (advance_past_comma ())
    {
      if (p->inherit && *input_line_pointer == ',' && should_inherit)
	{
	  p->match.group_name = elf_group_name (now_seg);
	  p->linkonce = (bfd_section_flags (now_seg) & SEC_LINK_ONCE) != 0;
	  return;
	}

      p->match.group_name = obj_elf_section_name ();
      if (p->match.group_name == NULL)
	p->attr &= ~SHF_GROUP;
      else if (*input_line_pointer == ',')
	{
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  if (startswith (input_line_pointer, "comdat"))
	    {
	      input_line_pointer += 6;
	      p->linkonce = 1;
	    }
	}
      else if (startswith (p->name, ".gnu.linkonce"))
	p->linkonce = 1;
    }
  else if (should_inherit)
    {
      p->match.group_name = elf_group_name (now_seg);
      p->linkonce = (bfd_section_flags (now_seg) & SEC_LINK_ONCE) != 0;
    }
  else
    {
      as_warn (_("group name for SHF_GROUP not specified"));
      p->attr &= ~SHF_GROUP;
    }
}

static void
parse_gnu_attributes (struct section_params *p)
{
  if ((p->gnu_attr & SHF_GNU_MBIND) != 0 && *input_line_pointer == ',')
    {
      char *save = input_line_pointer;
      ++input_line_pointer;
      SKIP_WHITESPACE ();
      if (ISDIGIT (*input_line_pointer))
	{
	  char *t = input_line_pointer;
	  p->match.sh_info = strtoul (input_line_pointer, &input_line_pointer, 0);
	  if (p->match.sh_info == -1u)
	    {
	      as_warn (_("unsupported mbind section info: %s"), t);
	      p->match.sh_info = 0;
	    }
	}
      else
	input_line_pointer = save;
    }

  if ((p->gnu_attr & SHF_GNU_RETAIN) != 0)
    p->match.sh_flags |= SHF_GNU_RETAIN;
}

static void
parse_unique_id_value (struct section_params *p)
{
  bfd_vma id;
  bool overflow;
  char *t = input_line_pointer;
  if (sizeof (bfd_vma) <= sizeof (unsigned long))
    {
      errno = 0;
      id = strtoul (input_line_pointer, &input_line_pointer, 0);
      overflow = id == -1ul && errno == ERANGE;
    }
  else
    {
      id = bfd_scan_vma (input_line_pointer,
			 (const char **) &input_line_pointer, 0);
      overflow = id == ~(bfd_vma) 0;
    }

  if (overflow || id > -1u)
    {
      char *linefeed, saved_char = 0;
      if ((linefeed = strchr (t, '\n')) != NULL)
	{
	  saved_char = *linefeed;
	  *linefeed = '\0';
	}
      as_bad (_("unsupported section id: %s"), t);
      if (saved_char)
	*linefeed = saved_char;
    }
  else
    {
      p->match.section_id = id;
      p->match.flags |= SEC_ASSEMBLER_SECTION_ID;
    }
}

static void
parse_unique_id (struct section_params *p)
{
  if (*input_line_pointer != ',')
    return;

  char *save = input_line_pointer;
  ++input_line_pointer;
  SKIP_WHITESPACE ();
  if (startswith (input_line_pointer, "unique"))
    {
      input_line_pointer += 6;
      SKIP_WHITESPACE ();
      if (*input_line_pointer == ',')
	{
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  if (ISDIGIT (*input_line_pointer))
	    parse_unique_id_value (p);
	}
    }
  else
    input_line_pointer = save;
}

static bool
parse_quoted_attributes (struct section_params *p, bool push)
{
  char *beg;
  int dummy;

  beg = demand_copy_C_string (&dummy);
  if (beg == NULL)
    return false;

  const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
  bool use_gnu_attr = bed->elf_osabi == ELFOSABI_NONE
		      || bed->elf_osabi == ELFOSABI_GNU
		      || bed->elf_osabi == ELFOSABI_FREEBSD;

  p->attr = obj_elf_parse_section_letters (beg, strlen (beg), push,
					   &p->is_clone, &p->inherit,
					   use_gnu_attr ? &p->gnu_attr : NULL,
					   &p->has_entsize);

  if (p->inherit > 0)
    p->attr |= elf_section_flags (now_seg);
  else if (p->inherit < 0)
    p->attr = elf_section_flags (now_seg) & ~p->attr;

  if (p->inherit)
    p->type = elf_section_type (now_seg);

  if ((p->attr & (SHF_MERGE | SHF_STRINGS)) != 0)
    p->has_entsize = true;

  char *save = input_line_pointer;
  if (advance_past_comma ())
    {
      int new_type = parse_section_type_value ();
      if (new_type != SHT_NULL)
	p->type = new_type;
      else
	input_line_pointer = save;
    }

  parse_entity_size (p);
  if ((p->attr & (SHF_MERGE | SHF_STRINGS)) != 0 && p->type == SHT_NOBITS)
    as_warn (_("bogus SHF_MERGE / SHF_STRINGS for SHT_NOBITS section"));

  parse_link_order (p);
  parse_group (p);
  parse_gnu_attributes (p);
  parse_unique_id (p);

  return true;
}

static bool
parse_sparc_attributes (struct section_params *p)
{
#ifdef TC_SPARC
  do
    {
      char c;
      char *beg;

      SKIP_WHITESPACE ();
      if (*input_line_pointer != '#')
	{
	  as_bad (_("character following name is not '#'"));
	  return false;
	}
      ++input_line_pointer;
      c = get_symbol_name (&beg);
      (void) restore_line_pointer (c);

      p->attr |= obj_elf_section_word (beg, input_line_pointer - beg, &p->type);

      SKIP_WHITESPACE ();
    }
  while (*input_line_pointer++ == ',');
  --input_line_pointer;
  return true;
#else
  (void) p;
  return true;
#endif
}

static void
handle_mri_section (void)
{
  char mri_type;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();
  s_mri_sect (&mri_type);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static bool
check_section_name_conflict (const char *name)
{
  symbolS *sym = symbol_find (name);
  if (sym != NULL
      && !symbol_section_p (sym)
      && S_IS_DEFINED (sym)
      && !S_IS_VOLATILE (sym)
      && !S_CAN_BE_REDEFINED (sym))
    {
      as_bad (_("section name '%s' already defined as another symbol"), name);
      ignore_rest_of_line ();
      return true;
    }
  return false;
}

static bool
parse_section_args (struct section_params *p, bool push)
{
  if (*input_line_pointer != ',')
    return true;

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  if (push && ISDIGIT (*input_line_pointer))
    {
      p->new_subsection = get_absolute_expression ();
      if (!advance_past_comma ())
	return true;
    }

  if (*input_line_pointer == '"')
    {
      if (!parse_quoted_attributes (p, push))
	{
	  ignore_rest_of_line ();
	  return false;
	}
    }
  else
    {
      if (!parse_sparc_attributes (p))
	{
	  ignore_rest_of_line ();
	  return false;
	}
    }
  return true;
}

void
obj_elf_section (int push)
{
  if (flag_mri)
    {
      handle_mri_section ();
      return;
    }

  const char *name = obj_elf_section_name ();
  if (name == NULL)
    return;

  if (check_section_name_conflict (name))
    return;

  struct section_params p;
  init_section_params (&p, name);

  if (!parse_section_args (&p, push))
    return;

  demand_empty_rest_of_line ();

  if ((p.gnu_attr & (SHF_GNU_MBIND | SHF_GNU_RETAIN)) != 0)
    {
      bool mbind_p = (p.gnu_attr & SHF_GNU_MBIND) != 0;
      if (mbind_p)
	{
	  if ((p.attr & SHF_ALLOC) == 0)
	    as_bad (_("SHF_ALLOC isn't set for GNU_MBIND section: %s"), name);
	  elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_mbind;
	}
      if ((p.gnu_attr & SHF_GNU_RETAIN) != 0)
	elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_retain;
      p.attr |= p.gnu_attr;
    }

  change_section (p.name, p.type, p.attr, p.entsize, &p.match, p.linkonce,
		  push, p.new_subsection);

  if (p.linked_to_section_index != INVALID_SECTION_INDEX)
    {
      elf_section_flags (now_seg) |= SHF_LINK_ORDER;
      elf_section_data (now_seg)->this_hdr.sh_link = p.linked_to_section_index;
    }
}

/* Change to the .bss section.  */

void
obj_elf_bss (int i ATTRIBUTE_UNUSED)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();

  subseg_set (bss_section, get_absolute_expression ());
  demand_empty_rest_of_line ();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* Change to the .data section.  */

static inline void obj_elf_pre_data_hook(void)
{
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif
    obj_elf_section_change_hook();
}

static inline void obj_elf_post_data_hook(void)
{
#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

void obj_elf_data(int value)
{
    obj_elf_pre_data_hook();
    s_data(value);
    obj_elf_post_data_hook();
}

/* Change to the .text section.  */

void obj_elf_text(const int i)
{
    md_flush_pending_output();
    obj_elf_section_change_hook();
    s_text(i);
    md_elf_section_change_hook();
}

/* Change to the *ABS* section.  */

void obj_elf_select_section(int section_index)
{
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();

    s_struct(section_index);

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

static void
obj_elf_subsection (int ignore ATTRIBUTE_UNUSED)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();

  subseg_set (now_seg, get_absolute_expression ());
  demand_empty_rest_of_line ();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* This can be called from the processor backends if they change
   sections.  */

void obj_elf_section_change_hook(void)
{
    previous_section = now_seg;
    previous_subsection = now_subseg;
}

void
obj_elf_previous (int ignore ATTRIBUTE_UNUSED)
{
  if (!previous_section)
    {
      as_warn (_(".previous without corresponding .section; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  const segT new_section = previous_section;
  const int new_subsection = previous_subsection;

  obj_elf_section_change_hook ();

  subseg_set (new_section, new_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_popsection (int xxx ATTRIBUTE_UNUSED)
{
  if (section_stack == NULL)
    {
      as_warn (_(".popsection without corresponding .pushsection; ignored"));
      return;
    }

  struct section_stack * const top = section_stack;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  section_stack = top->next;
  previous_section = top->prev_seg;
  previous_subsection = top->prev_subseg;
  subseg_set (top->seg, top->subseg);
  free (top);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_line (int ignore ATTRIBUTE_UNUSED)
{
  void *expr = get_absolute_expression ();

  if (expr != NULL)
    {
      new_logical_line (NULL, expr);
      demand_empty_rest_of_line ();
    }
}

static struct elf_versioned_name_list *
obj_elf_find_and_add_versioned_name (const char *version_name,
				     const char *sym_name,
				     const char *ver,
				     struct elf_obj_sy *sy_obj)
{
  const char *p = ver;
  while (*p == ELF_VER_CHR)
    {
      p++;
    }

  size_t prefix_len = p - ver;

  if (prefix_len < 1 || prefix_len > 3)
    {
      as_bad (_("invalid version name '%s' for symbol `%s'"),
	      version_name, sym_name);
      return NULL;
    }

  if (prefix_len == 3)
    {
      if (sy_obj->rename
	  && (sy_obj->versioned_name == NULL
	      || strcmp (sy_obj->versioned_name->name, version_name) != 0))
	{
	  as_bad (_("only one version name with `@@@' is allowed "
		    "for symbol `%s'"), sym_name);
	  return NULL;
	}
      sy_obj->rename = true;
    }

  for (struct elf_versioned_name_list *current = sy_obj->versioned_name;
       current != NULL;
       current = current->next)
    {
      if (strcmp (current->name, version_name) == 0)
	{
	  return current;
	}
    }

  struct elf_versioned_name_list *new_entry;
  new_entry = notes_alloc (sizeof (*new_entry));
  new_entry->name = notes_strdup (version_name);
  new_entry->next = sy_obj->versioned_name;
  sy_obj->versioned_name = new_entry;

  return new_entry;
}

/* This handles the .symver pseudo-op, which is used to specify a
   symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.
   SYMVERNAME may contain ELF_VER_CHR ('@') characters.  This
   pseudo-op causes the assembler to emit a symbol named SYMVERNAME
   with the same value as the symbol NAME.  */

static void
obj_elf_symver (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym = get_sym_from_input_line_and_check ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .symver"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  char *name;
  char c;
  {
    char old_lexat = lex_type[(unsigned char) '@'];
    lex_type[(unsigned char) '@'] |= LEX_NAME;
    c = get_symbol_name (&name);
    lex_type[(unsigned char) '@'] = old_lexat;
  }

  const char *sym_name = S_GET_NAME (sym);

  if (S_IS_COMMON (sym))
    {
      as_bad (_("`%s' can't be versioned to common symbol '%s'"),
	      name, sym_name);
      ignore_rest_of_line ();
      return;
    }

  char *p = strchr (name, ELF_VER_CHR);
  if (p == NULL)
    {
      as_bad (_("missing version name in `%s' for symbol `%s'"),
	      name, sym_name);
      ignore_rest_of_line ();
      return;
    }

  struct elf_obj_sy *sy_obj = symbol_get_obj (sym);
  if (obj_elf_find_and_add_versioned_name (name, sym_name,
					   p, sy_obj) == NULL)
    {
      sy_obj->bad_version = true;
      ignore_rest_of_line ();
      return;
    }

  (void) restore_line_pointer (c);

  if (*input_line_pointer == ',')
    {
      char *save_p = input_line_pointer;
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      static const struct
      {
	const char *keyword;
	size_t len;
	int visibility;
      }
      vis_keywords[] = {
	{ "local",  5, visibility_local  },
	{ "hidden", 6, visibility_hidden },
	{ "remove", 6, visibility_remove }
      };

      int found_keyword = 0;
      for (size_t i = 0; i < sizeof (vis_keywords) / sizeof (vis_keywords[0]); ++i)
	{
	  if (startswith (input_line_pointer, vis_keywords[i].keyword))
	    {
	      sy_obj->visibility = vis_keywords[i].visibility;
	      input_line_pointer += vis_keywords[i].len;
	      found_keyword = 1;
	      break;
	    }
	}

      if (!found_keyword)
	{
	  input_line_pointer = save_p;
	}
    }

  demand_empty_rest_of_line ();
}

/* This handles the .vtable_inherit pseudo-op, which is used to indicate
   to the linker the hierarchy in which a particular table resides.  The
   syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */

struct fix *
obj_elf_get_vtable_inherit (void)
{
  char *cname;
  symbolS *csym;
  char c;

  if (*input_line_pointer == '#')
    {
      ++input_line_pointer;
    }

  c = get_symbol_name (&cname);
  csym = symbol_find (cname);
  restore_line_pointer (c);

  if (csym == NULL || symbol_get_frag (csym) == NULL)
    {
      as_bad (_("expected `%s' to have already been set for .vtable_inherit"),
	      cname);
      ignore_rest_of_line ();
      return NULL;
    }

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .vtable_inherit"));
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  if (*input_line_pointer == '#')
    {
      ++input_line_pointer;
    }

  symbolS *psym;
  bool is_parent_zero = (input_line_pointer[0] == '0'
			 && (is_end_of_stmt (input_line_pointer[1])
			     || is_whitespace (input_line_pointer[1])));

  if (is_parent_zero)
    {
      psym = section_symbol (absolute_section);
      ++input_line_pointer;
    }
  else
    {
      char *pname;
      c = get_symbol_name (&pname);
      psym = symbol_find_or_make (pname);
      restore_line_pointer (c);
    }

  demand_empty_rest_of_line ();

  gas_assert (symbol_get_value_expression (csym)->X_op == O_constant);
  return fix_new (symbol_get_frag (csym),
		  symbol_get_value_expression (csym)->X_add_number,
		  0, psym, 0, 0, BFD_RELOC_VTABLE_INHERIT);
}

/* This is a version of obj_elf_get_vtable_inherit() that is
   suitable for use in struct _pseudo_type tables.  */

void
obj_elf_vtable_inherit (int)
{
  (void) obj_elf_get_vtable_inherit ();
}

/* This handles the .vtable_entry pseudo-op, which is used to indicate
   to the linker that a vtable slot was used.  The syntax is
   ".vtable_entry tablename, offset".  */

static inline void
skip_optional_hash (void)
{
  if (*input_line_pointer == '#')
    {
      ++input_line_pointer;
    }
}

static int
consume_comma_or_fail (void)
{
  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .vtable_entry"));
      ignore_rest_of_line ();
      return 0;
    }
  ++input_line_pointer;
  return 1;
}

struct fix *
obj_elf_get_vtable_entry (void)
{
  symbolS *sym;
  offsetT offset;

  skip_optional_hash ();

  sym = get_sym_from_input_line_and_check ();
  if (sym == NULL)
    {
      return NULL;
    }

  if (!consume_comma_or_fail ())
    {
      return NULL;
    }

  skip_optional_hash ();

  offset = get_absolute_expression ();

  demand_empty_rest_of_line ();

  return fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
		  BFD_RELOC_VTABLE_ENTRY);
}

/* This is a version of obj_elf_get_vtable_entry() that is
   suitable for use in struct _pseudo_type tables.  */

void obj_elf_vtable_entry(int)
{
    (void)obj_elf_get_vtable_entry();
}

#define skip_whitespace(str)  do { if (is_whitespace (*(str))) ++(str); } while (0)

static inline int
skip_past_char (char ** str, char c)
{
  if (!str || !*str || **str != c)
    {
      return -1;
    }
  (*str)++;
  return 0;
}
#define skip_past_comma(str) skip_past_char (str, ',')

/* A list of attributes that have been explicitly set by the assembly code.
   VENDOR is the vendor id, BASE is the tag shifted right by the number
   of bits in MASK, and bit N of MASK is set if tag BASE+N has been set.  */
struct recorded_attribute_info {
  struct recorded_attribute_info *next;
  int vendor;
  unsigned int base;
  unsigned long mask;
};
static struct recorded_attribute_info *recorded_attributes;

/* Record that we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

#include <limits.h>
#include <stdlib.h>

static void
record_attribute (int vendor, unsigned int tag)
{
  struct recorded_attribute_info *rai;
  const unsigned int bits_per_mask = CHAR_BIT * sizeof(rai->mask);
  const unsigned int base = tag / bits_per_mask;
  const unsigned long mask = 1UL << (tag % bits_per_mask);

  for (rai = recorded_attributes; rai != NULL; rai = rai->next)
    {
      if (rai->vendor == vendor && rai->base == base)
        {
          rai->mask |= mask;
          return;
        }
    }

  rai = XNEW (struct recorded_attribute_info);
  if (rai == NULL)
    {
      return;
    }

  rai->next = recorded_attributes;
  rai->vendor = vendor;
  rai->base = base;
  rai->mask = mask;
  recorded_attributes = rai;
}

/* Return true if we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

bool
obj_elf_seen_attribute (int vendor, unsigned int tag)
{
  const unsigned int bits_per_mask = 8 * sizeof (recorded_attributes->mask);
  const unsigned int base = tag / bits_per_mask;
  const unsigned long mask = 1UL << (tag % bits_per_mask);

  for (const struct recorded_attribute_info *rai = recorded_attributes; rai; rai = rai->next)
    {
      if (rai->vendor == vendor && rai->base == base)
        {
          return (rai->mask & mask) != 0;
        }
    }

  return false;
}

/* Parse an attribute directive for VENDOR.
   Returns the attribute number read, or zero on error.  */

int
obj_elf_vendor_attribute (int vendor)
{
  expressionS exp;
  int tag;

  skip_whitespace (input_line_pointer);
  if (ISDIGIT (*input_line_pointer))
    {
      expression (&exp);
      if (exp.X_op != O_constant)
	{
	  as_bad (_("expected numeric constant for tag"));
	  ignore_rest_of_line ();
	  return 0;
	}
      tag = exp.X_add_number;
    }
  else
    {
      char *name_start = input_line_pointer;
      char *name_end = name_start;
      while (ISALNUM (*name_end) || *name_end == '_')
	name_end++;

      if (name_end == name_start)
	{
	  as_bad (_("expected attribute name or number"));
	  ignore_rest_of_line ();
	  return 0;
	}

      char *name = xmemdup0 (name_start, name_end - name_start);
      input_line_pointer = name_end;

#ifndef CONVERT_SYMBOLIC_ATTRIBUTE
#define CONVERT_SYMBOLIC_ATTRIBUTE(a) -1
#endif

      tag = CONVERT_SYMBOLIC_ATTRIBUTE (name);
      if (tag == -1)
	{
	  as_bad (_("Attribute name not recognised: %s"), name);
	  free (name);
	  ignore_rest_of_line ();
	  return 0;
	}
      free (name);
    }

  if (skip_past_comma (&input_line_pointer) == -1)
    {
      as_bad (_("expected comma after attribute tag"));
      ignore_rest_of_line ();
      return 0;
    }

  int type = _bfd_elf_obj_attrs_arg_type (stdoutput, vendor, tag);
  unsigned int int_val = 0;
  char *str_val = NULL;

  if (type & 1)
    {
      expression (&exp);
      if (exp.X_op != O_constant)
	{
	  as_bad (_("expected numeric constant for attribute value"));
	  ignore_rest_of_line ();
	  return 0;
	}
      int_val = exp.X_add_number;
    }

  if ((type & 3) == 3)
    {
      if (skip_past_comma (&input_line_pointer) == -1)
	{
	  as_bad (_("expected comma between attribute values"));
	  ignore_rest_of_line ();
	  return 0;
	}
    }

  if (type & 2)
    {
      int len;
      skip_whitespace (input_line_pointer);
      if (*input_line_pointer != '"')
	{
	  as_bad (_("bad string constant; expected '\"'"));
	  ignore_rest_of_line ();
	  return 0;
	}
      str_val = demand_copy_C_string (&len);
    }

  record_attribute (vendor, tag);
  bool ok = false;
  switch (type & 3)
    {
    case 3:
      ok = bfd_elf_add_obj_attr_int_string (stdoutput, vendor, tag, int_val, str_val);
      break;
    case 2:
      ok = bfd_elf_add_obj_attr_string (stdoutput, vendor, tag, str_val);
      break;
    case 1:
      ok = bfd_elf_add_obj_attr_int (stdoutput, vendor, tag, int_val);
      break;
    default:
      abort ();
    }

  if (!ok)
    as_fatal (_("error adding attribute: %s"),
	      bfd_errmsg (bfd_get_error ()));

  demand_empty_rest_of_line ();
  return tag;
}

/* Parse a .gnu_attribute directive.  */

static void
obj_elf_gnu_attribute (int ATTRIBUTE_UNUSED)
{
  obj_elf_vendor_attribute (OBJ_ATTR_GNU);
}

#ifdef NEED_ECOFF_DEBUG

void
elf_obj_read_begin_hook (void)
{
  if (ECOFF_DEBUGGING)
    {
      ecoff_read_begin_hook ();
    }
}

#else

void
elf_obj_read_begin_hook (void)
{
  /* No-op for builds without ECOFF debug support. */
}

#endif /* NEED_ECOFF_DEBUG */

void
elf_obj_symbol_new_hook (symbolS *symbolP)
{
  if (symbolP == NULL)
    {
      return;
    }

  struct elf_obj_sy *sy_obj = symbol_get_obj (symbolP);
  if (sy_obj == NULL)
    {
      return;
    }

  sy_obj->size = NULL;
  sy_obj->versioned_name = NULL;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    {
      ecoff_symbol_new_hook (symbolP);
    }
#endif
}

/* If size is unset, copy size from src.  Because we don't track whether
   .size has been used, we can't differentiate .size dest, 0 from the case
   where dest's size is unset.  */
void
elf_copy_symbol_size (symbolS *dest, symbolS *src)
{
  if (dest == NULL || src == NULL)
    {
      return;
    }

  struct elf_obj_sy *destelf = symbol_get_obj (dest);
  struct elf_obj_sy *srcelf = symbol_get_obj (src);

  if (destelf == NULL || srcelf == NULL)
    {
      return;
    }

  if (destelf->size == 0 && S_GET_SIZE (dest) == 0)
    {
      destelf->size = srcelf->size;
      S_SET_SIZE (dest, S_GET_SIZE (src));
    }
}

void
elf_copy_symbol_attributes (symbolS *dest, symbolS *src)
{
  if (dest == NULL || src == NULL)
    {
      return;
    }

  elf_copy_symbol_size (dest, src);

  const unsigned char src_other = S_GET_OTHER (src);
  const unsigned char dest_other = S_GET_OTHER (dest);

  const unsigned char visibility_mask = ELF_ST_VISIBILITY (-1);

  const unsigned char preserved_visibility = dest_other & visibility_mask;
  const unsigned char copied_attributes = src_other & ~visibility_mask;

  S_SET_OTHER (dest, preserved_visibility | copied_attributes);
}

static void
write_elf_note_word (bfd_vma value)
{
  const size_t word_size = sizeof (((Elf_External_Note *) 0)->namesz);
  char *p = frag_more (word_size);
  md_number_to_chars (p, value, word_size);
}

static void
create_elf_version_note (const char *name, size_t name_len)
{
  const unsigned int note_alignment = 2;
  const size_t name_size = name_len + 1;

  asection *note_secp = subseg_new (".note", 0);
  bfd_set_section_flags (note_secp, SEC_HAS_CONTENTS | SEC_READONLY);
  record_alignment (note_secp, note_alignment);

  write_elf_note_word (name_size);
  write_elf_note_word (0);
  write_elf_note_word (NT_VERSION);

  char *p = frag_more (name_size);
  memcpy (p, name, name_len);
  p[name_len] = '\0';

  frag_align (note_alignment, 0, 0);
}

void
obj_elf_version (int ignore ATTRIBUTE_UNUSED)
{
  asection *seg = now_seg;
  subsegT subseg = now_subseg;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '\"')
    {
      ++input_line_pointer;
      const char *name = input_line_pointer;

      while (is_a_char (next_char_of_string ()))
	{
	}

      const size_t name_len = input_line_pointer - name;
      create_elf_version_note (name, name_len);
      subseg_set (seg, subseg);
    }
  else
    {
      as_bad (_("expected quoted string"));
    }

  demand_empty_rest_of_line ();
}

static void
obj_elf_size (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c = get_symbol_name (&name);
  char *p = input_line_pointer;

  restore_line_pointer (c);
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      *p = 0;
      as_bad (_("expected comma after name `%s' in .size directive"), name);
      *p = c;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;

  expressionS exp;
  expression (&exp);
  if (exp.X_op == O_absent)
    {
      as_bad (_("missing expression in .size directive"));
      exp.X_op = O_constant;
      exp.X_add_number = 0;
    }

  *p = 0;
  symbolS *sym = symbol_find_or_make (name);
  *p = c;

  if (exp.X_op == O_constant)
    {
      S_SET_SIZE (sym, exp.X_add_number);
      symbol_get_obj (sym)->size = NULL;
    }
  else
    {
      expressionS *size_exp = notes_alloc (sizeof (*size_exp));
      if (size_exp == NULL)
        {
          as_fatal (_("virtual memory exhausted"));
        }
      *size_exp = exp;
      symbol_get_obj (sym)->size = size_exp;
    }

  /* If the symbol in the directive matches the current function being
     processed, indicate end of the current stream of ginsns.  */
  if (flag_synth_cfi
      && S_IS_FUNCTION (sym)
      && sym == ginsn_data_func_symbol ())
    {
      ginsn_data_end (symbol_temp_new_now ());
    }

  demand_empty_rest_of_line ();
}

/* Handle the ELF .type pseudo-op.  This sets the type of a symbol.
   There are six syntaxes:

   The first (used on Solaris) is
       .type SYM,#function
   The second (used on UnixWare) is
       .type SYM,@function
   The third (reportedly to be used on Irix 6.0) is
       .type SYM STT_FUNC
   The fourth (used on NetBSD/Arm and Linux/ARM) is
       .type SYM,%function
   The fifth (used on SVR4/860) is
       .type SYM,"function"
   The sixth (emitted by recent SunPRO under Solaris) is
       .type SYM,[0-9]
   where the integer is the STT_* value.
   */

static char *
obj_elf_type_name(char **line_p, char *cp)
{
    char *token_start = *line_p;

    if (**line_p >= '0' && **line_p <= '9') {
        char *end_p = *line_p;
        while (*end_p >= '0' && *end_p <= '9') {
            end_p++;
        }
        *cp = *end_p;
        *end_p = '\0';
        *line_p = end_p;
    } else {
        *cp = get_symbol_name(line_p);
    }

    return token_start;
}

typedef enum
{
  ELF_SYM_TYPE_SIMPLE,
  ELF_SYM_TYPE_COMMON,
  ELF_SYM_TYPE_GNU_IFUNC,
  ELF_SYM_TYPE_GNU_UNIQUE
} elf_symbol_type_kind;

typedef struct
{
  const char *name;
  int type_flag;
  elf_symbol_type_kind kind;
} elf_symbol_type_map;

static const elf_symbol_type_map symbol_type_map[] = {
  {"function", BSF_FUNCTION, ELF_SYM_TYPE_SIMPLE},
  {"2", BSF_FUNCTION, ELF_SYM_TYPE_SIMPLE},
  {"STT_FUNC", BSF_FUNCTION, ELF_SYM_TYPE_SIMPLE},
  {"object", BSF_OBJECT, ELF_SYM_TYPE_SIMPLE},
  {"1", BSF_OBJECT, ELF_SYM_TYPE_SIMPLE},
  {"STT_OBJECT", BSF_OBJECT, ELF_SYM_TYPE_SIMPLE},
  {"tls_object", BSF_OBJECT | BSF_THREAD_LOCAL, ELF_SYM_TYPE_SIMPLE},
  {"6", BSF_OBJECT | BSF_THREAD_LOCAL, ELF_SYM_TYPE_SIMPLE},
  {"STT_TLS", BSF_OBJECT | BSF_THREAD_LOCAL, ELF_SYM_TYPE_SIMPLE},
  {"notype", 0, ELF_SYM_TYPE_SIMPLE},
  {"0", 0, ELF_SYM_TYPE_SIMPLE},
  {"STT_NOTYPE", 0, ELF_SYM_TYPE_SIMPLE},
  {"common", BSF_OBJECT, ELF_SYM_TYPE_COMMON},
  {"5", BSF_OBJECT, ELF_SYM_TYPE_COMMON},
  {"STT_COMMON", BSF_OBJECT, ELF_SYM_TYPE_COMMON},
  {"gnu_indirect_function", BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION, ELF_SYM_TYPE_GNU_IFUNC},
  {"10", BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION, ELF_SYM_TYPE_GNU_IFUNC},
  {"STT_GNU_IFUNC", BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION, ELF_SYM_TYPE_GNU_IFUNC},
  {"gnu_unique_object", BSF_OBJECT | BSF_GNU_UNIQUE, ELF_SYM_TYPE_GNU_UNIQUE}
};

static const elf_symbol_type_map *
find_symbol_type_map (const char *type_name)
{
  for (size_t i = 0; i < sizeof (symbol_type_map) / sizeof (symbol_type_map[0]); ++i)
    {
      if (strcmp (type_name, symbol_type_map[i].name) == 0)
	return &symbol_type_map[i];
    }
  return NULL;
}

static void
handle_common_type (symbolS **sym_p)
{
  symbolS *sym = *sym_p;
  if (S_IS_COMMON (sym))
    return;

  if (S_IS_DEFINED (sym) || symbol_equated_p (sym))
    as_bad (_("symbol '%s' is already defined"), S_GET_NAME (sym));

  if (S_IS_VOLATILE (sym))
    {
      *sym_p = symbol_clone (sym, 1);
      sym = *sym_p;
      symbol_set_frag (sym, &zero_address_frag);
      S_CLEAR_VOLATILE (sym);
    }

  /* FIXME: Is it safe to just change the section ?  */
  S_SET_SEGMENT (sym, bfd_com_section_ptr);
  S_SET_VALUE (sym, 0);
  S_SET_EXTERNAL (sym);
}

static void
handle_gnu_ifunc_type (const char *type_name)
{
  const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
  if (bed->elf_osabi != ELFOSABI_NONE
      && bed->elf_osabi != ELFOSABI_GNU
      && bed->elf_osabi != ELFOSABI_FREEBSD)
    as_bad (_("symbol type \"%s\" is supported only by GNU "
	      "and FreeBSD targets"), type_name);
  else if (bed->target_id == MIPS_ELF_DATA)
    as_bad (_("symbol type \"%s\" is not supported by "
	      "MIPS targets"), type_name);

  elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
}

static void
handle_gnu_unique_type (const char *type_name)
{
  const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
  if (bed->elf_osabi != ELFOSABI_NONE
      && bed->elf_osabi != ELFOSABI_GNU)
    as_bad (_("symbol type \"%s\" is supported only by GNU targets"),
	    type_name);

  elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_unique;
}

static void
apply_symbol_type_change (symbolS *sym, elf_symbol_type *elfsym, int type)
{
#ifdef md_elf_symbol_type_change
  if (md_elf_symbol_type_change (sym, elfsym, type))
    return;
#endif

  flagword mask = BSF_FUNCTION | BSF_OBJECT;
  int final_type = type;

  if (final_type != BSF_FUNCTION)
    mask |= BSF_GNU_INDIRECT_FUNCTION;

  if (final_type != BSF_OBJECT)
    {
      mask |= BSF_GNU_UNIQUE | BSF_THREAD_LOCAL;
      if (S_IS_COMMON (sym))
	{
	  as_bad (_("cannot change type of common symbol '%s'"),
		  S_GET_NAME (sym));
	  final_type = 0;
	  mask = 0;
	}
    }

  if (final_type)
    {
      flagword new_flags = (elfsym->symbol.flags & ~mask) | final_type;
      if (new_flags != (elfsym->symbol.flags | final_type))
	as_warn (_("symbol '%s' already has its type set"), S_GET_NAME (sym));
      elfsym->symbol.flags = new_flags;
    }
  else
    {
      elfsym->symbol.flags &= ~mask;
    }
}

static void
parse_elf_type_directive_prefix (char *c_p)
{
  *c_p = *input_line_pointer;

  if (*input_line_pointer == ',')
    ++input_line_pointer;

  SKIP_WHITESPACE ();

  switch (*input_line_pointer)
    {
    case '#':
    case '@':
    case '"':
    case '%':
      ++input_line_pointer;
      break;
    default:
      break;
    }
}

static void
obj_elf_type (int ignore ATTRIBUTE_UNUSED)
{
  char c;
  int type = 0;
  const char *type_name;
  symbolS *sym;
  elf_symbol_type *elfsym;

  sym = get_sym_from_input_line_and_check ();
  elfsym = (elf_symbol_type *) symbol_get_bfdsym (sym);

  parse_elf_type_directive_prefix (&c);
  type_name = obj_elf_type_name (&c);

  const elf_symbol_type_map *map = find_symbol_type_map (type_name);

  if (map)
    {
      type = map->type_flag;
      switch (map->kind)
	{
	case ELF_SYM_TYPE_SIMPLE:
	  break;
	case ELF_SYM_TYPE_COMMON:
	  handle_common_type (&sym);
	  break;
	case ELF_SYM_TYPE_GNU_IFUNC:
	  handle_gnu_ifunc_type (type_name);
	  break;
	case ELF_SYM_TYPE_GNU_UNIQUE:
	  handle_gnu_unique_type (type_name);
	  break;
	}
    }
#ifdef md_elf_symbol_type
  else if ((type = md_elf_symbol_type (type_name, sym, elfsym)) != -1)
    {
    }
#endif
  else
    {
      as_bad (_("unrecognized symbol type \"%s\""), type_name);
    }

  *input_line_pointer = c;
  if (*input_line_pointer == '"')
    ++input_line_pointer;

  apply_symbol_type_change (sym, elfsym, type);

  if (S_IS_FUNCTION (sym) && flag_synth_cfi)
    {
      if (frchain_now->frch_ginsn_data)
	ginsn_data_end (symbol_temp_new_now ());
      ginsn_data_begin (sym);
    }

  demand_empty_rest_of_line ();
}

static segT comment_section;

static void
obj_elf_ident (int ignore ATTRIBUTE_UNUSED)
{
  segT old_section = now_seg;
  int old_subsection = now_subseg;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (!comment_section)
    {
      comment_section = subseg_new (".comment", 0);
      assert (comment_section != NULL);

      bfd_set_section_flags (comment_section, (SEC_READONLY | SEC_HAS_CONTENTS
					       | SEC_MERGE | SEC_STRINGS));
      comment_section->entsize = 1;

      char *p = frag_more (1);
      assert (p != NULL);
      *p = 0;
    }
  else
    {
      subseg_set (comment_section, 0);
    }

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif

  stringer (8 + 1);

  subseg_set (old_section, old_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

#ifdef INIT_STAB_SECTION

/* The first entry in a .stabs section is special.  */

void
obj_elf_init_stab_section (segT stab, segT stabstr)
{
  char *file;
  char *p;
  unsigned int stroff;

  /* Force the section to align to a longword boundary.  Without this,
     UnixWare ar crashes.  */
  bfd_set_section_alignment (stab, 2);

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  file = remap_debug_filename (as_where (NULL));
  stroff = get_stab_string_offset (file, stabstr);
  know (stroff == 1 || (stroff == 0 && file[0] == '\0'));
  md_number_to_chars (p, stroff, 4);
  seg_info (stab)->stabu.p = p;
  free (file);
}

#endif

/* Called via bfd_map_over_sections.  If SEC's linked_to_symbol_name
   isn't NULL, set up its linked-to section.
   For .stabs section, fill in the counts in the first entry.  */

static void
handle_stab_section_info (bfd *abfd, asection *sec)
{
  if (!startswith (sec->name, ".stab"))
    return;

  size_t name_len = strlen (sec->name);
  if (name_len >= 3 && strcmp (sec->name + name_len - 3, "str") == 0)
    return;

  char *name = concat (sec->name, "str", (const char *) NULL);
  asection *strsec = bfd_get_section_by_name (abfd, name);
  int strsz = strsec ? bfd_section_size (strsec) : 0;
  int nsyms = bfd_section_size (sec) / 12 - 1;

  char *p = seg_info (sec)->stabu.p;
  gas_assert (p != NULL);

  bfd_h_put_16 (abfd, nsyms, p + 6);
  bfd_h_put_32 (abfd, strsz, p + 8);
  free (name);
}

static void
set_additional_section_info (bfd *abfd,
			     asection *sec,
			     void *inf ATTRIBUTE_UNUSED)
{
  if (sec->map_head.linked_to_symbol_name)
    {
      symbolS *linked_to_sym =
	symbol_find (sec->map_head.linked_to_symbol_name);
      if (!linked_to_sym || !S_IS_DEFINED (linked_to_sym))
	as_bad (_("undefined linked-to symbol `%s' on section `%s'"),
		sec->map_head.linked_to_symbol_name,
		bfd_section_name (sec));
      else
	elf_linked_to_section (sec) = S_GET_SEGMENT (linked_to_sym);
    }

  handle_stab_section_info (abfd, sec);
}

#ifdef NEED_ECOFF_DEBUG

/* This function is called by the ECOFF code.  It is supposed to
   record the external symbol information so that the backend can
   write it out correctly.  The ELF backend doesn't actually handle
   this at the moment, so we do it ourselves.  We save the information
   in the symbol.  */

#ifdef OBJ_MAYBE_ELF
static
#endif
void
elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)
{
  symbol_get_bfdsym (sym)->udata.p = ext;
}

/* This function is called by bfd_ecoff_debug_externals.  It is
   supposed to *EXT to the external symbol information, and return
   whether the symbol should be used at all.  */

static bool
elf_get_extr (asymbol *sym, EXTR *ext)
{
  if (sym->udata.p == NULL)
    return false;
  *ext = *(EXTR *) sym->udata.p;
  return true;
}

/* This function is called by bfd_ecoff_debug_externals.  It has
   nothing to do for ELF.  */

static void
elf_set_index (asymbol *sym ATTRIBUTE_UNUSED,
	       bfd_size_type indx ATTRIBUTE_UNUSED)
{
}

#endif /* NEED_ECOFF_DEBUG */

static void
handle_symbol_size (symbolS *symp, struct elf_obj_sy *sy_obj)
{
  expressionS *size = sy_obj->size;
  if (size == NULL)
    return;

  if (resolve_expression (size) && size->X_op == O_constant)
    {
      S_SET_SIZE (symp, size->X_add_number);
    }
  else
    {
      const char *msg = _(".size expression for %s does not evaluate to a constant");
      const char *sym_name = S_GET_NAME (symp);
      if (!flag_allow_nonconst_size)
	as_bad (msg, sym_name);
      else
	as_warn (msg, sym_name);
    }
  sy_obj->size = NULL;
}

static void
create_versioned_aliases (symbolS *symp, struct elf_versioned_name_list *versioned_name)
{
  valueT val = (S_GET_VALUE (symp)
		- (symbol_get_frag (symp)->fr_address / OCTETS_PER_BYTE));

  for (; versioned_name != NULL; versioned_name = versioned_name->next)
    {
      symbolS *symp2 = symbol_find_or_make (versioned_name->name);

      S_SET_SEGMENT (symp2, S_GET_SEGMENT (symp));
      S_SET_VALUE (symp2, val);
      symbol_set_frag (symp2, symbol_get_frag (symp));
      copy_symbol_attributes (symp2, symp);
      S_SET_OTHER (symp2, S_GET_OTHER (symp));

      if (S_IS_WEAK (symp))
	S_SET_WEAK (symp2);

      if (S_IS_EXTERNAL (symp))
	S_SET_EXTERNAL (symp2);
    }
}

static void
apply_symbol_visibility (symbolS *symp, struct elf_obj_sy *sy_obj)
{
  switch (sy_obj->visibility)
    {
    case visibility_unchanged:
      break;
    case visibility_hidden:
      {
	asymbol *bfdsym = symbol_get_bfdsym (symp);
	elf_symbol_type *elfsym = elf_symbol_from (bfdsym);
	elfsym->internal_elf_sym.st_other &= ~3;
	elfsym->internal_elf_sym.st_other |= STV_HIDDEN;
	break;
      }
    case visibility_remove:
      if (symbol_used_in_reloc_p (symp))
	{
	  if (sy_obj->versioned_name->next != NULL)
	    as_bad (_("symbol '%s' with multiple versions cannot be used in relocation"),
		    S_GET_NAME (symp));
	  symbol_mark_removed (symp);
	}
      else
	{
	  symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	}
      break;
    case visibility_local:
      S_CLEAR_EXTERNAL (symp);
      break;
    }
}

static void
handle_symbol_versioning (symbolS *symp, struct elf_obj_sy *sy_obj, int *puntp)
{
  struct elf_versioned_name_list *versioned_name = sy_obj->versioned_name;
  if (versioned_name == NULL)
    return;

  if (sy_obj->bad_version)
    {
      *puntp = true;
      return;
    }

  if (sy_obj->rename)
    {
      S_SET_NAME (symp, versioned_name->name);
    }
  else if (S_IS_COMMON (symp))
    {
      as_bad (_("`%s' can't be versioned to common symbol '%s'"),
	      versioned_name->name, S_GET_NAME (symp));
      *puntp = true;
    }
  else
    {
      create_versioned_aliases (symp, versioned_name);
      apply_symbol_visibility (symp, sy_obj);
    }
}

static void
check_weak_common_conflict (symbolS *symp)
{
  if (S_IS_WEAK (symp) && S_IS_COMMON (symp))
    {
      as_bad (_("symbol `%s' can not be both weak and common"),
	      S_GET_NAME (symp));
    }
}

void
elf_frob_symbol (symbolS *symp, int *puntp)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_frob_symbol (symp);
#endif

  struct elf_obj_sy *sy_obj = symbol_get_obj (symp);

  handle_symbol_size (symp, sy_obj);
  handle_symbol_versioning (symp, sy_obj, puntp);
  check_weak_common_conflict (symp);
}

/* Fix up SYMPP which has been marked to be removed by .symver.  */

void
elf_fixup_removed_symbol (symbolS **sympp)
{
  if (sympp == NULL || *sympp == NULL)
    {
      return;
    }

  struct elf_obj_sy *sy_obj = symbol_get_obj (*sympp);

  if (sy_obj != NULL && sy_obj->versioned_name != NULL
      && sy_obj->versioned_name->name != NULL)
    {
      *sympp = symbol_find (sy_obj->versioned_name->name);
    }
}

/* Create symbols for group signature.  */

void
elf_adjust_symtab (void)
{
  for (unsigned int i = 0; i < groups.num_group; i++)
    {
      asection * const group_head = groups.head[i];
      const char * const group_name = elf_group_name (group_head);
      flagword flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;

      for (asection * member = group_head; member != NULL; member = elf_next_in_group (member))
	{
	  if (member->flags & SEC_LINK_ONCE)
	    {
	      flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
	      if (member != group_head)
		{
		  as_warn (_("assuming all members of group `%s' are COMDAT"),
			   group_name);
		}
	      break;
	    }
	}

      const char *sec_name = ".group";
      const unsigned int alignment = 2;
      asection *group_section = subseg_force_new (sec_name, 0);
      if (group_section == NULL
	  || !bfd_set_section_flags (group_section, flags)
	  || !bfd_set_section_alignment (group_section, alignment))
	{
	  as_fatal (_("can't create group: %s"),
		    bfd_errmsg (bfd_get_error ()));
	}
      elf_section_type (group_section) = SHT_GROUP;

      elf_next_in_group (group_section) = group_head;
      elf_sec_group (group_head) = group_section;

      struct symbol *group_symbol = symbol_find_exact (group_name);
      if (group_symbol == NULL
	  || !symbol_on_chain (group_symbol, symbol_rootP, symbol_lastP))
	{
	  group_symbol = symbol_new (group_name, now_seg, frag_now, 0);
#ifdef TE_SOLARIS
	  symbol_get_bfdsym (group_symbol)->flags |= BSF_WEAK;
	  S_SET_OTHER (group_symbol, STV_HIDDEN);
#else
	  symbol_get_obj (group_symbol)->local = 1;
#endif
	  symbol_table_insert (group_symbol);
	}

      elf_group_id (group_section) = symbol_get_bfdsym (group_symbol);
      symbol_mark_used_in_reloc (group_symbol);
    }
}

bfd_boolean
elf_finalize_section_processing (bfd *abfd)
{
  if (!bfd_map_over_sections (abfd, set_additional_section_info, NULL))
  {
    return FALSE;
  }

#ifdef elf_tc_final_processing
  if (!elf_tc_final_processing ())
  {
    return FALSE;
  }
#endif

  return TRUE;
}

/* It removes any unneeded versioned symbols from the symbol table.  */

static bool
is_unused_removable_symbol (symbolS *symp, const struct elf_obj_sy *sy_obj)
{
  if (S_IS_DEFINED (symp))
    {
      return false;
    }

  if (!sy_obj->versioned_name && !S_IS_WEAK (symp))
    {
      return false;
    }

  return symbol_used_p (symp) == 0 && symbol_used_in_reloc_p (symp) == 0;
}

static bool
process_versioned_symbol (symbolS *symp, struct elf_obj_sy *sy_obj,
			  int is_defined)
{
  char *p = strchr (sy_obj->versioned_name->name, ELF_VER_CHR);
  if (!p)
    {
      return true;
    }

  if (sy_obj->rename)
    {
      size_t l = strlen (&p[3]) + 1;
      memmove (&p[1 + is_defined], &p[3], l);
    }

  if (is_defined)
    {
      return true;
    }

  if (!sy_obj->rename && p[1] == ELF_VER_CHR)
    {
      as_bad (_("invalid attempt to declare external "
		"version name as default in symbol `%s'"),
	      sy_obj->versioned_name->name);
      return false;
    }

  if (sy_obj->versioned_name->next)
    {
      as_bad (_("multiple versions [`%s'|`%s'] for "
		"symbol `%s'"),
	      sy_obj->versioned_name->name,
	      sy_obj->versioned_name->next->name, S_GET_NAME (symp));
      return false;
    }

  sy_obj->rename = true;
  return true;
}

void
elf_frob_file_before_adjust (void)
{
  symbolS *symp = symbol_rootP;
  while (symp)
    {
      symbolS *next_symp = symbol_next (symp);
      struct elf_obj_sy *sy_obj = symbol_get_obj (symp);

      if (sy_obj->versioned_name)
	{
	  int is_defined = S_IS_DEFINED (symp) != 0;
	  if (!process_versioned_symbol (symp, sy_obj, is_defined))
	    {
	      return;
	    }
	}

      if (is_unused_removable_symbol (symp, sy_obj))
	{
	  symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	}

      symp = next_symp;
    }
}

/* It is required that we let write_relocs have the opportunity to
   optimize away fixups before output has begun, since it is possible
   to eliminate all fixups for a section and thus we never should
   have generated the relocation section.  */

static bfd_size_type
calculate_group_size (const asection *head)
{
  bfd_size_type size = 4;
  const asection *s;

  for (s = head; s != NULL; s = elf_next_in_group (s))
    {
      size += (s->flags & SEC_RELOC) != 0 ? 8 : 4;
    }
  return size;
}

static void
setup_group_section (asection *group, bfd_size_type size)
{
  subseg_set (group, 0);
  bfd_set_section_size (group, size);
  group->contents = (unsigned char *) frag_more (size);
  group->alloced = 1;
  frag_now->fr_fix = frag_now_fix_octets ();
  frag_wane (frag_now);
}

#ifdef NEED_ECOFF_DEBUG

static void
initialize_debug_pointers (struct ecoff_debug_info *debug, const char *buf)
{
  debug->line = (unsigned char *) (buf + debug->symbolic_header.cbLineOffset);
  debug->external_dnr = (void *) (buf + debug->symbolic_header.cbDnOffset);
  debug->external_pdr = (void *) (buf + debug->symbolic_header.cbPdOffset);
  debug->external_sym = (void *) (buf + debug->symbolic_header.cbSymOffset);
  debug->external_opt = (void *) (buf + debug->symbolic_header.cbOptOffset);
  debug->external_aux = (union aux_ext *) (buf + debug->symbolic_header.cbAuxOffset);
  debug->ss = (char *) (buf + debug->symbolic_header.cbSsOffset);
  debug->external_fdr = (void *) (buf + debug->symbolic_header.cbFdOffset);
  debug->external_rfd = (void *) (buf + debug->symbolic_header.cbRfdOffset);
}

static void
write_mdebug_section (asection *sec, struct ecoff_debug_info *debug,
		      const struct ecoff_debug_swap *debug_swap,
		      const void *buf)
{
  gas_assert (sec != NULL);
  know (!stdoutput->output_has_begun);

  bfd_set_section_size (sec,
			bfd_ecoff_debug_size (stdoutput, debug, debug_swap));

  if (!bfd_set_section_contents (stdoutput, sec, buf, 0, 0))
    {
      as_fatal (_("can't start writing .mdebug section: %s"),
		bfd_errmsg (bfd_get_error ()));
    }

  know (stdoutput->output_has_begun);
  know (sec->filepos != 0);

  if (!bfd_ecoff_write_debug (stdoutput, debug, debug_swap, sec->filepos))
    {
      as_fatal (_("could not write .mdebug section: %s"),
		bfd_errmsg (bfd_get_error ()));
    }
}

static void
generate_ecoff_debug_info (void)
{
  const struct ecoff_debug_swap *debug_swap;
  struct ecoff_debug_info debug;
  asection *sec;
  char *buf;

  if (!ECOFF_DEBUGGING)
    {
      return;
    }

  debug_swap = get_elf_backend_data (stdoutput)->elf_backend_ecoff_debug_swap;
  know (debug_swap != NULL);

  ecoff_build_debug (&debug.symbolic_header, &buf, debug_swap);

  debug.alloc_syments = true;
  initialize_debug_pointers (&debug, buf);

  debug.ssext = debug.ssext_end = NULL;
  debug.external_ext = debug.external_ext_end = NULL;
  if (!bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, true,
				  elf_get_extr, elf_set_index))
    {
      as_fatal (_("failed to set up debugging information: %s"),
		bfd_errmsg (bfd_get_error ()));
    }

  sec = bfd_get_section_by_name (stdoutput, ".mdebug");
  write_mdebug_section (sec, &debug, debug_swap, buf);
}
#endif /* NEED_ECOFF_DEBUG */

void
elf_frob_file_after_relocs (void)
{
  unsigned int i;

  for (i = 0; i < groups.num_group; i++)
    {
      asection *head = groups.head[i];
      asection *group = elf_sec_group (head);
      bfd_size_type size = calculate_group_size (head);
      setup_group_section (group, size);
    }

#ifdef NEED_ECOFF_DEBUG
  generate_ecoff_debug_info ();
#endif /* NEED_ECOFF_DEBUG */
}

/* This is called when the assembler starts.  */

void
elf_begin (void)
{
  static const char *const known_sections[] = {
    TEXT_SECTION_NAME,
    DATA_SECTION_NAME,
    BSS_SECTION_NAME
  };

  for (size_t i = 0; i < sizeof (known_sections) / sizeof (known_sections[0]); ++i)
    {
      asection *s = bfd_get_section_by_name (stdoutput, known_sections[i]);
      if (s != NULL)
        {
          symbol_table_insert (section_symbol (s));
        }
    }

  elf_com_section_ptr = bfd_com_section_ptr;
  previous_section = NULL;
  previous_subsection = 0;
  comment_section = NULL;
  memset (&groups, 0, sizeof (groups));
}

void
elf_end (void)
{
  while (section_stack)
    {
      struct section_stack *next = section_stack->next;
      free (section_stack);
      section_stack = next;
    }

  while (recorded_attributes)
    {
      struct recorded_attribute_info *next = recorded_attributes->next;
      free (recorded_attributes);
      recorded_attributes = next;
    }

  if (groups.indexes)
    {
      htab_delete (groups.indexes);
      free (groups.head);
      groups.indexes = NULL;
      groups.head = NULL;
    }
}

#ifdef USE_EMULATIONS

static bfd_vma
elf_s_get_size (symbolS *sym)
{
  return S_GET_SIZE (sym);
}

static void
elf_s_set_size (symbolS *sym, bfd_vma sz)
{
  S_SET_SIZE (sym, sz);
}

static bfd_vma
elf_s_get_align (symbolS *sym)
{
  return S_GET_ALIGN (sym);
}

static void
elf_s_set_align (symbolS *sym, bfd_vma align)
{
  S_SET_ALIGN (sym, align);
}

int
elf_s_get_other (symbolS *sym)
{
  return elf_symbol (symbol_get_bfdsym (sym))->internal_elf_sym.st_other;
}

static void
elf_s_set_other (symbolS *sym, int other)
{
  S_SET_OTHER (sym, other);
}

static int
elf_sec_sym_ok_for_reloc (asection *sec)
{
  return obj_sec_sym_ok_for_reloc (sec);
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_process_stab (int what ATTRIBUTE_UNUSED,
		  const char *string ATTRIBUTE_UNUSED,
		  int type ATTRIBUTE_UNUSED,
		  int other ATTRIBUTE_UNUSED,
		  int desc ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_stab (what, string, type, other, desc);
}
#else
# define elf_process_stab NULL
#endif

static int
elf_separate_stab_sections (void)
{
#ifdef NEED_ECOFF_DEBUG
  return (!ECOFF_DEBUGGING);
#else
  return 1;
#endif
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_init_stab_section (segT stab, segT stabstr)
{
  if (!ECOFF_DEBUGGING)
    obj_elf_init_stab_section (stab, stabstr);
}
#endif

const struct format_ops elf_format_ops =
{
  bfd_target_elf_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  elf_begin,
  elf_end,
  elf_file_symbol,
  NULL, /* assign_symbol */
  elf_frob_symbol,
  elf_frob_file,
  elf_frob_file_before_adjust,
  0,	/* obj_frob_file_before_fix */
  elf_frob_file_after_relocs,
  elf_s_get_size, elf_s_set_size,
  elf_s_get_align, elf_s_set_align,
  elf_s_get_other,
  elf_s_set_other,
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  elf_copy_symbol_attributes,
  elf_process_stab,
  elf_separate_stab_sections,
#ifdef NEED_ECOFF_DEBUG
  elf_init_stab_section,
#else
  obj_elf_init_stab_section,
#endif
  elf_sec_sym_ok_for_reloc,
  elf_pop_insert,
#ifdef NEED_ECOFF_DEBUG
  elf_ecoff_set_ext,
#else
  0,	/* ecoff_set_ext */
#endif
  elf_obj_read_begin_hook,
  elf_obj_symbol_new_hook,
  0,
  elf_adjust_symtab
};

#endif /* USE_EMULATIONS */
