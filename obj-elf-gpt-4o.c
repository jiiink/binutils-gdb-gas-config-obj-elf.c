/* ELF object file format
   Copyright (C) 1992-2025 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 3,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#define OBJ_HEADER "obj-elf.h"
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "obstack.h"
#include "dwarf2dbg.h"
#include "ginsn.h"

#ifndef ECOFF_DEBUGGING
#define ECOFF_DEBUGGING 0
#else
#define NEED_ECOFF_DEBUG
#endif

#ifdef NEED_ECOFF_DEBUG
#include "ecoff.h"
#include "bfd/ecoff-bfd.h"
#endif

#ifdef TC_ALPHA
#include "elf/alpha.h"
#endif

#ifdef TC_MIPS
#include "elf/mips.h"
#endif

#ifdef TC_PPC
#include "elf/ppc.h"
#endif

#ifdef TC_I386
#include "elf/x86-64.h"
#endif

#ifdef TC_MEP
#include "elf/mep.h"
#endif

#ifdef TC_PRU
#include "elf/pru.h"
#endif

static void obj_elf_line (int);
static void obj_elf_size (int);
static void obj_elf_type (int);
static void obj_elf_ident (int);
static void obj_elf_weak (int);
static void obj_elf_local (int);
static void obj_elf_visibility (int);
static void obj_elf_symver (int);
static void obj_elf_subsection (int);
static void obj_elf_popsection (int);
static void obj_elf_gnu_attribute (int);
static void obj_elf_tls_common (int);
static void obj_elf_lcomm (int);
static void obj_elf_struct (int);
static void obj_elf_attach_to_group (int);

static const pseudo_typeS elf_pseudo_table[] =
{
  {"attach_to_group", obj_elf_attach_to_group, 0},
  {"comm", obj_elf_common, 0},
  {"common", obj_elf_common, 1},
  {"ident", obj_elf_ident, 0},
  {"lcomm", obj_elf_lcomm, 0},
  {"local", obj_elf_local, 0},
  {"previous", obj_elf_previous, 0},
  {"section", obj_elf_section, 0},
  {"section.s", obj_elf_section, 0},
  {"sect", obj_elf_section, 0},
  {"sect.s", obj_elf_section, 0},
  {"pushsection", obj_elf_section, 1},
  {"popsection", obj_elf_popsection, 0},
  {"size", obj_elf_size, 0},
  {"type", obj_elf_type, 0},
  {"version", obj_elf_version, 0},
  {"weak", obj_elf_weak, 0},

  /* These define symbol visibility.  */
  {"internal", obj_elf_visibility, STV_INTERNAL},
  {"hidden", obj_elf_visibility, STV_HIDDEN},
  {"protected", obj_elf_visibility, STV_PROTECTED},

  /* These are used for stabs-in-elf configurations.  */
  {"line", obj_elf_line, 0},

  /* This is a GNU extension to handle symbol versions.  */
  {"symver", obj_elf_symver, 0},

  /* A GNU extension to change subsection only.  */
  {"subsection", obj_elf_subsection, 0},

  /* These are GNU extensions to aid in garbage collecting C++ vtables.  */
  {"vtable_inherit", obj_elf_vtable_inherit, 0},
  {"vtable_entry", obj_elf_vtable_entry, 0},

  /* A GNU extension for object attributes.  */
  {"gnu_attribute", obj_elf_gnu_attribute, 0},

  /* These are used for dwarf2.  */
  { "file", dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },
  { "loc_mark_labels", dwarf2_directive_loc_mark_labels, 0 },

  /* We need to trap the section changing calls to handle .previous.  */
  {"data", obj_elf_data, 0},
  {"offset", obj_elf_struct, 0},
  {"struct", obj_elf_struct, 0},
  {"text", obj_elf_text, 0},
  {"bss", obj_elf_bss, 0},

  {"tls_common", obj_elf_tls_common, 0},

  /* End sentinel.  */
  {NULL, NULL, 0},
};

static const pseudo_typeS ecoff_debug_pseudo_table[] =
{
#ifdef NEED_ECOFF_DEBUG
  /* COFF style debugging information for ECOFF. .ln is not used; .loc
     is used instead.  */
  { "def",	ecoff_directive_def,	0 },
  { "dim",	ecoff_directive_dim,	0 },
  { "endef",	ecoff_directive_endef,	0 },
  { "file",	ecoff_directive_file,	0 },
  { "scl",	ecoff_directive_scl,	0 },
  { "tag",	ecoff_directive_tag,	0 },
  { "val",	ecoff_directive_val,	0 },

  /* COFF debugging requires pseudo-ops .size and .type, but ELF
     already has meanings for those.  We use .esize and .etype
     instead.  These are only generated by gcc anyhow.  */
  { "esize",	ecoff_directive_size,	0 },
  { "etype",	ecoff_directive_type,	0 },

  /* ECOFF specific debugging information.  */
  { "aent",	ecoff_directive_ent,	1 },
  { "begin",	ecoff_directive_begin,	0 },
  { "bend",	ecoff_directive_bend,	0 },
  { "end",	ecoff_directive_end,	0 },
  { "ent",	ecoff_directive_ent,	0 },
  { "fmask",	ecoff_directive_fmask,	0 },
  { "frame",	ecoff_directive_frame,	0 },
  { "loc",	ecoff_directive_loc,	0 },
  { "mask",	ecoff_directive_mask,	0 },

  /* Other ECOFF directives.  */
  { "extern",	ecoff_directive_extern,	0 },

  /* These are used on Irix.  I don't know how to implement them.  */
  { "alias",	s_ignore,		0 },
  { "bgnb",	s_ignore,		0 },
  { "endb",	s_ignore,		0 },
  { "lab",	s_ignore,		0 },
  { "noalias",	s_ignore,		0 },
  { "verstamp",	s_ignore,		0 },
  { "vreg",	s_ignore,		0 },
#endif

  {NULL, NULL, 0}			/* end sentinel */
};

#undef NO_RELOC
#include "aout/aout64.h"

asection *elf_com_section_ptr;

#include <stdbool.h>

void pop_insert(const char *table);

static const char *elf_pseudo_table = "ELF Table";
static const char *ecoff_debug_pseudo_table = "ECOFF Debug Table";
static const bool ECOFF_DEBUGGING = true;

void elf_pop_insert(void) {
    pop_insert(elf_pseudo_table);

    if (ECOFF_DEBUGGING) {
        pop_insert(ecoff_debug_pseudo_table);
    }
}

void elf_file_symbol(const char *s) {
    asymbol *bsym;
    symbolS *sym = symbol_new(s, absolute_section, &zero_address_frag, 0);
    size_t name_length = strlen(s);

    if (name_length > strlen(S_GET_NAME(sym))) {
        obstack_grow(&notes, s, name_length + 1);
        S_SET_NAME(sym, obstack_finish(&notes));
    } else {
        strncpy((char *)S_GET_NAME(sym), s, name_length + 1);
    }

    symbol_get_bfdsym(sym)->flags |= BSF_FILE;

    if (symbol_rootP != sym) {
        bsym = symbol_get_bfdsym(symbol_rootP);
        if (bsym == NULL || (bsym->flags & BSF_FILE) == 0) {
            symbol_remove(sym, &symbol_rootP, &symbol_lastP);
            symbol_insert(sym, symbol_rootP, &symbol_rootP, &symbol_lastP);
        }
    }
    
#ifdef DEBUG
    verify_symbol_chain(symbol_rootP, symbol_lastP);
#endif

#ifdef NEED_ECOFF_DEBUG
    ecoff_new_file(s);
#endif
}

/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

symbolS *elf_common_parse(int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size) {
    addressT align = 0;
    int is_local = symbol_get_obj(symbolP)->local;

    if (*input_line_pointer == ',') {
        char *save = input_line_pointer;
        input_line_pointer++;
        SKIP_WHITESPACE();

        if (*input_line_pointer == '"') {
            input_line_pointer++;
            if (*input_line_pointer == '.') input_line_pointer++;

            size_t len = 0;
            if (strncmp(input_line_pointer, "bss\"", 4) == 0) {
                len = 4;
            } else if (strncmp(input_line_pointer, "data\"", 5) == 0) {
                len = 5;
            }

            if (len > 0) {
                input_line_pointer += len;
                is_local = 0;
            } else {
                char *end_quote = strchr(input_line_pointer, '"');
                if (end_quote) *end_quote = '\0';
                as_bad(_("bad .common segment %s"), input_line_pointer);
                ignore_rest_of_line();
                return NULL;
            }
        } else {
            input_line_pointer = save;
            align = parse_align(is_local);
            if (align == (addressT)-1) return NULL;
        }
    }

    if (is_local) {
        bss_alloc(symbolP, size, align);
        S_CLEAR_EXTERNAL(symbolP);
    } else {
        S_SET_VALUE(symbolP, size);
        S_SET_ALIGN(symbolP, align);
        S_SET_EXTERNAL(symbolP);
        S_SET_SEGMENT(symbolP, elf_com_section_ptr);
    }

    symbol_get_bfdsym(symbolP)->flags |= BSF_OBJECT;

    return symbolP;
}

void obj_elf_common(int is_common) {
  if (is_common) {
    if (flag_mri) {
      s_mri_common(0);
      return;
    }
  }
  s_comm_internal(0, elf_common_parse);
}

static void obj_elf_tls_common(int ignore) {
    (void)ignore; // Explicitly ignore unused parameter
    symbolS *symbolP = s_comm_internal(0, elf_common_parse);

    if (!symbolP) {
        return; // Handle error where `symbolP` could be NULL more explicitly
    }

    symbol_get_bfdsym(symbolP)->flags |= BSF_THREAD_LOCAL;
}

static void obj_elf_lcomm(int ignore ATTRIBUTE_UNUSED) {
    symbolS *symbolP = s_comm_internal(0, s_lcomm_internal);

    if (symbolP != NULL) {
        symbol_get_bfdsym(symbolP)->flags |= BSF_OBJECT;
    }
}

static symbolS *get_sym_from_input_line_and_check(void) {
    char *name;
    symbolS *sym;

    if (get_symbol_name(&name) == *name) {
        as_bad(_("Missing symbol name in directive"));
        return NULL;
    }

    sym = symbol_find_or_make(name);
    restore_line_pointer(*name);
    SKIP_WHITESPACE();
    
    return sym;
}

static void obj_elf_local(int ignore ATTRIBUTE_UNUSED) {
    symbolS *symbolP;
    do {
        symbolP = get_sym_from_input_line_and_check();
        S_CLEAR_EXTERNAL(symbolP);
        symbol_get_obj(symbolP)->local = 1;
        
        input_line_pointer++;
        SKIP_WHITESPACE();

    } while (*input_line_pointer == ',');

    demand_empty_rest_of_line();
}

static void obj_elf_weak(int ignore ATTRIBUTE_UNUSED) {
    symbolS *symbolP;
    int c;

    do {
        symbolP = get_sym_from_input_line_and_check();
        c = *input_line_pointer;
        S_SET_WEAK(symbolP);

        if (c == ',') {
            input_line_pointer++;
            SKIP_WHITESPACE();

            if (*input_line_pointer == '\n' || *input_line_pointer == '\0') {
                break;
            }
        } else {
            break;
        }
    } while (c == ',');

    demand_empty_rest_of_line();
}

static void obj_elf_visibility(int visibility) {
    int c;
    do {
        symbolS *symbolP = get_sym_from_input_line_and_check();
        if (!symbolP) {
            report_error("Invalid symbol");
            return;
        }

        asymbol *bfdsym = symbol_get_bfdsym(symbolP);
        elf_symbol_type *elfsym = elf_symbol_from(bfdsym);
        if (!elfsym) {
            report_error("Failed to retrieve ELF symbol");
            return;
        }

        elfsym->internal_elf_sym.st_other = (elfsym->internal_elf_sym.st_other & ~3) | visibility;

        c = *input_line_pointer;
        if (c == ',') {
            input_line_pointer++;
            SKIP_WHITESPACE();
            c = (*input_line_pointer == '\n') ? '\n' : *input_line_pointer;
        }
    } while (c == ',');
    
    demand_empty_rest_of_line();
}

static segT previous_section;
static int previous_subsection;

struct section_stack
{
  struct section_stack *next;
  segT seg, prev_seg;
  int subseg, prev_subseg;
};

static struct section_stack *section_stack;

/* ELF section flags for unique sections.  */
#define SEC_ASSEMBLER_SHF_MASK SHF_GNU_RETAIN

struct group_list
{
  asection **head;		/* Section lists.  */
  unsigned int num_group;	/* Number of lists.  */
  htab_t indexes; /* Maps group name to index in head array.  */
};

static struct group_list groups;

static bool
match_section (const asection *sec, const struct elf_section_match *match)
{
  if (sec == NULL || match == NULL) return false;

  const char *linked_to_symbol_name = sec->map_head.linked_to_symbol_name;
  unsigned int sh_info = elf_section_data (sec) ? elf_section_data(sec)->this_hdr.sh_info : 0;
  bfd_vma sh_flags = (elf_section_data (sec) ? elf_section_data(sec)->this_hdr.sh_flags : 0) & SEC_ASSEMBLER_SHF_MASK;
  bfd_vma sec_flags = bfd_section_flags(sec) & SEC_ASSEMBLER_SECTION_ID;

  return (sh_info == match->sh_info &&
          sh_flags == match->sh_flags &&
          sec_flags == (match->flags & SEC_ASSEMBLER_SECTION_ID) &&
          sec->section_id == match->section_id &&
          ((linked_to_symbol_name == match->linked_to_symbol_name) || 
           (linked_to_symbol_name && match->linked_to_symbol_name && 
            strcmp(linked_to_symbol_name, match->linked_to_symbol_name) == 0)));
}

/* Return TRUE iff SEC matches the section info INF.  */

static bool get_section_by_match(bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf) {
    struct elf_section_match *match = inf;
    const char *gname = match->group_name;
    const char *group_name = elf_group_name(sec);

    if (group_name && gname && strcmp(group_name, gname) == 0)
        return match_section(sec, match);
    
    return false;
}

/* Go look in section lists kept per group for SEC_NAME with
   properties given by MATCH.  If info for the group named by
   MATCH->GROUP_NAME has been initialised, set GROUP_IDX.  */

static asection *group_section_find(const struct elf_section_match *match, const char *sec_name, unsigned int *group_idx) {
    if (!groups.indexes) {
        groups.num_group = 0;
        groups.head = NULL;
        groups.indexes = htab_create_alloc(16, hash_string_tuple, eq_string_tuple, NULL, notes_calloc, NULL);
        if (!groups.indexes) {
            *group_idx = ~0u;
            return NULL;
        }
    }

    *group_idx = str_hash_find_int(groups.indexes, match->group_name);
    if (*group_idx == ~0u) {
        return NULL;
    }

    for (asection *s = groups.head[*group_idx]; s != NULL; s = elf_next_in_group(s)) {
        if ((s->name == sec_name || strcmp(s->name, sec_name) == 0) && match_section(s, match)) {
            return s;
        }
    }
    return NULL;
}

/* Insert SEC into section lists kept per group.  MATCH and GROUP_IDX
   must be from a prior call to group_section_find.  */

static void group_section_insert(const struct elf_section_match *match, asection *sec, unsigned int *group_idx) {
    unsigned int i;

    if (*group_idx != ~0u) {
        elf_next_in_group(sec) = groups.head[*group_idx];
        groups.head[*group_idx] = sec;
        return;
    }

    if (groups.num_group % 128 == 0) {
        asection **new_head = realloc(groups.head, (groups.num_group + 128) * sizeof(asection *));
        if (!new_head) {
            // Handle memory allocation error (e.g., log or exit)
            return;
        }
        groups.head = new_head;
    }

    i = groups.num_group;
    groups.head[i] = sec;
    groups.num_group++;

    if (!str_hash_insert_int(groups.indexes, match->group_name, i, 0)) {
        // Handle hash insertion error (e.g., log or rollback changes)
    }
}

/* Handle the .section pseudo-op.  This code supports two different
   syntaxes.

   The first is found on Solaris, and looks like
       .section ".sec1",#alloc,#execinstr,#write
   Here the names after '#' are the SHF_* flags to turn on for the
   section.  I'm not sure how it determines the SHT_* type (BFD
   doesn't really give us control over the type, anyhow).

   The second format is found on UnixWare, and probably most SVR4
   machines, and looks like
       .section .sec1,"a",@progbits
   The quoted string may contain any combination of a, w, x, and
   represents the SHF_* flags to turn on for the section.  The string
   beginning with '@' can be progbits or nobits.  There should be
   other possibilities, but I don't know what they are.  In any case,
   BFD doesn't really let us set the section type.  */

#include <stdbool.h>

static void change_section(const char *name, unsigned int type, bfd_vma attr,
                           int entsize, struct elf_section_match *match_p,
                           bool linkonce, bool push, subsegT new_subsection) {
  asection *old_sec;
  segT sec;
  flagword flags;
  const struct elf_backend_data *bed;
  const struct bfd_elf_special_section *ssect;

  if (!match_p) {
    static struct elf_section_match unused_match;
    match_p = &unused_match;
  }

#ifdef md_flush_pending_output
  md_flush_pending_output();
#endif

  if (push) {
    struct section_stack *elt = XNEW(struct section_stack);
    elt->next = section_stack;
    elt->seg = now_seg;
    elt->prev_seg = previous_section;
    elt->subseg = now_subseg;
    elt->prev_subseg = previous_subsection;
    section_stack = elt;
  }

  obj_elf_section_change_hook();

  unsigned int group_idx = ~0u;
  old_sec = match_p->group_name ? group_section_find(match_p, name, &group_idx)
           : bfd_get_section_by_name_if(stdoutput, name, get_section_by_match, match_p);

  sec = old_sec ? old_sec : subseg_force_new(name, new_subsection);
  if (!old_sec && match_p->group_name) {
    group_section_insert(match_p, sec, &group_idx);
  }

  bed = get_elf_backend_data(stdoutput);
  ssect = bed->get_sec_type_attr(stdoutput, sec);

  if (ssect) {
    bool override = false;
    if (type == SHT_NULL) type = ssect->type;
    else if (type != ssect->type) {
      if (!old_sec && type < SHT_LOPROC &&
          ssect->type != SHT_INIT_ARRAY &&
          ssect->type != SHT_FINI_ARRAY &&
          ssect->type != SHT_PREINIT_ARRAY) {
        as_warn(_("setting incorrect section type for %s"), name);
      } else {
        as_warn(_("ignoring incorrect section type for %s"), name);
        type = ssect->type;
      }
    }
    if (!old_sec && (attr & ~(SHF_LINK_ORDER | SHF_MASKOS | SHF_MASKPROC) & ~ssect->attr) != 0) {
      if (elf_tdata(stdoutput)->has_gnu_osabi) attr &= ~SHF_GNU_RETAIN;
      if (ssect->type == SHT_NOTE && (attr == SHF_ALLOC || attr == SHF_EXECINSTR)) {
      } else if (ssect->suffix_length == -2 && name[ssect->prefix_length] == '.' &&
                 !(attr & ~ssect->attr & ~SHF_MERGE & ~SHF_STRINGS)) {
      } else if (attr == SHF_ALLOC && (!strcmp(name, ".interp") || !strcmp(name, ".strtab") || !strcmp(name, ".symtab"))) {
        override = true;
      } else if (attr == SHF_EXECINSTR && !strcmp(name, ".note.GNU-stack")) {
        override = true;
#ifdef TC_ALPHA
      } else if ((attr & ~ssect->attr) == SHF_ALPHA_GPREL) {
        override = true;
#endif
#ifdef TC_RX
      } else if (attr == (SHF_EXECINSTR | SHF_WRITE | SHF_ALLOC) &&
                 (ssect->type == SHT_INIT_ARRAY || ssect->type == SHT_FINI_ARRAY || ssect->type == SHT_PREINIT_ARRAY)) {
      }
#endif
      else {
        if (!match_p->group_name) as_warn(_("setting incorrect section attributes for %s"), name);
        override = true;
      }
    }
    if (!override && !old_sec) attr |= ssect->attr;
  }

  flags = (SEC_RELOC
           | (attr & SHF_WRITE ? 0 : SEC_READONLY)
           | (attr & SHF_ALLOC ? SEC_ALLOC : 0)
           | ((attr & SHF_ALLOC && type != SHT_NOBITS) ? SEC_LOAD : 0)
           | (attr & SHF_EXECINSTR ? SEC_CODE : 0)
           | (attr & SHF_MERGE ? SEC_MERGE : 0)
           | (attr & SHF_STRINGS ? SEC_STRINGS : 0)
           | (attr & SHF_EXCLUDE ? SEC_EXCLUDE : 0)
           | (attr & SHF_TLS ? SEC_THREAD_LOCAL : 0));
#ifdef md_elf_section_flags
  flags = md_elf_section_flags(flags, attr, type);
#endif

  if (linkonce) flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

  if (!(flags & SEC_ALLOC) && name[0] == '.') {
    if (startswith(name, ".debug") || startswith(name, ".zdebug") ||
        startswith(name, ".gnu.debuglto_.debug_") ||
        startswith(name, ".gnu.linkonce.wi.") ||
        startswith(name, GNU_BUILD_ATTRS_SECTION_NAME) ||
        startswith(name, ".note.gnu")) {
      flags |= SEC_ELF_OCTETS;
    }
  }

  if (!old_sec) {
    symbolS *secsym;
    if (type == SHT_NULL) type = bfd_elf_get_default_section_type(flags);
    elf_section_type(sec) = type;
    elf_section_flags(sec) = attr;
    elf_section_data(sec)->this_hdr.sh_info = match_p->sh_info;
    if (type == SHT_NOBITS) seg_info(sec)->bss = 1;
    sec->section_id = match_p->section_id;
    flags |= match_p->flags;
    sec->map_head.linked_to_symbol_name = match_p->linked_to_symbol_name;
    bfd_set_section_flags(sec, flags);
    if (entsize != 0) sec->entsize = entsize;
    elf_group_name(sec) = match_p->group_name;
    secsym = symbol_find(name);
    if (secsym) {
      static const expressionS exp = { .X_op = O_constant };
      symbol_set_value_expression(secsym, &exp);
      symbol_set_bfdsym(secsym, sec->symbol);
    } else {
      symbol_table_insert(section_symbol(sec));
    }
  } else {
    if (type != SHT_NULL && (unsigned)type != elf_section_type(old_sec)) {
      if (ssect) {
        as_warn(_("ignoring changed section type for %s"), name);
      } else {
        as_bad(_("changed section type for %s"), name);
      }
    }
    if (attr != 0 && ((old_sec->flags ^ flags) & (SEC_ALLOC | SEC_LOAD |
                                                  SEC_READONLY | SEC_CODE |
                                                  SEC_EXCLUDE | SEC_SORT_ENTRIES |
                                                  SEC_MERGE | SEC_STRINGS |
                                                  SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD |
                                                  SEC_THREAD_LOCAL))) {
      if (ssect) {
        as_warn(_("ignoring changed section attributes for %s"), name);
      } else {
        as_bad(_("changed section attributes for %s"), name);
      }
    } else {
      elf_section_flags(sec) = attr;
      if (entsize != 0 && old_sec->entsize != (unsigned)entsize) {
        as_bad(_("changed section entity size for %s"), name);
      }
    }
  }

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook();
#endif
}

void change_section_properties(const char *name, unsigned int type, bfd_vma attr, int entsize, struct elf_section_match *match_p, bool linkonce) {
    change_section(name, type, attr, entsize, match_p, linkonce, false, 0);
}

#include <stdbool.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>

static bfd_vma obj_elf_parse_section_letters(char *str, size_t len, bool push,
                                             bool *is_clone, int *inherit, bfd_vma *gnu_attr,
                                             bool *has_entsize) {
    bfd_vma attr = 0;

    if (!str || !is_clone || !inherit || !has_entsize) {
        return attr;
    }

    *is_clone = false;
    *inherit = 0;

    while (len > 0) {
        char current_char = *str;

        if (current_char == 'a') {
            attr |= SHF_ALLOC;
            if (len > 1 && str[1] == 'm') {
                attr |= SHF_MERGE;
                str++, len--;
                if (len > 1 && str[1] == 's') {
                    attr |= SHF_STRINGS;
                    str++, len--;
                }
            }
        } else if (current_char == 'd') {
            if (gnu_attr) *gnu_attr |= SHF_GNU_MBIND;
            else goto error_unrecognized;
        } else if (current_char == 'e') {
            attr |= SHF_EXCLUDE;
        } else if (current_char == 'o') {
            attr |= SHF_LINK_ORDER;
        } else if (current_char == 'w') {
            attr |= SHF_WRITE;
        } else if (current_char == 'x') {
            attr |= SHF_EXECINSTR;
        } else if (current_char == 'E') {
            *has_entsize = true;
        } else if (current_char == 'G') {
            attr |= SHF_GROUP;
        } else if (current_char == 'M') {
            attr |= SHF_MERGE;
        } else if (current_char == 'R') {
            if (gnu_attr) *gnu_attr |= SHF_GNU_RETAIN;
            else goto error_unrecognized;
        } else if (current_char == 'S') {
            attr |= SHF_STRINGS;
        } else if (current_char == 'T') {
            attr |= SHF_TLS;
        } else if (current_char == '?') {
            *is_clone = true;
        } else if (isdigit(current_char)) {
            char *end;
            errno = 0;
            bfd_vma numeric_flags = strtoul(str, &end, 0);

            if (errno != 0 || end == str) goto error_unrecognized;

            attr |= numeric_flags;

            if (gnu_attr) {
                *gnu_attr |= (numeric_flags & SHF_MASKOS);
            }

            len -= (end - str);
            str = end - 1; // str will be incremented below
        } else if (!*inherit && !attr && (!gnu_attr || !*gnu_attr) &&
                   (current_char == '+' || current_char == '-')) {
            *inherit = (current_char == '+') ? 1 : -1;
        } else {
            error_unrecognized:
            as_bad(_("unrecognized .%ssection attribute: want %s%s%s,? or number"),
                   push ? "push" : "",
                   gnu_attr ? "a,d,e,o,w,x,E,G,M,R,S,T" : "a,e,o,w,x,E,G,M,S,T",
                   "", "");
            return attr;
        }

        str++, len--;
    }

    return attr;
}

#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>

static int obj_elf_section_type(char *str, size_t len, bool warn) {
  typedef struct {
    const char *name;
    size_t length;
    int type;
  } SectionType;

  static const SectionType section_types[] = {
    {"progbits", 8, SHT_PROGBITS},
    {"nobits", 6, SHT_NOBITS},
    {"note", 4, SHT_NOTE},
    {"init_array", 10, SHT_INIT_ARRAY},
    {"fini_array", 10, SHT_FINI_ARRAY},
    {"preinit_array", 13, SHT_PREINIT_ARRAY},
  };

  for (size_t i = 0; i < sizeof(section_types) / sizeof(section_types[0]); ++i) {
    if (len == section_types[i].length && startswith(str, section_types[i].name)) {
      return section_types[i].type;
    }
  }

#ifdef md_elf_section_type
  int md_type = md_elf_section_type(str, len);
  if (md_type >= 0) return md_type;
#endif

  if (isdigit(*str)) {
    char *end;
    int type = strtoul(str, &end, 0);

    if (warn && (size_t)(end - str) != len) {
      as_warn(_("extraneous characters at end of numeric section type"));
    }

    return type;
  }

  if (warn) {
    as_warn(_("unrecognized section type"));
  }
  return 0;
}

#ifdef TC_SPARC
static bfd_vma
obj_elf_section_word (char *str, size_t len, int *type)
{
  int ret;

  if (len == 5 && startswith (str, "write"))
    return SHF_WRITE;
  if (len == 5 && startswith (str, "alloc"))
    return SHF_ALLOC;
  if (len == 9 && startswith (str, "execinstr"))
    return SHF_EXECINSTR;
  if (len == 7 && startswith (str, "exclude"))
    return SHF_EXCLUDE;
  if (len == 3 && startswith (str, "tls"))
    return SHF_TLS;

  ret = obj_elf_section_type (str, len, false);
  if (ret != 0)
    *type = ret;
  else
    as_warn (_("unrecognized section attribute"));

  return 0;
}
#endif

/* Get name of section.  */
#include <stddef.h>
#include <string.h>
#include <stdlib.h>

const char *obj_elf_section_name(void) {
    char *name = NULL;

    SKIP_WHITESPACE();
    if (*input_line_pointer == '"') {
        int dummy;
        name = demand_copy_C_string(&dummy);
        if (!name) {
            ignore_rest_of_line();
            return NULL;
        }
    } else {
        char *end = input_line_pointer;
        while (!is_whitespace(*end) && !is_end_of_stmt(*end) && *end != ',') {
            end++;
        }
        if (end == input_line_pointer) {
            as_bad(_("missing name"));
            ignore_rest_of_line();
            return NULL;
        }

        obstack_grow0(&notes, input_line_pointer, end - input_line_pointer);
        name = obstack_base(&notes);

        while (flag_sectname_subst) {
            char *subst = strchr(name, '%');
            if (!subst || subst[1] != 'S') break;

            size_t head = subst - name;
            size_t tail = strlen(subst + 2) + 1;
            size_t slen = strlen(now_seg->name);

            if (slen > 2) {
                obstack_blank(&notes, slen - 2);
                name = obstack_base(&notes);
            }
            memmove(name + head + slen, name + head + 2, tail);
            memcpy(name + head, now_seg->name, slen);
        }
        obstack_finish(&notes);

#ifdef tc_canonicalize_section_name
        name = tc_canonicalize_section_name(name);
#endif
        input_line_pointer = end;
    }
    SKIP_WHITESPACE();
    return name;
}

/* Arrange to put SEC, known to be in group GNAME into the per-group
   section lists kept by gas.  */

void elf_set_group_name(asection *sec, const char *gname) {
    if (sec == NULL || gname == NULL) return;

    elf_group_name(sec) = gname;
    elf_section_flags(sec) |= SHF_GROUP;

    struct elf_section_match match = {0};
    match.group_name = gname;
    match.linked_to_symbol_name = sec->map_head.linked_to_symbol_name;
    match.section_id = sec->section_id;

    struct elf_section_data *sec_data = elf_section_data(sec);
    if (sec_data == NULL) return;

    match.sh_info = sec_data->this_hdr.sh_info;
    match.sh_flags = sec_data->this_hdr.sh_flags & SEC_ASSEMBLER_SHF_MASK;
    match.flags = bfd_section_flags(sec) & SEC_ASSEMBLER_SECTION_ID;

    unsigned int group_idx = 0;
    if (!group_section_find(&match, sec->name, &group_idx)) {
        group_section_insert(&match, sec, &group_idx);
    }
}

static void
obj_elf_attach_to_group(int dummy ATTRIBUTE_UNUSED)
{
  const char *gname = obj_elf_section_name();

  if (!gname) {
    as_warn(_("group name not parseable"));
    return;
  }

  const char *current_group_name = elf_group_name(now_seg);
  
  if (current_group_name) {
    if (strcmp(current_group_name, gname) != 0) {
      as_warn(_("section %s already has a group (%s)"),
              bfd_section_name(now_seg), current_group_name);
    }
  } else {
    elf_set_group_name(now_seg, gname);
  }
}

/* Handle section related directives.

   Note on support for SFrame sections: These are generally expected to be
   generated by the assembler.  However, this function permits their direct
   creation by the user.  At the moment though, we go no extra mile by adding
   an explicit @sframe for SHT_GNU_SFRAME (using the numeric value of section
   type should suffice); Nor do we implement any outright refusal for
   non-supported targets via ELFOSABI-specific checks.  */

#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include "bfd.h"

void obj_elf_section(int push) {
    const char *name;
    char *beg;
    int type = SHT_NULL;
    bfd_vma attr = 0;
    bfd_vma gnu_attr = 0;
    int entsize = 0;
    bool has_entsize = false, linkonce = false;
    subsegT new_subsection = 0;
    struct elf_section_match match;
    unsigned long linked_to_section_index = -1UL;

    if (flag_mri) {
        char mri_type;
        #ifdef md_flush_pending_output
        md_flush_pending_output();
        #endif
        obj_elf_section_change_hook();
        s_mri_sect(&mri_type);
        #ifdef md_elf_section_change_hook
        md_elf_section_change_hook();
        #endif
        return;
    }

    name = obj_elf_section_name();
    if (name == NULL) return;

    memset(&match, 0, sizeof(match));

    symbolS *sym = symbol_find(name);
    if (sym && !symbol_section_p(sym) && S_IS_DEFINED(sym) && !S_IS_VOLATILE(sym) && !S_CAN_BE_REDEFINED(sym)) {
        as_bad(_("section name '%s' already defined as another symbol"), name);
        ignore_rest_of_line();
        return;
    }

    if (*input_line_pointer == ',') {
        ++input_line_pointer;
        SKIP_WHITESPACE();

        if (push && ISDIGIT(*input_line_pointer)) {
            new_subsection = get_absolute_expression();
            SKIP_WHITESPACE();
            if (*input_line_pointer != ',') goto done;
            ++input_line_pointer;
            SKIP_WHITESPACE();
        }

        if (*input_line_pointer == '"') {
            bool is_clone;
            int inherit;
            beg = demand_copy_C_string(NULL);
            if (beg == NULL) {
                ignore_rest_of_line();
                return;
            }

            const struct elf_backend_data *bed = get_elf_backend_data(stdoutput);
            attr = obj_elf_parse_section_letters(beg, strlen(beg), push, &is_clone, &inherit,
                         bed->elf_osabi == ELFOSABI_NONE || (bed->elf_osabi == ELFOSABI_GNU) || (bed->elf_osabi == ELFOSABI_FREEBSD) ? &gnu_attr : NULL, &has_entsize);

            if (inherit > 0) attr |= elf_section_flags(now_seg);
            else if (inherit < 0) attr = elf_section_flags(now_seg) & ~attr;
            if (inherit) type = elf_section_type(now_seg);

            if ((attr & (SHF_MERGE | SHF_STRINGS)) != 0) has_entsize = true;

            SKIP_WHITESPACE();
            if (*input_line_pointer == ',') {
                char *save = input_line_pointer;
                ++input_line_pointer;
                SKIP_WHITESPACE();
                if (*input_line_pointer == '"') {
                    beg = demand_copy_C_string(NULL);
                    if (beg == NULL) {
                        ignore_rest_of_line();
                        return;
                    }
                    type = obj_elf_section_type(beg, strlen(beg), true);
                } else if (*input_line_pointer == '@' || *input_line_pointer == '%') {
                    ++input_line_pointer;
                    if (ISDIGIT(*input_line_pointer)) {
                        type = strtoul(input_line_pointer, &input_line_pointer, 0);
                    } else {
                        int c = get_symbol_name(&beg);
                        (void)restore_line_pointer(c);
                        type = obj_elf_section_type(beg, input_line_pointer - beg, true);
                    }
                } else input_line_pointer = save;
            }

            SKIP_WHITESPACE();
            if (has_entsize && *input_line_pointer == ',') {
                ++input_line_pointer;
                SKIP_WHITESPACE();
                if (inherit && *input_line_pointer == ',' && ((bfd_section_flags(now_seg) & (SEC_MERGE | SEC_STRINGS)) != 0 || now_seg->entsize)) goto fetch_entsize;
                if (is_end_of_stmt(*input_line_pointer) && (bfd_section_flags(now_seg) & (SEC_MERGE | SEC_STRINGS)) != 0) {
                    as_tsktsk(_("missing section entity size, 1 assumed"));
                    entsize = 1;
                } else {
                    entsize = get_absolute_expression();
                    SKIP_WHITESPACE();
                    if (entsize <= 0) {
                        as_warn(_("invalid section entity size"));
                        attr &= ~(SHF_MERGE | SHF_STRINGS);
                        has_entsize = false;
                        entsize = 0;
                    }
                }
            } else if (has_entsize && inherit && ((bfd_section_flags(now_seg) & (SEC_MERGE | SEC_STRINGS)) != 0 || now_seg->entsize)) {
                fetch_entsize:
                entsize = now_seg->entsize;
            } else if ((attr & SHF_MERGE) != 0) {
                as_warn(_("entity size for SHF_MERGE not specified"));
                attr &= ~(SHF_MERGE | SHF_STRINGS);
                has_entsize = false;
            } else if ((attr & SHF_STRINGS) != 0) {
                entsize = 1;
            } else if (has_entsize) {
                as_warn(_("entity size not specified"));
                has_entsize = false;
            }

            if ((attr & (SHF_MERGE | SHF_STRINGS)) != 0 && type == SHT_NOBITS) as_warn(_("bogus SHF_MERGE / SHF_STRINGS for SHT_NOBITS section"));

            if ((attr & SHF_LINK_ORDER) != 0 && *input_line_pointer == ',') {
                ++input_line_pointer;
                SKIP_WHITESPACE();
                if (ISDIGIT(*input_line_pointer)) {
                    linked_to_section_index = strtoul(input_line_pointer, &input_line_pointer, 0);
                } else if (inherit && *input_line_pointer == ',' && (elf_section_flags(now_seg) & SHF_LINK_ORDER) != 0) goto fetch_linked_to;
                else {
                    int c;
                    unsigned int length;
                    c = get_symbol_name(&beg);
                    (void)restore_line_pointer(c);
                    length = input_line_pointer - beg;
                    if (length) match.linked_to_symbol_name = notes_memdup(beg, length, length + 1);
                }
            } else if ((attr & SHF_LINK_ORDER) != 0 && inherit && (elf_section_flags(now_seg) & SHF_LINK_ORDER) != 0) {
                fetch_linked_to:
                if (now_seg->map_head.linked_to_symbol_name) match.linked_to_symbol_name = now_seg->map_head.linked_to_symbol_name;
                else linked_to_section_index = elf_section_data(now_seg)->this_hdr.sh_link;
            }

            if ((attr & SHF_GROUP) != 0 && is_clone) {
                as_warn(_("? section flag ignored with G present"));
                is_clone = false;
            }

            if ((attr & SHF_GROUP) != 0 && *input_line_pointer == ',') {
                ++input_line_pointer;
                SKIP_WHITESPACE();
                if (inherit && *input_line_pointer == ',' && (elf_section_flags(now_seg) & SHF_GROUP) != 0) goto fetch_group;
                match.group_name = obj_elf_section_name();
                if (match.group_name == NULL) attr &= ~SHF_GROUP;
                else if (*input_line_pointer == ',') {
                    ++input_line_pointer;
                    SKIP_WHITESPACE();
                    if (startswith(input_line_pointer, "comdat")) {
                        input_line_pointer += 6;
                        linkonce = 1;
                    }
                } else if (startswith(name, ".gnu.linkonce")) linkonce = 1;
            } else if ((attr & SHF_GROUP) != 0 && inherit && (elf_section_flags(now_seg) & SHF_GROUP) != 0) {
                fetch_group:
                match.group_name = elf_group_name(now_seg);
                linkonce = (bfd_section_flags(now_seg) & SEC_LINK_ONCE) != 0;
            } else if ((attr & SHF_GROUP) != 0) {
                as_warn(_("group name for SHF_GROUP not specified"));
                attr &= ~SHF_GROUP;
            }

            if (is_clone) {
                const char *now_group = elf_group_name(now_seg);
                if (now_group != NULL) {
                    match.group_name = now_group;
                    linkonce = (now_seg->flags & SEC_LINK_ONCE) != 0;
                }
            }

            if ((gnu_attr & SHF_GNU_MBIND) != 0 && *input_line_pointer == ',') {
                char *save = input_line_pointer;
                ++input_line_pointer;
                SKIP_WHITESPACE();
                if (ISDIGIT(*input_line_pointer)) {
                    char *t = input_line_pointer;
                    match.sh_info = strtoul(input_line_pointer, &input_line_pointer, 0);
                    if (match.sh_info == -1u) {
                        as_warn(_("unsupported mbind section info: %s"), t);
                        match.sh_info = 0;
                    }
                } else input_line_pointer = save;
            }

            if ((gnu_attr & SHF_GNU_RETAIN) != 0) match.sh_flags |= SHF_GNU_RETAIN;

            if (*input_line_pointer == ',') {
                char *save = input_line_pointer;
                ++input_line_pointer;
                SKIP_WHITESPACE();
                if (startswith(input_line_pointer, "unique")) {
                    input_line_pointer += 6;
                    SKIP_WHITESPACE();
                    if (*input_line_pointer == ',') {
                        ++input_line_pointer;
                        SKIP_WHITESPACE();
                        if (ISDIGIT(*input_line_pointer)) {
                            bfd_vma id;
                            bool overflow;
                            char *t = input_line_pointer;
                            if (sizeof(bfd_vma) <= sizeof(unsigned long)) {
                                errno = 0;
                                id = strtoul(input_line_pointer, &input_line_pointer, 0);
                                overflow = id == -1ul && errno == ERANGE;
                            } else {
                                id = bfd_scan_vma(input_line_pointer, (const char **)&input_line_pointer, 0);
                                overflow = id == ~(bfd_vma)0;
                            }
                            if (overflow || id > -1u) {
                                char *linefeed, saved_char = 0;
                                if ((linefeed = strchr(t, '\n')) != NULL) {
                                    saved_char = *linefeed;
                                    *linefeed = '\0';
                                }
                                as_bad(_("unsupported section id: %s"), t);
                                if (saved_char) *linefeed = saved_char;
                            } else {
                                match.section_id = id;
                                match.flags |= SEC_ASSEMBLER_SECTION_ID;
                            }
                        }
                    }
                } else input_line_pointer = save;
            }
        }
    }

done:
    demand_empty_rest_of_line();

    if ((gnu_attr & (SHF_GNU_MBIND | SHF_GNU_RETAIN)) != 0) {
        bool mbind_p = (gnu_attr & SHF_GNU_MBIND) != 0;

        if (mbind_p && (attr & SHF_ALLOC) == 0)
            as_bad(_("SHF_ALLOC isn't set for GNU_MBIND section: %s"), name);

        if (mbind_p) elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_mbind;
        if ((gnu_attr & SHF_GNU_RETAIN) != 0)
            elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_retain;

        attr |= gnu_attr;
    }

    change_section(name, type, attr, entsize, &match, linkonce, push, new_subsection);

    if (linked_to_section_index != -1UL) {
        elf_section_flags(now_seg) |= SHF_LINK_ORDER;
        elf_section_data(now_seg)->this_hdr.sh_link = linked_to_section_index;
    }
}

/* Change to the .bss section.  */

void obj_elf_bss(int i ATTRIBUTE_UNUSED) {
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();

    int temp = get_absolute_expression();
    subseg_set(bss_section, temp);
    demand_empty_rest_of_line();

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

/* Change to the .data section.  */

void obj_elf_data(int i) {
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();
    s_data(i);

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

/* Change to the .text section.  */

void obj_elf_text(int i) {
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();
    s_text(i);

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

/* Change to the *ABS* section.  */

#include <stdbool.h>

void flush_output_if_needed() {
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif
}

void section_change_hook() {
    obj_elf_section_change_hook();
#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

void obj_elf_struct(int i) {
    if (i < 0) return; // Error handling: Ensure valid input
    flush_output_if_needed();
    section_change_hook();
    s_struct(i);
}

static void obj_elf_subsection(int ignore ATTRIBUTE_UNUSED) {
    #ifdef md_flush_pending_output
    md_flush_pending_output();
    #endif

    obj_elf_section_change_hook();

    int temp = get_absolute_expression();
    subseg_set(now_seg, temp);
    demand_empty_rest_of_line();

    #ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
    #endif
}

/* This can be called from the processor backends if they change
   sections.  */

void obj_elf_section_change_hook(void) {
  previous_section = now_seg;
  previous_subsection = now_subseg;
}

void obj_elf_previous(int ignore ATTRIBUTE_UNUSED) {
    if (previous_section == 0) {
        as_warn(_(".previous without corresponding .section; ignored"));
        return;
    }

#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();
    subseg_set(previous_section, previous_subsection);

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

static void obj_elf_popsection(int xxx ATTRIBUTE_UNUSED) {
    if (section_stack == NULL) {
        as_warn(_(".popsection without corresponding .pushsection; ignored"));
        return;
    }

#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    struct section_stack *top = section_stack;
    section_stack = top->next;
    previous_section = top->prev_seg;
    previous_subsection = top->prev_subseg;
    subseg_set(top->seg, top->subseg);
    free(top);

#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

static void obj_elf_line(int ignore ATTRIBUTE_UNUSED) {
    if (!new_logical_line(NULL, get_absolute_expression())) {
        // Handle error if new_logical_line fails
        return;
    }
    if (!demand_empty_rest_of_line()) {
        // Handle error if rest of the line is not empty
        return;
    }
}

static struct elf_versioned_name_list *
obj_elf_find_and_add_versioned_name(const char *version_name,
                                    const char *sym_name,
                                    const char *ver,
                                    struct elf_obj_sy *sy_obj)
{
    struct elf_versioned_name_list *versioned_name = sy_obj->versioned_name;
    const char *p = ver + 1;

    while (*p == ELF_VER_CHR) {
        p++;
    }

    if (*p == '\0') {
        as_bad(_("missing version name in `%s' for symbol `%s'"),
               version_name, sym_name);
        return NULL;
    }

    if (p - ver == 3) {
        if (sy_obj->rename) {
            if (versioned_name && strcmp(versioned_name->name, version_name) == 0) {
                return versioned_name;
            }
            as_bad(_("only one version name with `@@@` is allowed for symbol `%s'"), sym_name);
            return NULL;
        }
        sy_obj->rename = true;
    } else if (p - ver != 1 && p - ver != 2) {
        as_bad(_("invalid version name '%s' for symbol `%s'"),
               version_name, sym_name);
        return NULL;
    }

    while (versioned_name) {
        if (strcmp(versioned_name->name, version_name) == 0) {
            return versioned_name;
        }
        versioned_name = versioned_name->next;
    }

    versioned_name = notes_alloc(sizeof(*versioned_name));
    if (!versioned_name) {
        // Handle allocation error appropriately
        return NULL;
    }
    versioned_name->name = notes_strdup(version_name);
    if (!versioned_name->name) {
        // Handle allocation error appropriately
        return NULL;
    }
    versioned_name->next = sy_obj->versioned_name;
    sy_obj->versioned_name = versioned_name;

    return versioned_name;
}

/* This handles the .symver pseudo-op, which is used to specify a
   symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.
   SYMVERNAME may contain ELF_VER_CHR ('@') characters.  This
   pseudo-op causes the assembler to emit a symbol named SYMVERNAME
   with the same value as the symbol NAME.  */

static void obj_elf_symver(int ignore ATTRIBUTE_UNUSED) {
    char *name;
    const char *sym_name;
    symbolS *sym;
    struct elf_obj_sy *sy_obj;
    char *p;

    sym = get_sym_from_input_line_and_check();

    if (*input_line_pointer++ != ',') {
        as_bad(_("expected comma after name in .symver"));
        ignore_rest_of_line();
        return;
    }

    SKIP_WHITESPACE();

    char old_lexat = lex_type[(unsigned char) '@'];
    lex_type[(unsigned char) '@'] |= LEX_NAME;

    char c = get_symbol_name(&name);
    lex_type[(unsigned char) '@'] = old_lexat;

    sym_name = S_GET_NAME(sym);

    if (S_IS_COMMON(sym)) {
        as_bad(_("`%s' can't be versioned to common symbol '%s'"), name, sym_name);
        ignore_rest_of_line();
        return;
    }

    p = strchr(name, ELF_VER_CHR);
    if (!p) {
        as_bad(_("missing version name in `%s' for symbol `%s'"), name, sym_name);
        ignore_rest_of_line();
        return;
    }

    sy_obj = symbol_get_obj(sym);
    if (!obj_elf_find_and_add_versioned_name(name, sym_name, p, sy_obj)) {
        sy_obj->bad_version = true;
        ignore_rest_of_line();
        return;
    }

    restore_line_pointer(c);

    if (*input_line_pointer == ',') {
        char *save = input_line_pointer++;
        SKIP_WHITESPACE();
        
        if (startswith(input_line_pointer, "local")) {
            input_line_pointer += 5;
            sy_obj->visibility = visibility_local;
        } else if (startswith(input_line_pointer, "hidden")) {
            input_line_pointer += 6;
            sy_obj->visibility = visibility_hidden;
        } else if (startswith(input_line_pointer, "remove")) {
            input_line_pointer += 6;
            sy_obj->visibility = visibility_remove;
        } else {
            input_line_pointer = save;
        }
    }

    demand_empty_rest_of_line();
}

/* This handles the .vtable_inherit pseudo-op, which is used to indicate
   to the linker the hierarchy in which a particular table resides.  The
   syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */

struct fix *obj_elf_get_vtable_inherit(void) {
    char *cname = NULL, *pname = NULL;
    symbolS *csym, *psym;
    char c;
    int has_error = 0;

    if (*input_line_pointer == '#') {
        ++input_line_pointer;
    }

    c = get_symbol_name(&cname);
    csym = symbol_find(cname);

    if (csym == NULL || symbol_get_frag(csym) == NULL) {
        as_bad(_("expected `%s' to have already been set for .vtable_inherit"), cname);
        has_error = 1;
    }

    restore_line_pointer(c);
    SKIP_WHITESPACE();

    if (*input_line_pointer != ',') {
        as_bad(_("expected comma after name in .vtable_inherit"));
        ignore_rest_of_line();
        return NULL;
    }

    ++input_line_pointer;
    SKIP_WHITESPACE();

    if (*input_line_pointer == '#') {
        ++input_line_pointer;
    }

    if (*input_line_pointer == '0' && (is_end_of_stmt(input_line_pointer[1]) || is_whitespace(input_line_pointer[1]))) {
        psym = section_symbol(absolute_section);
        ++input_line_pointer;
    } else {
        c = get_symbol_name(&pname);
        psym = symbol_find_or_make(pname);
        restore_line_pointer(c);
    }

    demand_empty_rest_of_line();

    if (has_error) {
        return NULL;
    }

    gas_assert(symbol_get_value_expression(csym)->X_op == O_constant);
    return fix_new(symbol_get_frag(csym), symbol_get_value_expression(csym)->X_add_number, 0, psym, 0, 0, BFD_RELOC_VTABLE_INHERIT);
}

/* This is a version of obj_elf_get_vtable_inherit() that is
   suitable for use in struct _pseudo_type tables.  */

void obj_elf_vtable_inherit(int ignore ATTRIBUTE_UNUSED) {
  obj_elf_get_vtable_inherit();
}

/* This handles the .vtable_entry pseudo-op, which is used to indicate
   to the linker that a vtable slot was used.  The syntax is
   ".vtable_entry tablename, offset".  */

struct fix *obj_elf_get_vtable_entry(void) {
    symbolS *sym;
    offsetT offset;

    if (*input_line_pointer == '#') {
        ++input_line_pointer;
    }

    sym = get_sym_from_input_line_and_check();
    if (!sym || *input_line_pointer != ',') {
        as_bad(_("expected comma after name in .vtable_entry"));
        ignore_rest_of_line();
        return NULL;
    }

    ++input_line_pointer;
    if (*input_line_pointer == '#') {
        ++input_line_pointer;
    }

    offset = get_absolute_expression();
    if (!demand_empty_rest_of_line()) {
        return NULL;
    }

    return fix_new(frag_now, frag_now_fix(), 0, sym, offset, 0, BFD_RELOC_VTABLE_ENTRY);
}

/* This is a version of obj_elf_get_vtable_entry() that is
   suitable for use in struct _pseudo_type tables.  */

void obj_elf_vtable_entry(int ignore)
{
    if (obj_elf_get_vtable_entry() == NULL)
    {
        // Handle potential error here
    }
}

#define skip_whitespace(str)  do { if (is_whitespace (*(str))) ++(str); } while (0)

static inline int skip_past_char(char **str, char c) {
    if (str && *str && **str == c) {
        (*str)++;
        return 0;
    }
    return -1;
}
#define skip_past_comma(str) skip_past_char (str, ',')

/* A list of attributes that have been explicitly set by the assembly code.
   VENDOR is the vendor id, BASE is the tag shifted right by the number
   of bits in MASK, and bit N of MASK is set if tag BASE+N has been set.  */
struct recorded_attribute_info {
  struct recorded_attribute_info *next;
  int vendor;
  unsigned int base;
  unsigned long mask;
};
static struct recorded_attribute_info *recorded_attributes;

/* Record that we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

#include <stdlib.h>

static void record_attribute(int vendor, unsigned int tag) {
    unsigned int base = tag / (8 * sizeof(unsigned long));
    unsigned long mask = 1UL << (tag % (8 * sizeof(unsigned long)));
    struct recorded_attribute_info *rai;

    for (rai = recorded_attributes; rai; rai = rai->next) {
        if (rai->vendor == vendor && rai->base == base) {
            rai->mask |= mask;
            return;
        }
    }

    rai = (struct recorded_attribute_info *)malloc(sizeof(struct recorded_attribute_info));
    if (rai == NULL) {
        // Handle allocation failure
        return;
    }
    rai->next = recorded_attributes;
    rai->vendor = vendor;
    rai->base = base;
    rai->mask = mask;
    recorded_attributes = rai;
}

/* Return true if we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

#include <stdbool.h>
#include <stddef.h>

struct recorded_attribute_info {
  int vendor;
  unsigned int base;
  unsigned long mask;
  struct recorded_attribute_info *next;
};

extern struct recorded_attribute_info *recorded_attributes;

bool obj_elf_seen_attribute(int vendor, unsigned int tag) {
  unsigned int base = tag / (8 * sizeof(unsigned long));
  unsigned long mask = 1UL << (tag % (8 * sizeof(unsigned long)));
  
  for (struct recorded_attribute_info *rai = recorded_attributes; rai != NULL; rai = rai->next) {
    if (rai->vendor == vendor && rai->base == base && (rai->mask & mask) != 0) {
      return true;
    }
  }
  
  return false;
}

/* Parse an attribute directive for VENDOR.
   Returns the attribute number read, or zero on error.  */

int obj_elf_vendor_attribute(int vendor) {
    expressionS exp;
    int type, tag;
    char *s = NULL;
    unsigned int numeric_value = 0;

    skip_whitespace(input_line_pointer);
    s = input_line_pointer;

    if (ISDIGIT(*input_line_pointer)) {
        expression(&exp);
        if (exp.X_op != O_constant) {
            as_bad(_("expected <tag> , <value>"));
            ignore_rest_of_line();
            return 0;
        }
        tag = exp.X_add_number;
    } else {
        char *name;
        size_t i = 0;

        while (ISALNUM(*input_line_pointer) || *input_line_pointer == '_') {
            ++input_line_pointer;
            ++i;
        }
        
        if (i == 0) {
            as_bad(_("expected <tag> , <value>"));
            ignore_rest_of_line();
            return 0;
        }

        name = xmemdup0(s, i);

        #ifndef CONVERT_SYMBOLIC_ATTRIBUTE
        #define CONVERT_SYMBOLIC_ATTRIBUTE(a) -1
        #endif

        tag = CONVERT_SYMBOLIC_ATTRIBUTE(name);
        free(name);

        if (tag == -1) {
            as_bad(_("Attribute name not recognised: %s"), name);
            ignore_rest_of_line();
            return 0;
        }
    }

    type = _bfd_elf_obj_attrs_arg_type(stdoutput, vendor, tag);
    
    if (skip_past_comma(&input_line_pointer) == -1) {
        as_bad(_("expected <tag> , <value>"));
        ignore_rest_of_line();
        return 0;
    }

    if (type & 1) {
        expression(&exp);
        if (exp.X_op != O_constant) {
            as_bad(_("expected numeric constant"));
            ignore_rest_of_line();
            return 0;
        }
        numeric_value = exp.X_add_number;
    }

    if ((type & 3) == 3 && skip_past_comma(&input_line_pointer) == -1) {
        as_bad(_("expected comma"));
        ignore_rest_of_line();
        return 0;
    }

    if (type & 2) {
        int len;
        skip_whitespace(input_line_pointer);
        if (*input_line_pointer != '"') {
            as_bad(_("bad string constant"));
            ignore_rest_of_line();
            return 0;
        }
        s = demand_copy_C_string(&len);
    }

    record_attribute(vendor, tag);
    bool ok = false;

    switch (type & 3) {
        case 3:
            ok = bfd_elf_add_obj_attr_int_string(stdoutput, vendor, tag, numeric_value, s);
            break;
        case 2:
            ok = bfd_elf_add_obj_attr_string(stdoutput, vendor, tag, s);
            break;
        case 1:
            ok = bfd_elf_add_obj_attr_int(stdoutput, vendor, tag, numeric_value);
            break;
        default:
            abort();
    }

    if (!ok) {
        as_fatal(_("error adding attribute: %s"), bfd_errmsg(bfd_get_error()));
    }

    demand_empty_rest_of_line();
    return tag;
}

/* Parse a .gnu_attribute directive.  */

static void obj_elf_gnu_attribute(void) {
    obj_elf_vendor_attribute(OBJ_ATTR_GNU);
}

#ifdef NEED_ECOFF_DEBUG
void ecoff_read_begin_hook(void);
#endif

void elf_obj_read_begin_hook(void) {
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING) {
    ecoff_read_begin_hook();
  }
#endif
}

void elf_obj_symbol_new_hook(symbolS *symbolP) {
  if (!symbolP) return;

  struct elf_obj_sy *sy_obj = symbol_get_obj(symbolP);
  if (!sy_obj) return;

  sy_obj->size = NULL;
  sy_obj->versioned_name = NULL;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING) {
    ecoff_symbol_new_hook(symbolP);
  }
#endif
}

/* If size is unset, copy size from src.  Because we don't track whether
   .size has been used, we can't differentiate .size dest, 0 from the case
   where dest's size is unset.  */
void elf_copy_symbol_size(symbolS *dest, symbolS *src) {
    struct elf_obj_sy *srcelf = symbol_get_obj(src);
    struct elf_obj_sy *destelf = symbol_get_obj(dest);
    if (destelf->size || S_GET_SIZE(dest) != 0) {
        return;
    }
    destelf->size = srcelf->size;
    S_SET_SIZE(dest, S_GET_SIZE(src));
}

void elf_copy_symbol_attributes(symbolS *dest, symbolS *src) {
    elf_copy_symbol_size(dest, src);
    unsigned char dest_visibility = ELF_ST_VISIBILITY(S_GET_OTHER(dest));
    unsigned char src_other = S_GET_OTHER(src) & ~ELF_ST_VISIBILITY(-1);
    S_SET_OTHER(dest, dest_visibility | src_other);
}

void obj_elf_version(int ignore ATTRIBUTE_UNUSED) {
    char *name;
    char *p;
    unsigned int len;
    asection *note_secp = NULL;
    asection *seg = now_seg;
    subsegT subseg = now_subseg;
    Elf_Internal_Note i_note;
    Elf_External_Note e_note;

    SKIP_WHITESPACE();

    if (*input_line_pointer != '\"') {
        as_bad(_("expected quoted string"));
        demand_empty_rest_of_line();
        return;
    }

    ++input_line_pointer;  // Move past the opening quote
    name = input_line_pointer;

    while (*input_line_pointer && *input_line_pointer != '\"') {
        input_line_pointer++;
    }
    if (*input_line_pointer != '\"') {
        as_bad(_("unterminated string"));
        demand_empty_rest_of_line();
        return;
    }

    *input_line_pointer = '\0';  // Terminate the string
    len = strlen(name) + 1;

    note_secp = subseg_new(".note", 0);
    if (!note_secp) {
        as_bad(_("failed to create a note section"));
        demand_empty_rest_of_line();
        return;
    }
    bfd_set_section_flags(note_secp, SEC_HAS_CONTENTS | SEC_READONLY);
    record_alignment(note_secp, 2);

    i_note.namesz = len;
    i_note.descsz = 0;  // No description
    i_note.type = NT_VERSION;

    p = frag_more(sizeof(e_note.namesz));
    md_number_to_chars(p, i_note.namesz, sizeof(e_note.namesz));
    p = frag_more(sizeof(e_note.descsz));
    md_number_to_chars(p, i_note.descsz, sizeof(e_note.descsz));
    p = frag_more(sizeof(e_note.type));
    md_number_to_chars(p, i_note.type, sizeof(e_note.type));
    p = frag_more(len);
    memcpy(p, name, len);

    frag_align(2, 0, 0);

    subseg_set(seg, subseg);
    demand_empty_rest_of_line();
}

#include <stddef.h> 

static void obj_elf_size(int ignore ATTRIBUTE_UNUSED) {
    char *name;
    char c = get_symbol_name(&name);
    char *p = input_line_pointer;
    expressionS exp;
    symbolS *sym;

    restore_line_pointer(c);
    SKIP_WHITESPACE();

    if (*input_line_pointer != ',') {
        *p = 0;
        as_bad(_("expected comma after name `%s' in .size directive"), name);
        *p = c;
        ignore_rest_of_line();
        return;
    }
    
    input_line_pointer++;
    expression(&exp);

    if (exp.X_op == O_absent) {
        as_bad(_("missing expression in .size directive"));
        exp.X_op = O_constant;
        exp.X_add_number = 0;
    }

    *p = 0;
    sym = symbol_find_or_make(name);
    *p = c;

    if (exp.X_op == O_constant) {
        S_SET_SIZE(sym, exp.X_add_number);
        symbol_get_obj(sym)->size = NULL;
    } else {
        size_t exp_size = sizeof(exp);
        symbol_get_obj(sym)->size = notes_alloc(exp_size);
        if (symbol_get_obj(sym)->size != NULL) {
            *symbol_get_obj(sym)->size = exp;
        } else {
            as_bad(_("memory allocation failed for expression"));
            return;
        }
    }

    if (flag_synth_cfi && S_IS_FUNCTION(sym) && sym == ginsn_data_func_symbol()) {
        ginsn_data_end(symbol_temp_new_now());
    }

    demand_empty_rest_of_line();
}

/* Handle the ELF .type pseudo-op.  This sets the type of a symbol.
   There are six syntaxes:

   The first (used on Solaris) is
       .type SYM,#function
   The second (used on UnixWare) is
       .type SYM,@function
   The third (reportedly to be used on Irix 6.0) is
       .type SYM STT_FUNC
   The fourth (used on NetBSD/Arm and Linux/ARM) is
       .type SYM,%function
   The fifth (used on SVR4/860) is
       .type SYM,"function"
   The sixth (emitted by recent SunPRO under Solaris) is
       .type SYM,[0-9]
   where the integer is the STT_* value.
   */

static char *obj_elf_type_name(char *cp) {
    char *p = input_line_pointer;

    if (*input_line_pointer >= '0' && *input_line_pointer <= '9') {
        while (*input_line_pointer >= '0' && *input_line_pointer <= '9') {
            ++input_line_pointer;
        }
        *cp = *input_line_pointer;
        *input_line_pointer = '\0';
    } else {
        *cp = get_symbol_name(&p);
    }

    return p;
}

static void obj_elf_type(int ignore ATTRIBUTE_UNUSED) {
    char c;
    int type = 0;
    const char *type_name;
    symbolS *sym = get_sym_from_input_line_and_check();
    elf_symbol_type *elfsym = (elf_symbol_type *) symbol_get_bfdsym(sym);

    c = *input_line_pointer;
    if (*input_line_pointer == ',') {
        ++input_line_pointer;
    }

    SKIP_WHITESPACE();
    if (strchr("#@\"%", *input_line_pointer)) {
        ++input_line_pointer;
    }

    type_name = obj_elf_type_name(&c);

    if (strcmp(type_name, "function") == 0 || strcmp(type_name, "2") == 0 || strcmp(type_name, "STT_FUNC") == 0) {
        type = BSF_FUNCTION;
    } else if (strcmp(type_name, "object") == 0 || strcmp(type_name, "1") == 0 || strcmp(type_name, "STT_OBJECT") == 0) {
        type = BSF_OBJECT;
    } else if (strcmp(type_name, "tls_object") == 0 || strcmp(type_name, "6") == 0 || strcmp(type_name, "STT_TLS") == 0) {
        type = BSF_OBJECT | BSF_THREAD_LOCAL;
    } else if (strcmp(type_name, "common") == 0 || strcmp(type_name, "5") == 0 || strcmp(type_name, "STT_COMMON") == 0) {
        type = BSF_OBJECT;
        if (!S_IS_COMMON(sym)) {
            if (S_IS_VOLATILE(sym)) {
                sym = symbol_clone(sym, 1);
                S_SET_SEGMENT(sym, bfd_com_section_ptr);
                S_SET_VALUE(sym, 0);
                S_SET_EXTERNAL(sym);
                symbol_set_frag(sym, &zero_address_frag);
                S_CLEAR_VOLATILE(sym);
            } else if (S_IS_DEFINED(sym) || symbol_equated_p(sym)) {
                as_bad(_("symbol '%s' is already defined"), S_GET_NAME(sym));
            } else {
                S_SET_SEGMENT(sym, bfd_com_section_ptr);
                S_SET_VALUE(sym, 0);
                S_SET_EXTERNAL(sym);
            }
        }
    } else if (strcmp(type_name, "gnu_indirect_function") == 0 || strcmp(type_name, "10") == 0 || strcmp(type_name, "STT_GNU_IFUNC") == 0) {
        const struct elf_backend_data *bed = get_elf_backend_data(stdoutput);
        if (bed->elf_osabi != ELFOSABI_NONE && bed->elf_osabi != ELFOSABI_GNU && bed->elf_osabi != ELFOSABI_FREEBSD) {
            as_bad(_("symbol type \"%s\" is supported only by GNU and FreeBSD targets"), type_name);
        } else if (bed->target_id == MIPS_ELF_DATA) {
            as_bad(_("symbol type \"%s\" is not supported by MIPS targets"), type_name);
        } else {
            elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
            type = BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION;
        }
    } else if (strcmp(type_name, "gnu_unique_object") == 0) {
        const struct elf_backend_data *bed = get_elf_backend_data(stdoutput);
        if (bed->elf_osabi != ELFOSABI_NONE && bed->elf_osabi != ELFOSABI_GNU) {
            as_bad(_("symbol type \"%s\" is supported only by GNU targets"), type_name);
        } else {
            elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_unique;
            type = BSF_OBJECT | BSF_GNU_UNIQUE;
        }
    }
#ifdef md_elf_symbol_type
    else if ((type = md_elf_symbol_type(type_name, sym, elfsym)) != -1) {
        // Type is set.
    }
#endif
    else {
        as_bad(_("unrecognized symbol type \"%s\""), type_name);
    }

    *input_line_pointer = c;
    if (*input_line_pointer == '"') {
        ++input_line_pointer;
    }

#ifdef md_elf_symbol_type_change
    if (!md_elf_symbol_type_change(sym, elfsym, type))
#endif
    {
        flagword mask = BSF_FUNCTION | BSF_OBJECT;
        if (type != BSF_FUNCTION) {
            mask |= BSF_GNU_INDIRECT_FUNCTION;
        }
        if (type != BSF_OBJECT) {
            mask |= BSF_GNU_UNIQUE | BSF_THREAD_LOCAL;
            if (S_IS_COMMON(sym)) {
                as_bad(_("cannot change type of common symbol '%s'"), S_GET_NAME(sym));
                mask = type = 0;
            }
        }

        if (type) {
            flagword new_flags = (elfsym->symbol.flags & ~mask) | type;
            if (new_flags != (elfsym->symbol.flags | type)) {
                as_warn(_("symbol '%s' already has its type set"), S_GET_NAME(sym));
            }
            elfsym->symbol.flags = new_flags;
        } else {
            elfsym->symbol.flags &= ~mask;
        }
    }

    if (S_IS_FUNCTION(sym) && flag_synth_cfi) {
        if (frchain_now->frch_ginsn_data) {
            ginsn_data_end(symbol_temp_new_now());
        }
        ginsn_data_begin(sym);
    }

    demand_empty_rest_of_line();
}

static segT comment_section;

static void obj_elf_ident(int ignore ATTRIBUTE_UNUSED) {
    segT old_section = now_seg;
    int old_subsection = now_subseg;

#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif

    if (!comment_section) {
        comment_section = subseg_new(".comment", 0);
        if (!comment_section) {
            // Handle error
            return;
        }
        bfd_set_section_flags(comment_section, SEC_READONLY | SEC_HAS_CONTENTS | SEC_MERGE | SEC_STRINGS);
        comment_section->entsize = 1;
#ifdef md_elf_section_change_hook
        md_elf_section_change_hook();
#endif
        char *p = frag_more(1);
        if (p) {
            *p = 0;
        } else {
            // Handle error
            return;
        }
    } else {
        subseg_set(comment_section, 0);
#ifdef md_elf_section_change_hook
        md_elf_section_change_hook();
#endif
    }

    stringer(9);

    subseg_set(old_section, old_subsection);
#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

#ifdef INIT_STAB_SECTION

/* The first entry in a .stabs section is special.  */

void
obj_elf_init_stab_section (segT stab, segT stabstr)
{
  char *file;
  char *p;
  unsigned int stroff;

  /* Force the section to align to a longword boundary.  Without this,
     UnixWare ar crashes.  */
  bfd_set_section_alignment (stab, 2);

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  file = remap_debug_filename (as_where (NULL));
  stroff = get_stab_string_offset (file, stabstr);
  know (stroff == 1 || (stroff == 0 && file[0] == '\0'));
  md_number_to_chars (p, stroff, 4);
  seg_info (stab)->stabu.p = p;
  free (file);
}

#endif

/* Called via bfd_map_over_sections.  If SEC's linked_to_symbol_name
   isn't NULL, set up its linked-to section.
   For .stabs section, fill in the counts in the first entry.  */

#include <stdbool.h>
#include <string.h>
#include <stdlib.h>

static bool is_valid_symbol(symbolS *sym) {
    return sym && S_IS_DEFINED(sym);
}

static void set_additional_section_info(bfd *abfd, asection *sec, void *inf ATTRIBUTE_UNUSED) {
    if (sec->map_head.linked_to_symbol_name) {
        symbolS *linked_to_sym = symbol_find(sec->map_head.linked_to_symbol_name);
        if (!is_valid_symbol(linked_to_sym)) {
            as_bad(_("undefined linked-to symbol `%s' on section `%s'"), 
                   sec->map_head.linked_to_symbol_name, 
                   bfd_section_name(sec));
        } else {
            elf_linked_to_section(sec) = S_GET_SEGMENT(linked_to_sym);
        }
    }

    if (!startswith(sec->name, ".stab") || 
        strcmp("str", sec->name + strlen(sec->name) - 3) == 0) {
        return;
    }

    char *name = concat(sec->name, "str", (const char *)NULL);
    if (!name) {
        return;
    }

    asection *strsec = bfd_get_section_by_name(abfd, name);
    free(name);

    int strsz = strsec ? bfd_section_size(strsec) : 0;
    int nsyms = bfd_section_size(sec) / 12 - 1;

    char *p = seg_info(sec)->stabu.p;
    gas_assert(p != NULL);

    bfd_h_put_16(abfd, nsyms, p + 6);
    bfd_h_put_32(abfd, strsz, p + 8);
}

#ifdef NEED_ECOFF_DEBUG

/* This function is called by the ECOFF code.  It is supposed to
   record the external symbol information so that the backend can
   write it out correctly.  The ELF backend doesn't actually handle
   this at the moment, so we do it ourselves.  We save the information
   in the symbol.  */

#ifdef OBJ_MAYBE_ELF
static
#endif
void
elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)
{
  symbol_get_bfdsym (sym)->udata.p = ext;
}

/* This function is called by bfd_ecoff_debug_externals.  It is
   supposed to *EXT to the external symbol information, and return
   whether the symbol should be used at all.  */

static bool
elf_get_extr (asymbol *sym, EXTR *ext)
{
  if (sym->udata.p == NULL)
    return false;
  *ext = *(EXTR *) sym->udata.p;
  return true;
}

/* This function is called by bfd_ecoff_debug_externals.  It has
   nothing to do for ELF.  */

static void
elf_set_index (asymbol *sym ATTRIBUTE_UNUSED,
	       bfd_size_type indx ATTRIBUTE_UNUSED)
{
}

#endif /* NEED_ECOFF_DEBUG */

void elf_frob_symbol(symbolS *symp, int *puntp) {
    struct elf_obj_sy *sy_obj = symbol_get_obj(symp);
    expressionS *size = sy_obj->size;
    
#ifdef NEED_ECOFF_DEBUG
    if (ECOFF_DEBUGGING) {
        ecoff_frob_symbol(symp);
    }
#endif

    if (size) {
        if (resolve_expression(size) && size->X_op == O_constant) {
            S_SET_SIZE(symp, size->X_add_number);
        } else {
            const char *msg_fmt = _(".size expression for %s does not evaluate to a constant");
            if (!flag_allow_nonconst_size) {
                as_bad(msg_fmt, S_GET_NAME(symp));
            } else {
                as_warn(msg_fmt, S_GET_NAME(symp));
            }
        }
        sy_obj->size = NULL;
    }

    struct elf_versioned_name_list *versioned_name = sy_obj->versioned_name;
    if (versioned_name) {
        if (sy_obj->bad_version) {
            *puntp = true;
        } else if (sy_obj->rename) {
            S_SET_NAME(symp, versioned_name->name);
        } else if (S_IS_COMMON(symp)) {
            as_bad(_("`%s' can't be versioned to common symbol '%s'"), versioned_name->name, S_GET_NAME(symp));
            *puntp = true;
        } else {
            alias_versions(symp, versioned_name);
            handle_visibility(symp, sy_obj);
        }
    }

    if (S_IS_WEAK(symp) && S_IS_COMMON(symp)) {
        as_bad(_("symbol `%s' can not be both weak and common"), S_GET_NAME(symp));
    }
}

void alias_versions(symbolS *symp, struct elf_versioned_name_list *versioned_name) {
    for (; versioned_name; versioned_name = versioned_name->next) {
        symbolS *symp2 = symbol_find_or_make(versioned_name->name);
        S_SET_SEGMENT(symp2, S_GET_SEGMENT(symp));
        S_SET_VALUE(symp2, S_GET_VALUE(symp) - (symbol_get_frag(symp)->fr_address / OCTETS_PER_BYTE));
        symbol_set_frag(symp2, symbol_get_frag(symp));
        copy_symbol_attributes(symp2, symp);
        S_SET_OTHER(symp2, S_GET_OTHER(symp));
        if (S_IS_WEAK(symp)) S_SET_WEAK(symp2);
        if (S_IS_EXTERNAL(symp)) S_SET_EXTERNAL(symp2);
    }
}

void handle_visibility(symbolS *symp, struct elf_obj_sy *sy_obj) {
    asymbol *bfdsym;
    elf_symbol_type *elfsym;

    switch (sy_obj->visibility) {
        case visibility_unchanged:
            break;
        case visibility_hidden:
            bfdsym = symbol_get_bfdsym(symp);
            elfsym = elf_symbol_from(bfdsym);
            elfsym->internal_elf_sym.st_other = (elfsym->internal_elf_sym.st_other & ~3) | STV_HIDDEN;
            break;
        case visibility_remove:
            if (symbol_used_in_reloc_p(symp)) {
                if (sy_obj->versioned_name->next) {
                    as_bad(_("symbol '%s' with multiple versions cannot be used in relocation"), S_GET_NAME(symp));
                }
                symbol_mark_removed(symp);
            } else {
                symbol_remove(symp, &symbol_rootP, &symbol_lastP);
            }
            break;
        case visibility_local:
            S_CLEAR_EXTERNAL(symp);
            break;
    }
}

/* Fix up SYMPP which has been marked to be removed by .symver.  */

void elf_fixup_removed_symbol(symbolS **sympp) {
    if (sympp == NULL || *sympp == NULL) return;
    
    symbolS *symp = *sympp;
    struct elf_obj_sy *sy_obj = symbol_get_obj(symp);
    
    if (sy_obj == NULL || sy_obj->versioned_name == NULL) return;
    
    symbolS *versioned_symp = symbol_find(sy_obj->versioned_name->name);
    if (versioned_symp != NULL) {
        *sympp = versioned_symp;
    }
}

/* Create symbols for group signature.  */

void elf_adjust_symtab(void) {
    unsigned int i;

    for (i = 0; i < groups.num_group; i++) {
        const char *group_name = elf_group_name(groups.head[i]);
        const char *sec_name = ".group";
        asection *s;
        flagword flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;
        struct symbol *sy;

        for (s = groups.head[i]; s != NULL; s = elf_next_in_group(s)) {
            if ((s->flags ^ flags) & SEC_LINK_ONCE) {
                flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
                if (s != groups.head[i]) {
                    as_warn(_("assuming all members of group `%s' are COMDAT"), group_name);
                    break;
                }
            }
        }

        s = subseg_force_new(sec_name, 0);
        if (s == NULL || !bfd_set_section_flags(s, flags) || !bfd_set_section_alignment(s, 2)) {
            as_fatal(_("can't create group: %s"), bfd_errmsg(bfd_get_error()));
        }
        elf_section_type(s) = SHT_GROUP;

        elf_next_in_group(s) = groups.head[i];
        elf_sec_group(groups.head[i]) = s;

        sy = symbol_find_exact(group_name);
        if (!sy || !symbol_on_chain(sy, symbol_rootP, symbol_lastP)) {
            sy = symbol_new(group_name, now_seg, frag_now, 0);
#ifdef TE_SOLARIS
            symbol_get_bfdsym(sy)->flags |= BSF_WEAK;
            S_SET_OTHER(sy, STV_HIDDEN);
#else
            symbol_get_obj(sy)->local = 1;
#endif
            symbol_table_insert(sy);
        }
        elf_group_id(s) = symbol_get_bfdsym(sy);
        symbol_mark_used_in_reloc(sy);
    }
}

void elf_frob_file(void) {
    bfd_map_over_sections(stdoutput, set_additional_section_info, NULL);

#if defined(elf_tc_final_processing)
    elf_tc_final_processing();
#endif
}

/* It removes any unneeded versioned symbols from the symbol table.  */

void elf_frob_file_before_adjust(void) {
    if (!symbol_rootP) return;

    symbolS *symp = symbol_rootP;
    while (symp) {
        struct elf_obj_sy *sy_obj = symbol_get_obj(symp);
        int is_defined = S_IS_DEFINED(symp);

        if (sy_obj->versioned_name) {
            char *p = strchr(sy_obj->versioned_name->name, ELF_VER_CHR);
            if (!p) {
                symp = symbol_next(symp);
                continue;
            }

            if (sy_obj->rename) {
                size_t l = strlen(&p[3]) + 1;
                memmove(&p[1 + is_defined], &p[3], l);
            }

            if (!is_defined) {
                if (!sy_obj->rename && p[1] == ELF_VER_CHR) {
                    as_bad(_("invalid attempt to declare external "
                             "version name as default in symbol `%s'"),
                           sy_obj->versioned_name->name);
                    return;
                }

                if (sy_obj->versioned_name->next) {
                    as_bad(_("multiple versions [`%s'|`%s'] for "
                             "symbol `%s'"),
                           sy_obj->versioned_name->name,
                           sy_obj->versioned_name->next->name,
                           S_GET_NAME(symp));
                    return;
                }

                sy_obj->rename = true;
            }
        }

        if (!is_defined && (sy_obj->versioned_name || S_IS_WEAK(symp)) &&
            !symbol_used_p(symp) && !symbol_used_in_reloc_p(symp)) {
            symbol_remove(symp, &symbol_rootP, &symbol_lastP);
        }

        symp = symbol_next(symp);
    }
}

/* It is required that we let write_relocs have the opportunity to
   optimize away fixups before output has begun, since it is possible
   to eliminate all fixups for a section and thus we never should
   have generated the relocation section.  */

void elf_frob_file_after_relocs(void) {
    unsigned int i;

    // Set SHT_GROUP section size.
    for (i = 0; i < groups.num_group; i++) {
        asection *s, *head, *group;
        bfd_size_type size;

        head = groups.head[i];
        size = 4;
        for (s = head; s != NULL; s = elf_next_in_group(s)) {
            size += ((s->flags & SEC_RELOC) != 0) ? 8 : 4;
        }

        group = elf_sec_group(head);
        subseg_set(group, 0);
        if (!bfd_set_section_size(group, size)) {
            as_fatal(_("failed to set section size for group"));
        }
        group->contents = (unsigned char *)frag_more(size);
        group->alloced = 1;
        frag_now->fr_fix = frag_now_fix_octets();
        frag_wane(frag_now);
    }

#ifdef NEED_ECOFF_DEBUG
    if (ECOFF_DEBUGGING) {
        const struct ecoff_debug_swap *debug_swap;
        struct ecoff_debug_info debug;
        char *buf;
        asection *sec;

        debug_swap = get_elf_backend_data(stdoutput)->elf_backend_ecoff_debug_swap;
        if (debug_swap == NULL) {
            as_fatal(_("debug swap not found"));
        }

        ecoff_build_debug(&debug.symbolic_header, &buf, debug_swap);

        #define SET(ptr, offset, type) debug.ptr = (type)(buf + debug.symbolic_header.offset)
        SET(line, cbLineOffset, unsigned char *);
        SET(external_dnr, cbDnOffset, void *);
        SET(external_pdr, cbPdOffset, void *);
        SET(external_sym, cbSymOffset, void *);
        SET(external_opt, cbOptOffset, void *);
        SET(external_aux, cbAuxOffset, union aux_ext *);
        SET(ss, cbSsOffset, char *);
        SET(external_fdr, cbFdOffset, void *);
        SET(external_rfd, cbRfdOffset, void *);
        #undef SET

        debug.ssext = debug.ssext_end = NULL;
        debug.external_ext = debug.external_ext_end = NULL;
        if (!bfd_ecoff_debug_externals(stdoutput, &debug, debug_swap, true, elf_get_extr, elf_set_index)) {
            as_fatal(_("failed to set up debugging information: %s"), bfd_errmsg(bfd_get_error()));
        }

        sec = bfd_get_section_by_name(stdoutput, ".mdebug");
        if (sec == NULL) {
            as_fatal(_("section .mdebug not found"));
        }

        if (stdoutput->output_has_begun) {
            as_fatal(_("output has already begun"));
        }

        if (!bfd_set_section_size(sec, bfd_ecoff_debug_size(stdoutput, &debug, debug_swap))) {
            as_fatal(_("failed to set section size for .mdebug"));
        }

        if (!bfd_set_section_contents(stdoutput, sec, buf, 0, 0)) {
            as_fatal(_("can't start writing .mdebug section: %s"), bfd_errmsg(bfd_get_error()));
        }

        if (!bfd_ecoff_write_debug(stdoutput, &debug, debug_swap, sec->filepos)) {
            as_fatal(_("could not write .mdebug section: %s"), bfd_errmsg(bfd_get_error()));
        }
    }
#endif /* NEED_ECOFF_DEBUG */
}

/* This is called when the assembler starts.  */

#include <stddef.h>
#include <string.h>

void elf_begin(void) {
    const char* section_names[] = {TEXT_SECTION_NAME, DATA_SECTION_NAME, BSS_SECTION_NAME};
    size_t section_count = sizeof(section_names) / sizeof(section_names[0]);
    
    for (size_t i = 0; i < section_count; i++) {
        asection *s = bfd_get_section_by_name(stdoutput, section_names[i]);
        if (s != NULL) {
            symbol_table_insert(section_symbol(s));
        }
    }
    
    elf_com_section_ptr = bfd_com_section_ptr;
    previous_section = NULL;
    previous_subsection = 0;
    comment_section = NULL;
    memset(&groups, 0, sizeof(groups));
}

void elf_end(void) {
    struct section_stack *current_section = section_stack;
    while (current_section) {
        struct section_stack *temp_section = current_section;
        current_section = current_section->next;
        free(temp_section);
    }
    section_stack = NULL;

    struct recorded_attribute_info *current_attribute = recorded_attributes;
    while (current_attribute) {
        struct recorded_attribute_info *temp_attribute = current_attribute;
        current_attribute = current_attribute->next;
        free(temp_attribute);
    }
    recorded_attributes = NULL;

    if (groups.indexes) {
        htab_delete(groups.indexes);
        groups.indexes = NULL;
    }

    free(groups.head);
    groups.head = NULL;
}

#ifdef USE_EMULATIONS

static bfd_vma
elf_s_get_size (symbolS *sym)
{
  return S_GET_SIZE (sym);
}

static void
elf_s_set_size (symbolS *sym, bfd_vma sz)
{
  S_SET_SIZE (sym, sz);
}

static bfd_vma
elf_s_get_align (symbolS *sym)
{
  return S_GET_ALIGN (sym);
}

static void
elf_s_set_align (symbolS *sym, bfd_vma align)
{
  S_SET_ALIGN (sym, align);
}

int
elf_s_get_other (symbolS *sym)
{
  return elf_symbol (symbol_get_bfdsym (sym))->internal_elf_sym.st_other;
}

static void
elf_s_set_other (symbolS *sym, int other)
{
  S_SET_OTHER (sym, other);
}

static int
elf_sec_sym_ok_for_reloc (asection *sec)
{
  return obj_sec_sym_ok_for_reloc (sec);
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_process_stab (int what ATTRIBUTE_UNUSED,
		  const char *string ATTRIBUTE_UNUSED,
		  int type ATTRIBUTE_UNUSED,
		  int other ATTRIBUTE_UNUSED,
		  int desc ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_stab (what, string, type, other, desc);
}
#else
# define elf_process_stab NULL
#endif

static int
elf_separate_stab_sections (void)
{
#ifdef NEED_ECOFF_DEBUG
  return (!ECOFF_DEBUGGING);
#else
  return 1;
#endif
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_init_stab_section (segT stab, segT stabstr)
{
  if (!ECOFF_DEBUGGING)
    obj_elf_init_stab_section (stab, stabstr);
}
#endif

const struct format_ops elf_format_ops =
{
  bfd_target_elf_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  elf_begin,
  elf_end,
  elf_file_symbol,
  NULL, /* assign_symbol */
  elf_frob_symbol,
  elf_frob_file,
  elf_frob_file_before_adjust,
  0,	/* obj_frob_file_before_fix */
  elf_frob_file_after_relocs,
  elf_s_get_size, elf_s_set_size,
  elf_s_get_align, elf_s_set_align,
  elf_s_get_other,
  elf_s_set_other,
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  elf_copy_symbol_attributes,
  elf_process_stab,
  elf_separate_stab_sections,
#ifdef NEED_ECOFF_DEBUG
  elf_init_stab_section,
#else
  obj_elf_init_stab_section,
#endif
  elf_sec_sym_ok_for_reloc,
  elf_pop_insert,
#ifdef NEED_ECOFF_DEBUG
  elf_ecoff_set_ext,
#else
  0,	/* ecoff_set_ext */
#endif
  elf_obj_read_begin_hook,
  elf_obj_symbol_new_hook,
  0,
  elf_adjust_symtab
};

#endif /* USE_EMULATIONS */
