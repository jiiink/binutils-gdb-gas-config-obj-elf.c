/* ELF object file format
   Copyright (C) 1992-2025 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 3,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#define OBJ_HEADER "obj-elf.h"
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "obstack.h"
#include "dwarf2dbg.h"
#include "ginsn.h"

#ifndef ECOFF_DEBUGGING
#define ECOFF_DEBUGGING 0
#else
#define NEED_ECOFF_DEBUG
#endif

#ifdef NEED_ECOFF_DEBUG
#include "ecoff.h"
#include "bfd/ecoff-bfd.h"
#endif

#ifdef TC_ALPHA
#include "elf/alpha.h"
#endif

#ifdef TC_MIPS
#include "elf/mips.h"
#endif

#ifdef TC_PPC
#include "elf/ppc.h"
#endif

#ifdef TC_I386
#include "elf/x86-64.h"
#endif

#ifdef TC_MEP
#include "elf/mep.h"
#endif

#ifdef TC_PRU
#include "elf/pru.h"
#endif

static void obj_elf_line (int);
static void obj_elf_size (int);
static void obj_elf_type (int);
static void obj_elf_ident (int);
static void obj_elf_weak (int);
static void obj_elf_local (int);
static void obj_elf_visibility (int);
static void obj_elf_symver (int);
static void obj_elf_subsection (int);
static void obj_elf_popsection (int);
static void obj_elf_gnu_attribute (int);
static void obj_elf_tls_common (int);
static void obj_elf_lcomm (int);
static void obj_elf_struct (int);
static void obj_elf_attach_to_group (int);

static const pseudo_typeS elf_pseudo_table[] =
{
  {"attach_to_group", obj_elf_attach_to_group, 0},
  {"comm", obj_elf_common, 0},
  {"common", obj_elf_common, 1},
  {"ident", obj_elf_ident, 0},
  {"lcomm", obj_elf_lcomm, 0},
  {"local", obj_elf_local, 0},
  {"previous", obj_elf_previous, 0},
  {"section", obj_elf_section, 0},
  {"section.s", obj_elf_section, 0},
  {"sect", obj_elf_section, 0},
  {"sect.s", obj_elf_section, 0},
  {"pushsection", obj_elf_section, 1},
  {"popsection", obj_elf_popsection, 0},
  {"size", obj_elf_size, 0},
  {"type", obj_elf_type, 0},
  {"version", obj_elf_version, 0},
  {"weak", obj_elf_weak, 0},

  /* These define symbol visibility.  */
  {"internal", obj_elf_visibility, STV_INTERNAL},
  {"hidden", obj_elf_visibility, STV_HIDDEN},
  {"protected", obj_elf_visibility, STV_PROTECTED},

  /* These are used for stabs-in-elf configurations.  */
  {"line", obj_elf_line, 0},

  /* This is a GNU extension to handle symbol versions.  */
  {"symver", obj_elf_symver, 0},

  /* A GNU extension to change subsection only.  */
  {"subsection", obj_elf_subsection, 0},

  /* These are GNU extensions to aid in garbage collecting C++ vtables.  */
  {"vtable_inherit", obj_elf_vtable_inherit, 0},
  {"vtable_entry", obj_elf_vtable_entry, 0},

  /* A GNU extension for object attributes.  */
  {"gnu_attribute", obj_elf_gnu_attribute, 0},

  /* These are used for dwarf2.  */
  { "file", dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },
  { "loc_mark_labels", dwarf2_directive_loc_mark_labels, 0 },

  /* We need to trap the section changing calls to handle .previous.  */
  {"data", obj_elf_data, 0},
  {"offset", obj_elf_struct, 0},
  {"struct", obj_elf_struct, 0},
  {"text", obj_elf_text, 0},
  {"bss", obj_elf_bss, 0},

  {"tls_common", obj_elf_tls_common, 0},

  /* End sentinel.  */
  {NULL, NULL, 0},
};

static const pseudo_typeS ecoff_debug_pseudo_table[] =
{
#ifdef NEED_ECOFF_DEBUG
  /* COFF style debugging information for ECOFF. .ln is not used; .loc
     is used instead.  */
  { "def",	ecoff_directive_def,	0 },
  { "dim",	ecoff_directive_dim,	0 },
  { "endef",	ecoff_directive_endef,	0 },
  { "file",	ecoff_directive_file,	0 },
  { "scl",	ecoff_directive_scl,	0 },
  { "tag",	ecoff_directive_tag,	0 },
  { "val",	ecoff_directive_val,	0 },

  /* COFF debugging requires pseudo-ops .size and .type, but ELF
     already has meanings for those.  We use .esize and .etype
     instead.  These are only generated by gcc anyhow.  */
  { "esize",	ecoff_directive_size,	0 },
  { "etype",	ecoff_directive_type,	0 },

  /* ECOFF specific debugging information.  */
  { "aent",	ecoff_directive_ent,	1 },
  { "begin",	ecoff_directive_begin,	0 },
  { "bend",	ecoff_directive_bend,	0 },
  { "end",	ecoff_directive_end,	0 },
  { "ent",	ecoff_directive_ent,	0 },
  { "fmask",	ecoff_directive_fmask,	0 },
  { "frame",	ecoff_directive_frame,	0 },
  { "loc",	ecoff_directive_loc,	0 },
  { "mask",	ecoff_directive_mask,	0 },

  /* Other ECOFF directives.  */
  { "extern",	ecoff_directive_extern,	0 },

  /* These are used on Irix.  I don't know how to implement them.  */
  { "alias",	s_ignore,		0 },
  { "bgnb",	s_ignore,		0 },
  { "endb",	s_ignore,		0 },
  { "lab",	s_ignore,		0 },
  { "noalias",	s_ignore,		0 },
  { "verstamp",	s_ignore,		0 },
  { "vreg",	s_ignore,		0 },
#endif

  {NULL, NULL, 0}			/* end sentinel */
};

#undef NO_RELOC
#include "aout/aout64.h"

asection *elf_com_section_ptr;

void elf_pop_insert(void)
{
    pop_insert(elf_pseudo_table);

    const int ecoff_debugging_enabled = ECOFF_DEBUGGING;
    if (ecoff_debugging_enabled) {
        pop_insert(ecoff_debug_pseudo_table);
    }
}

void
elf_file_symbol (const char *s)
{
  const char *src = s ? s : "";
  symbolS *sym = symbol_new (src, absolute_section, &zero_address_frag, 0);
  if (sym == NULL)
    return;

  size_t name_length = strlen (src);
  const char *current_name = S_GET_NAME (sym);
  size_t current_len = current_name ? strlen (current_name) : 0;

  if (!current_name || name_length > current_len)
    {
      obstack_grow (&notes, src, name_length + 1);
      S_SET_NAME (sym, obstack_finish (&notes));
    }
  else
    {
      memmove ((char *) current_name, src, name_length + 1);
    }

  {
    asymbol *bsym = symbol_get_bfdsym (sym);
    if (bsym != NULL)
      bsym->flags |= BSF_FILE;
  }

  if (symbol_rootP != sym)
    {
      asymbol *root_bsym = symbol_get_bfdsym (symbol_rootP);
      if (root_bsym == NULL || (root_bsym->flags & BSF_FILE) == 0)
	{
	  symbol_remove (sym, &symbol_rootP, &symbol_lastP);
	  symbol_insert (sym, symbol_rootP, &symbol_rootP, &symbol_lastP);
	}
    }

#ifdef DEBUG
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif

#ifdef NEED_ECOFF_DEBUG
  ecoff_new_file (src);
#endif
}

/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

static int parse_common_segment_quoted(void)
{
  char *start = input_line_pointer;
  char *p;
  char c;

  input_line_pointer++;
  if (*input_line_pointer == '.')
    input_line_pointer++;

  if (startswith(input_line_pointer, "bss\""))
    {
      input_line_pointer += 4;
      return 0;
    }

  if (startswith(input_line_pointer, "data\""))
    {
      input_line_pointer += 5;
      return 0;
    }

  p = input_line_pointer;
  while (p > start && *--p != '"')
    ;
  while (!is_end_of_stmt(*input_line_pointer))
    {
      if (*input_line_pointer++ == '"')
        break;
    }

  c = *input_line_pointer;
  *input_line_pointer = '\0';
  as_bad(_("bad .common segment %s"), p);
  *input_line_pointer = c;
  ignore_rest_of_line();
  return -1;
}

symbolS *
elf_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size)
{
  addressT align = 0;
  int is_local;

  if (symbolP == NULL)
    return NULL;

  is_local = symbol_get_obj (symbolP)->local;

  if (*input_line_pointer == ',')
    {
      char *saved = input_line_pointer;

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '"')
        {
          if (parse_common_segment_quoted () != 0)
            return NULL;
          is_local = 0;
        }
      else
        {
          input_line_pointer = saved;
          align = parse_align (is_local);
          if (align == (addressT) -1)
            return NULL;
        }
    }

  if (is_local)
    {
      bss_alloc (symbolP, size, align);
      S_CLEAR_EXTERNAL (symbolP);
    }
  else
    {
      S_SET_VALUE (symbolP, size);
      S_SET_ALIGN (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, elf_com_section_ptr);
    }

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  return symbolP;
}

void obj_elf_common(int is_common)
{
    if (flag_mri && is_common) {
        s_mri_common(0);
        return;
    }
    s_comm_internal(0, elf_common_parse);
}

static void
obj_elf_tls_common (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, elf_common_parse);
  asymbol *bfd_sym;

  (void) ignore;

  if (symbolP == NULL)
    return;

  bfd_sym = symbol_get_bfdsym (symbolP);
  if (bfd_sym == NULL)
    return;

  bfd_sym->flags |= BSF_THREAD_LOCAL;
}

static void
obj_elf_lcomm (int ignore ATTRIBUTE_UNUSED)
{
  (void) ignore;

  symbolS *symbolP = s_comm_internal (0, s_lcomm_internal);
  if (symbolP != NULL)
    {
      asymbol *bfd_sym = symbol_get_bfdsym (symbolP);
      if (bfd_sym != NULL)
        bfd_sym->flags |= BSF_OBJECT;
    }
}

static symbolS *
get_sym_from_input_line_and_check(void)
{
  char *name = NULL;
  const char c = get_symbol_name(&name);
  symbolS *const sym = symbol_find_or_make(name);

  restore_line_pointer(c);
  SKIP_WHITESPACE();

  if (name == input_line_pointer) {
    as_bad(_("Missing symbol name in directive"));
  }
  return sym;
}

static void
obj_elf_local (int ignore ATTRIBUTE_UNUSED)
{
  for (;;)
    {
      symbolS *symbolP = get_sym_from_input_line_and_check ();
      S_CLEAR_EXTERNAL (symbolP);
      symbol_get_obj (symbolP)->local = 1;

      int ch = *input_line_pointer;
      if (ch != ',')
        break;

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '\n')
        break;
    }
  demand_empty_rest_of_line ();
}

static void
obj_elf_weak (int ignore ATTRIBUTE_UNUSED)
{
  for (;;)
    {
      symbolS *symbolP = get_sym_from_input_line_and_check ();
      int next_char = *input_line_pointer;

      S_SET_WEAK (symbolP);

      if (next_char != ',')
        break;

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '\n')
        break;
    }
  demand_empty_rest_of_line ();
}

static void
obj_elf_visibility (int visibility)
{
  int c;
  symbolS *symbolP;
  asymbol *bfdsym;
  elf_symbol_type *elfsym;

  for (;;)
    {
      symbolP = get_sym_from_input_line_and_check ();
      bfdsym = symbol_get_bfdsym (symbolP);
      elfsym = elf_symbol_from (bfdsym);

      gas_assert (elfsym);

      elfsym->internal_elf_sym.st_other =
        (elfsym->internal_elf_sym.st_other & ~3) | visibility;

      c = *input_line_pointer;
      if (c != ',')
        break;

      input_line_pointer++;

      SKIP_WHITESPACE ();

      if (*input_line_pointer == '\n')
        break;
    }

  demand_empty_rest_of_line ();
}

static segT previous_section;
static int previous_subsection;

struct section_stack
{
  struct section_stack *next;
  segT seg, prev_seg;
  int subseg, prev_subseg;
};

static struct section_stack *section_stack;

/* ELF section flags for unique sections.  */
#define SEC_ASSEMBLER_SHF_MASK SHF_GNU_RETAIN

struct group_list
{
  asection **head;		/* Section lists.  */
  unsigned int num_group;	/* Number of lists.  */
  htab_t indexes; /* Maps group name to index in head array.  */
};

static struct group_list groups;

static bool names_equal(const char *a, const char *b)
{
  if (a == b)
    return true;
  if (a == NULL || b == NULL)
    return false;
  return strcmp(a, b) == 0;
}

static bool
match_section (const asection *sec, const struct elf_section_match *match)
{
  if (sec == NULL || match == NULL)
    return false;

  unsigned int sh_info = elf_section_data (sec)->this_hdr.sh_info;
  bfd_vma sh_flags = elf_section_data (sec)->this_hdr.sh_flags & SEC_ASSEMBLER_SHF_MASK;
  bfd_vma sec_id_flags = bfd_section_flags (sec) & SEC_ASSEMBLER_SECTION_ID;
  bfd_vma match_id_flags = match->flags & SEC_ASSEMBLER_SECTION_ID;
  const char *linked_to_symbol_name = sec->map_head.linked_to_symbol_name;

  if (sh_info != match->sh_info)
    return false;

  if (sh_flags != match->sh_flags)
    return false;

  if (sec_id_flags != match_id_flags)
    return false;

  if (sec->section_id != match->section_id)
    return false;

  return names_equal (linked_to_symbol_name, match->linked_to_symbol_name);
}

/* Return TRUE iff SEC matches the section info INF.  */

static bool
get_section_by_match (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  struct elf_section_match *match;
  const char *gname;
  const char *group_name;

  if (sec == NULL || inf == NULL)
    return false;

  match = (struct elf_section_match *) inf;
  gname = match->group_name;
  group_name = elf_group_name (sec);

  if (!(group_name == gname
        || (group_name != NULL && gname != NULL && strcmp (group_name, gname) == 0)))
    return false;

  return match_section (sec, match);
}

/* Go look in section lists kept per group for SEC_NAME with
   properties given by MATCH.  If info for the group named by
   MATCH->GROUP_NAME has been initialised, set GROUP_IDX.  */

static asection *
group_section_find (const struct elf_section_match *match,
                    const char *sec_name,
                    unsigned int *group_idx)
{
  if (group_idx)
    *group_idx = ~0u;

  if (match == NULL || sec_name == NULL || match->group_name == NULL)
    return NULL;

  if (!groups.indexes)
    {
      groups.num_group = 0;
      groups.head = NULL;
      groups.indexes = htab_create_alloc (16, hash_string_tuple, eq_string_tuple,
                                          NULL, notes_calloc, NULL);
      return NULL;
    }

  unsigned int idx = str_hash_find_int (groups.indexes, match->group_name);
  if (idx == ~0u)
    return NULL;

  if (group_idx)
    *group_idx = idx;

  if (groups.head == NULL || idx >= groups.num_group)
    return NULL;

  for (asection *s = groups.head[idx]; s != NULL; s = elf_next_in_group (s))
    {
      const char *name = s->name;
      if (((name == sec_name) || (name && strcmp (name, sec_name) == 0))
          && match_section (s, match))
        return s;
    }

  return NULL;
}

/* Insert SEC into section lists kept per group.  MATCH and GROUP_IDX
   must be from a prior call to group_section_find.  */

static void
group_section_insert(const struct elf_section_match *match,
                     asection *sec,
                     unsigned int *group_idx)
{
  const unsigned int GROUP_INDEX_UNSET = ~0u;
  const unsigned int GROUP_GROW_CHUNK = 128u;

  if (match == NULL || sec == NULL || group_idx == NULL)
    return;

  if (*group_idx != GROUP_INDEX_UNSET)
    {
      elf_next_in_group(sec) = groups.head[*group_idx];
      groups.head[*group_idx] = sec;
      return;
    }

  unsigned int i = groups.num_group;

  if ((i & (GROUP_GROW_CHUNK - 1u)) == 0u)
    groups.head = XRESIZEVEC(asection *, groups.head, i + GROUP_GROW_CHUNK);

  groups.head[i] = sec;
  groups.num_group = i + 1u;

  str_hash_insert_int(groups.indexes, match->group_name, i, 0);
}

/* Handle the .section pseudo-op.  This code supports two different
   syntaxes.

   The first is found on Solaris, and looks like
       .section ".sec1",#alloc,#execinstr,#write
   Here the names after '#' are the SHF_* flags to turn on for the
   section.  I'm not sure how it determines the SHT_* type (BFD
   doesn't really give us control over the type, anyhow).

   The second format is found on UnixWare, and probably most SVR4
   machines, and looks like
       .section .sec1,"a",@progbits
   The quoted string may contain any combination of a, w, x, and
   represents the SHF_* flags to turn on for the section.  The string
   beginning with '@' can be progbits or nobits.  There should be
   other possibilities, but I don't know what they are.  In any case,
   BFD doesn't really let us set the section type.  */

static void
change_section (const char *name,
		unsigned int type,
		bfd_vma attr,
		int entsize,
		struct elf_section_match *match_p,
		bool linkonce,
		bool push,
		subsegT new_subsection)
{
  asection *old_sec;
  segT sec;
  flagword flags;
  const struct elf_backend_data *bed;
  const struct bfd_elf_special_section *ssect;

  if (match_p == NULL)
    {
      static struct elf_section_match unused_match;
      match_p = &unused_match;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (push)
    {
      struct section_stack *elt = XNEW (struct section_stack);
      elt->next = section_stack;
      elt->seg = now_seg;
      elt->prev_seg = previous_section;
      elt->subseg = now_subseg;
      elt->prev_subseg = previous_subsection;
      section_stack = elt;
    }

  obj_elf_section_change_hook ();

  unsigned int group_idx = ~0u;
  if (match_p->group_name)
    old_sec = group_section_find (match_p, name, &group_idx);
  else
    old_sec = bfd_get_section_by_name_if (stdoutput, name, get_section_by_match, match_p);

  if (old_sec)
    {
      sec = old_sec;
      subseg_set (sec, new_subsection);
    }
  else
    {
      sec = subseg_force_new (name, new_subsection);
      if (match_p->group_name)
	group_section_insert (match_p, sec, &group_idx);
    }

  const bool is_new = (old_sec == NULL);
  bed = get_elf_backend_data (stdoutput);
  ssect = (*bed->get_sec_type_attr) (stdoutput, sec);

  if (ssect != NULL)
    {
      bool override = false;

      if (type == SHT_NULL)
	type = ssect->type;
      else if (type != ssect->type)
	{
	  bool must_ignore = !is_new
#ifdef TC_I386
	    || (bed->s->arch_size == 64 && (ssect->attr & SHF_X86_64_LARGE))
#endif
	    || ssect->type == SHT_INIT_ARRAY
	    || ssect->type == SHT_FINI_ARRAY
	    || ssect->type == SHT_PREINIT_ARRAY;

	  if (!must_ignore)
	    {
	      if (ssect->type != SHT_NOTE && type < SHT_LOPROC)
		as_warn (_("setting incorrect section type for %s"), name);
	    }
	  else
	    {
	      as_warn (_("ignoring incorrect section type for %s"), name);
	      type = ssect->type;
	    }
	}

      if (is_new
	  && ((attr & ~(SHF_LINK_ORDER | SHF_MASKOS | SHF_MASKPROC)) & ~ssect->attr) != 0)
	{
	  bfd_vma generic_attr = attr;

	  if (elf_tdata (stdoutput)->has_gnu_osabi)
	    generic_attr &= ~SHF_GNU_RETAIN;

	  if (ssect->type == SHT_NOTE
	      && (generic_attr == SHF_ALLOC || generic_attr == SHF_EXECINSTR))
	    {
	      /* allowed */ ;
	    }
	  else if (ssect->suffix_length == -2
		   && name[ssect->prefix_length] == '.'
		   && (generic_attr & ~ssect->attr & ~SHF_MERGE & ~SHF_STRINGS) == 0)
	    {
	      /* allowed */ ;
	    }
	  else if (generic_attr == SHF_ALLOC
		   && (strcmp (name, ".interp") == 0
		       || strcmp (name, ".strtab") == 0
		       || strcmp (name, ".symtab") == 0))
	    {
	      override = true;
	    }
	  else if (generic_attr == SHF_EXECINSTR
		   && strcmp (name, ".note.GNU-stack") == 0)
	    {
	      override = true;
	    }
#ifdef TC_ALPHA
	  else if ((generic_attr & ~ssect->attr) == SHF_ALPHA_GPREL)
	    {
	      override = true;
	    }
#endif
#ifdef TC_RX
	  else if (generic_attr == (SHF_EXECINSTR | SHF_WRITE | SHF_ALLOC)
		   && (ssect->type == SHT_INIT_ARRAY
		       || ssect->type == SHT_FINI_ARRAY
		       || ssect->type == SHT_PREINIT_ARRAY))
	    {
	      /* allowed */ ;
	    }
#endif
	  else
	    {
	      if (match_p->group_name == NULL)
		as_warn (_("setting incorrect section attributes for %s"), name);
	      override = true;
	    }
	}

      if (!override && is_new)
	attr |= ssect->attr;
    }

  flags = (SEC_RELOC
	   | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
	   | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
	   | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
	   | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0)
	   | ((attr & SHF_MERGE) ? SEC_MERGE : 0)
	   | ((attr & SHF_STRINGS) ? SEC_STRINGS : 0)
	   | ((attr & SHF_EXCLUDE) ? SEC_EXCLUDE: 0)
	   | ((attr & SHF_TLS) ? SEC_THREAD_LOCAL : 0));
#ifdef md_elf_section_flags
  flags = md_elf_section_flags (flags, attr, type);
#endif

  if (linkonce)
    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;

  if ((flags & SEC_ALLOC) == 0 && name[0] == '.')
    {
      if (startswith (name, ".debug")
	  || startswith (name, ".zdebug")
	  || startswith (name, ".gnu.debuglto_.debug_")
	  || startswith (name, ".gnu.linkonce.wi.")
	  || startswith (name, GNU_BUILD_ATTRS_SECTION_NAME)
	  || startswith (name, ".note.gnu"))
	flags |= SEC_ELF_OCTETS;
    }

  if (is_new)
    {
      symbolS *secsym;

      if (type == SHT_NULL)
	type = bfd_elf_get_default_section_type (flags);

      elf_section_type (sec) = type;
      elf_section_flags (sec) = attr;
      elf_section_data (sec)->this_hdr.sh_info = match_p->sh_info;

      if (type == SHT_NOBITS)
	seg_info (sec)->bss = 1;

      sec->section_id = match_p->section_id;
      flags |= match_p->flags;

      sec->map_head.linked_to_symbol_name = match_p->linked_to_symbol_name;

      bfd_set_section_flags (sec, flags);
      if (entsize != 0)
	sec->entsize = entsize;
      elf_group_name (sec) = match_p->group_name;

      secsym = symbol_find (name);
      if (secsym != NULL)
	{
	  static const expressionS exp = { .X_op = O_constant };
	  symbol_set_value_expression (secsym, &exp);
	  symbol_set_bfdsym (secsym, sec->symbol);
	}
      else
	{
	  symbol_table_insert (section_symbol (sec));
	}
    }
  else
    {
      if (type != SHT_NULL && (unsigned) type != elf_section_type (old_sec))
	{
	  if (ssect != NULL)
	    as_warn (_("ignoring changed section type for %s"), name);
	  else
	    as_bad (_("changed section type for %s"), name);
	}

      if (attr != 0)
	{
	  if (((old_sec->flags ^ flags)
	       & (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
		  | SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | SEC_STRINGS
		  | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
		  | SEC_THREAD_LOCAL)))
	    {
	      if (ssect != NULL)
		as_warn (_("ignoring changed section attributes for %s"), name);
	      else
		as_bad (_("changed section attributes for %s"), name);
	    }
	  else
	    {
	      elf_section_flags (sec) = attr;
	    }

	  if (entsize != 0 && old_sec->entsize != (unsigned) entsize)
	    as_bad (_("changed section entity size for %s"), name);
	}
    }

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

void
obj_elf_change_section (const char *name,
			unsigned int type,
			bfd_vma attr,
			int entsize,
			struct elf_section_match *match_p,
			bool linkonce)
{
  const bool relocatable = false;
  const unsigned int flags = 0U;
  change_section (name, type, attr, entsize, match_p, linkonce, relocatable, flags);
}

static size_t
handle_unrecognized_attr(const char *s, size_t remaining, bool push,
                         bfd_vma *attr, int *inherit, bfd_vma *gnu_attr)
{
  const char *md_extra = "";

#ifdef md_elf_section_letter
  {
    bfd_vma md_attr = md_elf_section_letter (*s, &md_extra);
    if (md_attr != (bfd_vma) -1)
      {
        if (attr != NULL)
          *attr |= md_attr;
        return 1;
      }
  }
#endif

  if (ISDIGIT ((unsigned char) *s))
    {
      char *end = NULL;
      bfd_vma numeric_flags = (bfd_vma) strtoul (s, &end, 0);

      if (attr != NULL)
        *attr |= numeric_flags;

      if (gnu_attr != NULL)
        *gnu_attr |= (numeric_flags & SHF_MASKOS);

      if (end != NULL && end > s)
        return (size_t) (end - s);

      return 1;
    }
  else if (inherit != NULL
           && *inherit == 0
           && (attr == NULL || *attr == 0)
           && (gnu_attr == NULL || *gnu_attr == 0)
           && (*s == '+' || *s == '-'))
    {
      *inherit = (*s == '+') ? 1 : -1;
      return 1;
    }
  else
    {
      as_bad (_("unrecognized .%ssection attribute: want %s%s%s,? or number"),
              push ? "push" : "",
              gnu_attr != NULL ? "a,d,e,o,w,x,E,G,M,R,S,T"
                               : "a,e,o,w,x,E,G,M,S,T",
              (md_extra != NULL && md_extra[0] != '\0') ? "," : "",
              md_extra);
      return (size_t) -1;
    }
}

static bfd_vma
obj_elf_parse_section_letters (char *str, size_t len, bool push,
                               bool *is_clone, int *inherit, bfd_vma *gnu_attr,
                               bool *has_entsize)
{
  bfd_vma attr = 0;

  if (is_clone != NULL)
    *is_clone = false;
  if (inherit != NULL)
    *inherit = 0;

  if (str == NULL || len == 0)
    return attr;

  for (size_t pos = 0; pos < len; )
    {
      char ch = str[pos];
      size_t consumed = 1;

      switch (ch)
        {
        case 'a':
          attr |= SHF_ALLOC;
          if (pos + 1 < len && str[pos + 1] == 'm')
            {
              attr |= SHF_MERGE;
              consumed++;
              if (pos + 2 < len && str[pos + 2] == 's')
                {
                  attr |= SHF_STRINGS;
                  consumed++;
                }
            }
          break;

        case 'd':
          if (gnu_attr != NULL)
            *gnu_attr |= SHF_GNU_MBIND;
          else
            {
              consumed = handle_unrecognized_attr(&str[pos], len - pos, push,
                                                  &attr, inherit, gnu_attr);
              if (consumed == (size_t) -1)
                return attr;
            }
          break;

        case 'e':
          attr |= SHF_EXCLUDE;
          break;

        case 'o':
          attr |= SHF_LINK_ORDER;
          break;

        case 'w':
          attr |= SHF_WRITE;
          break;

        case 'x':
          attr |= SHF_EXECINSTR;
          break;

        case 'E':
          if (has_entsize != NULL)
            *has_entsize = true;
          break;

        case 'G':
          attr |= SHF_GROUP;
          break;

        case 'M':
          attr |= SHF_MERGE;
          break;

        case 'R':
          if (gnu_attr != NULL)
            *gnu_attr |= SHF_GNU_RETAIN;
          else
            {
              consumed = handle_unrecognized_attr(&str[pos], len - pos, push,
                                                  &attr, inherit, gnu_attr);
              if (consumed == (size_t) -1)
                return attr;
            }
          break;

        case 'S':
          attr |= SHF_STRINGS;
          break;

        case 'T':
          attr |= SHF_TLS;
          break;

        case '?':
          if (is_clone != NULL)
            *is_clone = true;
          break;

        default:
          consumed = handle_unrecognized_attr(&str[pos], len - pos, push,
                                              &attr, inherit, gnu_attr);
          if (consumed == (size_t) -1)
            return attr;
          break;
        }

      pos += consumed;
    }

  return attr;
}

static int memeq_n(const char *a, const char *b, size_t n)
{
  if (a == NULL || b == NULL)
    return 0;
  for (size_t i = 0; i < n; ++i)
    {
      if (a[i] != b[i])
        return 0;
    }
  return 1;
}

static int
obj_elf_section_type (char *str, size_t len, bool warn)
{
  if (str == NULL)
    {
      if (warn)
        as_warn (_("unrecognized section type"));
      return 0;
    }

  switch (len)
    {
    case 4:
      if (memeq_n (str, "note", 4))
        return SHT_NOTE;
      break;
    case 6:
      if (memeq_n (str, "nobits", 6))
        return SHT_NOBITS;
      break;
    case 8:
      if (memeq_n (str, "progbits", 8))
        return SHT_PROGBITS;
      break;
    case 10:
      if (memeq_n (str, "init_array", 10))
        return SHT_INIT_ARRAY;
      if (memeq_n (str, "fini_array", 10))
        return SHT_FINI_ARRAY;
      break;
    case 13:
      if (memeq_n (str, "preinit_array", 13))
        return SHT_PREINIT_ARRAY;
      break;
    default:
      break;
    }

#ifdef md_elf_section_type
  {
    int md_type = md_elf_section_type (str, len);
    if (md_type >= 0)
      return md_type;
  }
#endif

  if (len > 0 && ISDIGIT (*str))
    {
      char *end = NULL;
      int type = (int) strtoul (str, &end, 0);

      if (warn && (size_t) (end - str) != len)
        as_warn (_("extraneous characters at end of numeric section type"));

      return type;
    }

  if (warn)
    as_warn (_("unrecognized section type"));
  return 0;
}

#ifdef TC_SPARC
static bfd_vma
obj_elf_section_word (char *str, size_t len, int *type)
{
  int ret;

  if (len == 5 && startswith (str, "write"))
    return SHF_WRITE;
  if (len == 5 && startswith (str, "alloc"))
    return SHF_ALLOC;
  if (len == 9 && startswith (str, "execinstr"))
    return SHF_EXECINSTR;
  if (len == 7 && startswith (str, "exclude"))
    return SHF_EXCLUDE;
  if (len == 3 && startswith (str, "tls"))
    return SHF_TLS;

  ret = obj_elf_section_type (str, len, false);
  if (ret != 0)
    *type = ret;
  else
    as_warn (_("unrecognized section attribute"));

  return 0;
}
#endif

/* Get name of section.  */
const char *
obj_elf_section_name (void)
{
  char *name;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      int dummy;
      name = demand_copy_C_string (&dummy);
      if (name == NULL)
        {
          ignore_rest_of_line ();
          return NULL;
        }
    }
  else
    {
      char *end = input_line_pointer;

      while (!is_whitespace (*end) && !is_end_of_stmt (*end) && *end != ',')
        end++;

      if (end == input_line_pointer)
        {
          as_bad (_("missing name"));
          ignore_rest_of_line ();
          return NULL;
        }

      obstack_grow0 (&notes, input_line_pointer, (size_t) (end - input_line_pointer));
      name = obstack_base (&notes);

      if (flag_sectname_subst)
        {
          const char *segname = now_seg->name;
          const size_t seglen = strlen (segname);

          for (;;)
            {
              char *subst = strstr (name, "%S");
              if (!subst)
                break;

              size_t head = (size_t) (subst - name);
              size_t tail = strlen (subst + 2) + 1;

              if (seglen > 2)
                {
                  obstack_blank (&notes, seglen - 2);
                  name = obstack_base (&notes);
                }

              memmove (name + head + seglen, name + head + 2, tail);
              memcpy (name + head, segname, seglen);
            }
        }

      obstack_finish (&notes);

#ifdef tc_canonicalize_section_name
      name = tc_canonicalize_section_name (name);
#endif
      input_line_pointer = end;
    }
  SKIP_WHITESPACE ();
  return name;
}

/* Arrange to put SEC, known to be in group GNAME into the per-group
   section lists kept by gas.  */

void
elf_set_group_name (asection *sec, const char *gname)
{
  if (sec == NULL || gname == NULL)
    return;

  struct bfd_elf_section_data *secdata = elf_section_data (sec);
  if (secdata == NULL || sec->name == NULL)
    return;

  elf_group_name (sec) = gname;
  elf_section_flags (sec) |= SHF_GROUP;

  struct elf_section_match match;
  match.group_name = gname;
  match.linked_to_symbol_name = sec->map_head.linked_to_symbol_name;
  match.section_id = sec->section_id;
  match.sh_info = secdata->this_hdr.sh_info;
  match.sh_flags = (secdata->this_hdr.sh_flags & SEC_ASSEMBLER_SHF_MASK);
  match.flags = bfd_section_flags (sec) & SEC_ASSEMBLER_SECTION_ID;

  unsigned int group_idx = 0;
  if (!group_section_find (&match, sec->name, &group_idx))
    group_section_insert (&match, sec, &group_idx);
}

static void
obj_elf_attach_to_group (int dummy ATTRIBUTE_UNUSED)
{
  const char *gname;
  const char *existing_group;

  if (now_seg == NULL)
    return;

  gname = obj_elf_section_name ();
  if (gname == NULL)
    {
      as_warn (_("group name not parseable"));
      return;
    }

  existing_group = elf_group_name (now_seg);
  if (existing_group != NULL)
    {
      if (strcmp (existing_group, gname) != 0)
        as_warn (_("section %s already has a group (%s)"),
                 bfd_section_name (now_seg), existing_group);
      return;
    }

  elf_set_group_name (now_seg, gname);
}

/* Handle section related directives.

   Note on support for SFrame sections: These are generally expected to be
   generated by the assembler.  However, this function permits their direct
   creation by the user.  At the moment though, we go no extra mile by adding
   an explicit @sframe for SHT_GNU_SFRAME (using the numeric value of section
   type should suffice); Nor do we implement any outright refusal for
   non-supported targets via ELFOSABI-specific checks.  */

void
obj_elf_section (int push)
{
  const char *name;
  char *beg;
  int type, str_dummy_len;
  bfd_vma attr;
  bfd_vma gnu_attr;
  int entsize;
  bool linkonce, has_entsize;
  subsegT new_subsection = 0;
  struct elf_section_match match;
  unsigned long linked_to_section_index = -1UL;
  symbolS *sym;

  if (flag_mri)
    {
      char mri_type;

#ifdef md_flush_pending_output
      md_flush_pending_output ();
#endif

      obj_elf_section_change_hook ();

      s_mri_sect (&mri_type);

#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif

      return;
    }

  name = obj_elf_section_name ();
  if (name == NULL)
    return;

  memset (&match, 0, sizeof (match));

  sym = symbol_find (name);
  if (sym != NULL
      && ! symbol_section_p (sym)
      && S_IS_DEFINED (sym)
      && ! S_IS_VOLATILE (sym)
      && ! S_CAN_BE_REDEFINED (sym))
    {
      as_bad (_("section name '%s' already defined as another symbol"), name);
      ignore_rest_of_line ();
      return;
    }

  type = SHT_NULL;
  attr = 0;
  gnu_attr = 0;
  entsize = 0;
  has_entsize = false;
  linkonce = false;

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (push && ISDIGIT (*input_line_pointer))
	{
	  new_subsection = get_absolute_expression ();

	  SKIP_WHITESPACE ();

	  if (*input_line_pointer != ',')
	    goto done;

	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	}

      if (*input_line_pointer == '"')
	{
	  bool is_clone;
	  int inherit;

	  beg = demand_copy_C_string (&str_dummy_len);
	  if (beg == NULL)
	    {
	      ignore_rest_of_line ();
	      return;
	    }

	  const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
	  attr = obj_elf_parse_section_letters (beg, strlen (beg), push,
						&is_clone, &inherit,
						bed->elf_osabi == ELFOSABI_NONE
						|| bed->elf_osabi == ELFOSABI_GNU
						|| bed->elf_osabi == ELFOSABI_FREEBSD
						? &gnu_attr : NULL,
						&has_entsize);

	  if (inherit > 0)
	    attr |= elf_section_flags (now_seg);
	  else if (inherit < 0)
	    attr = elf_section_flags (now_seg) & ~attr;
	  if (inherit)
	    type = elf_section_type (now_seg);

	  if ((attr & (SHF_MERGE | SHF_STRINGS)) != 0)
	    has_entsize = true;

	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      char c;
	      char *save = input_line_pointer;

	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      c = *input_line_pointer;
	      if (c == '"')
		{
		  beg = demand_copy_C_string (&str_dummy_len);
		  if (beg == NULL)
		    {
		      ignore_rest_of_line ();
		      return;
		    }
		  type = obj_elf_section_type (beg, strlen (beg), true);
		}
	      else if (c == '@' || c == '%')
		{
		  ++input_line_pointer;

		  if (ISDIGIT (* input_line_pointer))
		    type = strtoul (input_line_pointer, &input_line_pointer, 0);
		  else
		    {
		      c = get_symbol_name (& beg);
		      (void) restore_line_pointer (c);
		      type = obj_elf_section_type (beg,
						   input_line_pointer - beg,
						   true);
		    }
		}
	      else
		input_line_pointer = save;
	    }

	  SKIP_WHITESPACE ();
	  if (has_entsize && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      if (inherit && *input_line_pointer == ','
		  && ((bfd_section_flags (now_seg)
		       & (SEC_MERGE | SEC_STRINGS)) != 0
		      || now_seg->entsize))
		goto fetch_entsize;
	      if (is_end_of_stmt (*input_line_pointer)
		  && (bfd_section_flags (now_seg)
		      & (SEC_MERGE | SEC_STRINGS)) != 0)
		{
		  as_tsktsk (_("missing section entity size, 1 assumed"));
		  entsize = 1;
		}
	      else
		{
		  entsize = get_absolute_expression ();
		  SKIP_WHITESPACE ();
		  if (entsize <= 0)
		    {
		      as_warn (_("invalid section entity size"));
		      attr &= ~(SHF_MERGE | SHF_STRINGS);
		      has_entsize = false;
		      entsize = 0;
		    }
		}
	    }
	  else if (has_entsize && inherit
		    && ((bfd_section_flags (now_seg)
			 & (SEC_MERGE | SEC_STRINGS)) != 0
			|| now_seg->entsize))
	    {
	    fetch_entsize:
	      entsize = now_seg->entsize;
	    }
	  else if ((attr & SHF_MERGE) != 0)
	    {
	      as_warn (_("entity size for SHF_MERGE not specified"));
	      attr &= ~(SHF_MERGE | SHF_STRINGS);
	      has_entsize = false;
	    }
	  else if ((attr & SHF_STRINGS) != 0)
	    {
	      entsize = 1;
	    }
	  else if (has_entsize)
	    {
	      as_warn (_("entity size not specified"));
	      has_entsize = false;
	    }

	  if ((attr & (SHF_MERGE | SHF_STRINGS)) != 0 && type == SHT_NOBITS)
	    as_warn (_("bogus SHF_MERGE / SHF_STRINGS for SHT_NOBITS section"));

	  if ((attr & SHF_LINK_ORDER) != 0 && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      if (ISDIGIT (* input_line_pointer))
		{
		  linked_to_section_index = strtoul (input_line_pointer, & input_line_pointer, 0);
		}
	      else if (inherit && *input_line_pointer == ','
		       && (elf_section_flags (now_seg) & SHF_LINK_ORDER) != 0)
		goto fetch_linked_to;
	      else
		{
		  char c;
		  unsigned int length;

		  c = get_symbol_name (& beg);
		  (void) restore_line_pointer (c);
		  length = input_line_pointer - beg;
		  if (length)
		    match.linked_to_symbol_name
		      = notes_memdup (beg, length, length + 1);
		}
	    }
	  else if ((attr & SHF_LINK_ORDER) != 0 && inherit
		   && (elf_section_flags (now_seg) & SHF_LINK_ORDER) != 0)
	    {
	    fetch_linked_to:
	      if (now_seg->map_head.linked_to_symbol_name)
		match.linked_to_symbol_name =
		  now_seg->map_head.linked_to_symbol_name;
	      else
		linked_to_section_index =
		  elf_section_data (now_seg)->this_hdr.sh_link;
	    }

	  if ((attr & SHF_GROUP) != 0 && is_clone)
	    {
	      as_warn (_("? section flag ignored with G present"));
	      is_clone = false;
	    }

	  if ((attr & SHF_GROUP) != 0 && *input_line_pointer == ',')
	    {
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      if (inherit && *input_line_pointer == ','
		  && (elf_section_flags (now_seg) & SHF_GROUP) != 0)
		goto fetch_group;
	      match.group_name = obj_elf_section_name ();
	      if (match.group_name == NULL)
		attr &= ~SHF_GROUP;
	      else if (*input_line_pointer == ',')
		{
		  ++input_line_pointer;
		  SKIP_WHITESPACE ();
		  if (startswith (input_line_pointer, "comdat"))
		    {
		      input_line_pointer += 6;
		      linkonce = true;
		    }
		}
	      else if (startswith (name, ".gnu.linkonce"))
		linkonce = true;
	    }
	  else if ((attr & SHF_GROUP) != 0 && inherit
		   && (elf_section_flags (now_seg) & SHF_GROUP) != 0)
	    {
	    fetch_group:
	      match.group_name = elf_group_name (now_seg);
	      linkonce = (bfd_section_flags (now_seg) & SEC_LINK_ONCE) != 0;
	    }
	  else if ((attr & SHF_GROUP) != 0)
	    {
	      as_warn (_("group name for SHF_GROUP not specified"));
	      attr &= ~SHF_GROUP;
	    }

	  if (is_clone)
	    {
	      const char *now_group = elf_group_name (now_seg);
	      if (now_group != NULL)
		{
		  match.group_name = now_group;
		  linkonce = (now_seg->flags & SEC_LINK_ONCE) != 0;
		}
	    }

	  if ((gnu_attr & SHF_GNU_MBIND) != 0 && *input_line_pointer == ',')
	    {
	      char *save = input_line_pointer;
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      if (ISDIGIT (* input_line_pointer))
		{
		  char *t = input_line_pointer;
		  match.sh_info = strtoul (input_line_pointer,
					&input_line_pointer, 0);
		  if (match.sh_info == -1u)
		    {
		      as_warn (_("unsupported mbind section info: %s"), t);
		      match.sh_info = 0;
		    }
		}
	      else
		input_line_pointer = save;
	    }

	  if ((gnu_attr & SHF_GNU_RETAIN) != 0)
	    match.sh_flags |= SHF_GNU_RETAIN;

	  if (*input_line_pointer == ',')
	    {
	      char *save = input_line_pointer;

	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      if (startswith (input_line_pointer, "unique"))
		{
		  input_line_pointer += 6;
		  SKIP_WHITESPACE ();
		  if (*input_line_pointer == ',')
		    {
		      ++input_line_pointer;
		      SKIP_WHITESPACE ();
		      if (ISDIGIT (* input_line_pointer))
			{
			  bfd_vma id;
			  bool overflow;
			  char *t = input_line_pointer;
			  if (sizeof (bfd_vma) <= sizeof (unsigned long))
			    {
			      errno = 0;
			      id = strtoul (input_line_pointer,
					    &input_line_pointer, 0);
			      overflow = id == -1ul && errno == ERANGE;
			    }
			  else
			    {
			      id = bfd_scan_vma
				(input_line_pointer,
				 (const char **) &input_line_pointer, 0);
			      overflow = id == ~(bfd_vma) 0;
			    }
			  if (overflow || id > -1u)
			    {
			      char *linefeed, saved_char = 0;
			      if ((linefeed = strchr (t, '\n')) != NULL)
				{
				  saved_char = *linefeed;
				  *linefeed = '\0';
				}
			      as_bad (_("unsupported section id: %s"), t);
			      if (saved_char)
				*linefeed = saved_char;
			    }
			  else
			    {
			      match.section_id = id;
			      match.flags |= SEC_ASSEMBLER_SECTION_ID;
			    }
			}
		    }
		}
	      else
		input_line_pointer = save;
	    }
	}
#ifdef TC_SPARC
      else
	{
	  do
	    {
	      char c;

	      SKIP_WHITESPACE ();
	      if (*input_line_pointer != '#')
		{
		  as_bad (_("character following name is not '#'"));
		  ignore_rest_of_line ();
		  return;
		}
	      ++input_line_pointer;
	      c = get_symbol_name (& beg);
	      (void) restore_line_pointer (c);

	      attr |= obj_elf_section_word (beg, input_line_pointer - beg,
					    &type);

	      SKIP_WHITESPACE ();
	    }
	  while (*input_line_pointer++ == ',');
	  --input_line_pointer;
	}
#endif
    }

 done:
  demand_empty_rest_of_line ();

  if ((gnu_attr & (SHF_GNU_MBIND | SHF_GNU_RETAIN)) != 0)
    {
      bool mbind_p = (gnu_attr & SHF_GNU_MBIND) != 0;

      if (mbind_p && (attr & SHF_ALLOC) == 0)
	as_bad (_("SHF_ALLOC isn't set for GNU_MBIND section: %s"), name);

      if (mbind_p)
	elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_mbind;
      if ((gnu_attr & SHF_GNU_RETAIN) != 0)
	elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_retain;

      attr |= gnu_attr;
    }

  change_section (name, type, attr, entsize, &match, linkonce, push,
		  new_subsection);

  if (linked_to_section_index != -1UL)
    {
      elf_section_flags (now_seg) |= SHF_LINK_ORDER;
      elf_section_data (now_seg)->this_hdr.sh_link = linked_to_section_index;
    }
}

/* Change to the .bss section.  */

void
obj_elf_bss(int i ATTRIBUTE_UNUSED)
{
  (void)i;

#ifdef md_flush_pending_output
  md_flush_pending_output();
#endif

  obj_elf_section_change_hook();

  subseg_set(bss_section, get_absolute_expression());
  demand_empty_rest_of_line();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook();
#endif
}

/* Change to the .data section.  */

static void call_md_flush_pending_output(void)
{
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif
}

static void call_md_elf_section_change_hook(void)
{
#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

void obj_elf_data(int section_index)
{
    call_md_flush_pending_output();
    obj_elf_section_change_hook();
    s_data(section_index);
    call_md_elf_section_change_hook();
}

/* Change to the .text section.  */

static void elf_flush_pending_output_if_needed(void)
{
#ifdef md_flush_pending_output
  md_flush_pending_output();
#endif
}

static void elf_section_change_hook_if_needed(void)
{
#ifdef md_elf_section_change_hook
  md_elf_section_change_hook();
#endif
}

void obj_elf_text(int i)
{
  elf_flush_pending_output_if_needed();
  obj_elf_section_change_hook();
  s_text(i);
  elf_section_change_hook_if_needed();
}

/* Change to the *ABS* section.  */

static void call_md_flush_pending_output(void)
{
#ifdef md_flush_pending_output
    md_flush_pending_output();
#endif
}

static void call_md_elf_section_change_hook(void)
{
#ifdef md_elf_section_change_hook
    md_elf_section_change_hook();
#endif
}

void obj_elf_struct(int i)
{
    call_md_flush_pending_output();
    obj_elf_section_change_hook();
    s_struct(i);
    call_md_elf_section_change_hook();
}

static void
obj_elf_subsection(int ignore ATTRIBUTE_UNUSED)
{
    (void)ignore;

#if defined(md_flush_pending_output)
    md_flush_pending_output();
#endif

    obj_elf_section_change_hook();

    const int subsection = get_absolute_expression();
    subseg_set(now_seg, subsection);
    demand_empty_rest_of_line();

#if defined(md_elf_section_change_hook)
    md_elf_section_change_hook();
#endif
}

/* This can be called from the processor backends if they change
   sections.  */

void
obj_elf_section_change_hook(void)
{
    if (previous_section == now_seg && previous_subsection == now_subseg) {
        return;
    }
    previous_section = now_seg;
    previous_subsection = now_subseg;
}

void
obj_elf_previous (int ignore ATTRIBUTE_UNUSED)
{
  segT target_section;
  int target_subsection;

  (void) ignore;

  if (previous_section == 0)
    {
      as_warn (_(".previous without corresponding .section; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  target_section = previous_section;
  target_subsection = previous_subsection;
  obj_elf_section_change_hook ();

  subseg_set (target_section, target_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_popsection (int unused ATTRIBUTE_UNUSED)
{
  struct section_stack *node = section_stack;

  if (node == NULL)
    {
      as_warn (_(".popsection without corresponding .pushsection; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  section_stack = node->next;
  previous_section = node->prev_seg;
  previous_subsection = node->prev_subseg;
  subseg_set (node->seg, node->subseg);
  free (node);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_line (int unused ATTRIBUTE_UNUSED)
{
  (void) unused;
  new_logical_line(NULL, get_absolute_expression());
  demand_empty_rest_of_line();
}

static struct elf_versioned_name_list *
obj_elf_find_and_add_versioned_name(const char *version_name,
                                    const char *sym_name,
                                    const char *ver,
                                    struct elf_obj_sy *sy_obj)
{
  if (version_name == NULL || sym_name == NULL || ver == NULL || sy_obj == NULL)
    return NULL;

  const char *p = ver;
  while (*p == ELF_VER_CHR)
    ++p;

  int at_count = (int)(p - ver);
  struct elf_versioned_name_list *versioned_name = sy_obj->versioned_name;

  switch (at_count)
    {
    case 1:
    case 2:
      break;
    case 3:
      if (sy_obj->rename)
        {
          if (versioned_name != NULL
              && strcmp(versioned_name->name, version_name) == 0)
            return versioned_name;

          as_bad(_("only one version name with `@@@' is allowed for symbol `%s'"),
                 sym_name);
          return NULL;
        }
      sy_obj->rename = true;
      break;
    default:
      as_bad(_("invalid version name '%s' for symbol `%s'"),
             version_name, sym_name);
      return NULL;
    }

  while (versioned_name != NULL)
    {
      if (strcmp(versioned_name->name, version_name) == 0)
        return versioned_name;
      versioned_name = versioned_name->next;
    }

  char *dup_name = notes_strdup(version_name);
  if (dup_name == NULL)
    {
      as_bad(_("out of memory"));
      return NULL;
    }

  struct elf_versioned_name_list *new_node = notes_alloc(sizeof(*new_node));
  if (new_node == NULL)
    {
      as_bad(_("out of memory"));
      return NULL;
    }

  new_node->name = dup_name;
  new_node->next = sy_obj->versioned_name;
  sy_obj->versioned_name = new_node;

  return new_node;
}

/* This handles the .symver pseudo-op, which is used to specify a
   symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.
   SYMVERNAME may contain ELF_VER_CHR ('@') characters.  This
   pseudo-op causes the assembler to emit a symbol named SYMVERNAME
   with the same value as the symbol NAME.  */

static void
obj_elf_symver (int ignore ATTRIBUTE_UNUSED)
{
  char *versioned_name;
  const char *base_sym_name;
  char term_ch;
  char prev_lex_at;
  symbolS *sym;
  struct elf_obj_sy *sy_obj;
  char *version_sep;

  sym = get_sym_from_input_line_and_check ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .symver"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  prev_lex_at = lex_type[(unsigned char) '@'];
  lex_type[(unsigned char) '@'] |= LEX_NAME;
  term_ch = get_symbol_name (&versioned_name);
  lex_type[(unsigned char) '@'] = prev_lex_at;

  base_sym_name = S_GET_NAME (sym);

  if (S_IS_COMMON (sym))
    {
      as_bad (_("`%s' can't be versioned to common symbol '%s'"),
	      versioned_name, base_sym_name);
      ignore_rest_of_line ();
      return;
    }

  version_sep = strchr (versioned_name, ELF_VER_CHR);
  if (version_sep == NULL)
    {
      as_bad (_("missing version name in `%s' for symbol `%s'"),
	      versioned_name, base_sym_name);
      ignore_rest_of_line ();
      return;
    }

  sy_obj = symbol_get_obj (sym);
  if (obj_elf_find_and_add_versioned_name (versioned_name, base_sym_name,
					   version_sep, sy_obj) == NULL)
    {
      sy_obj->bad_version = true;
      ignore_rest_of_line ();
      return;
    }

  (void) restore_line_pointer (term_ch);

  if (*input_line_pointer == ',')
    {
      char *save = input_line_pointer;
      static const struct
      {
	const char *tok;
	unsigned int len;
	unsigned int vis;
      } opts[] =
      {
	{ "local",  5u, visibility_local },
	{ "hidden", 6u, visibility_hidden },
	{ "remove", 6u, visibility_remove }
      };
      size_t i;

      ++input_line_pointer;
      SKIP_WHITESPACE ();

      for (i = 0; i < sizeof (opts) / sizeof (opts[0]); ++i)
	{
	  if (startswith (input_line_pointer, opts[i].tok))
	    {
	      input_line_pointer += opts[i].len;
	      sy_obj->visibility = opts[i].vis;
	      break;
	    }
	}

      if (i == sizeof (opts) / sizeof (opts[0]))
	input_line_pointer = save;
    }

  demand_empty_rest_of_line ();
}

/* This handles the .vtable_inherit pseudo-op, which is used to indicate
   to the linker the hierarchy in which a particular table resides.  The
   syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */

struct fix *
obj_elf_get_vtable_inherit(void)
{
  char *child_name = NULL;
  char *parent_name = NULL;
  symbolS *child = NULL;
  symbolS *parent = NULL;
  char term;
  int has_error = 0;

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  term = get_symbol_name(&child_name);
  child = symbol_find(child_name);
  restore_line_pointer(term);

  if (child == NULL || symbol_get_frag(child) == NULL)
    {
      as_bad(_("expected `%s' to have already been set for .vtable_inherit"), child_name);
      has_error = 1;
    }

  SKIP_WHITESPACE();
  if (*input_line_pointer != ',')
    {
      as_bad(_("expected comma after name in .vtable_inherit"));
      ignore_rest_of_line();
      return NULL;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE();

  if (*input_line_pointer == '#')
    ++input_line_pointer;

  if (input_line_pointer[0] == '0'
      && (is_end_of_stmt(input_line_pointer[1]) || is_whitespace(input_line_pointer[1])))
    {
      parent = section_symbol(absolute_section);
      ++input_line_pointer;
    }
  else
    {
      term = get_symbol_name(&parent_name);
      parent = symbol_find_or_make(parent_name);
      restore_line_pointer(term);
    }

  demand_empty_rest_of_line();

  if (has_error)
    return NULL;

  {
    expressionS *exp = symbol_get_value_expression(child);
    gas_assert(exp->X_op == O_constant);
    return fix_new(symbol_get_frag(child),
                   exp->X_add_number,
                   0,
                   parent,
                   0,
                   0,
                   BFD_RELOC_VTABLE_INHERIT);
  }
}

/* This is a version of obj_elf_get_vtable_inherit() that is
   suitable for use in struct _pseudo_type tables.  */

void obj_elf_vtable_inherit(int ignore ATTRIBUTE_UNUSED)
{
    (void)ignore;
    (void)obj_elf_get_vtable_inherit();
}

/* This handles the .vtable_entry pseudo-op, which is used to indicate
   to the linker that a vtable slot was used.  The syntax is
   ".vtable_entry tablename, offset".  */

static inline void
skip_optional_hash (void)
{
  if (input_line_pointer != NULL && *input_line_pointer == '#')
    ++input_line_pointer;
}

struct fix *
obj_elf_get_vtable_entry (void)
{
  symbolS *sym;
  offsetT offset;

  skip_optional_hash ();

  sym = get_sym_from_input_line_and_check ();

  if (input_line_pointer == NULL || *input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .vtable_entry"));
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;

  skip_optional_hash ();

  offset = get_absolute_expression ();

  demand_empty_rest_of_line ();

  return fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
                  BFD_RELOC_VTABLE_ENTRY);
}

/* This is a version of obj_elf_get_vtable_entry() that is
   suitable for use in struct _pseudo_type tables.  */

void obj_elf_vtable_entry(int ignore)
{
    (void)ignore;
    (void)obj_elf_get_vtable_entry();
}

#define skip_whitespace(str)  do { if (is_whitespace (*(str))) ++(str); } while (0)

static inline int
skip_past_char(char **str, char c)
{
  if (str == NULL || *str == NULL)
    return -1;

  if (**str == c)
    {
      (*str)++;
      return 0;
    }

  return -1;
}
#define skip_past_comma(str) skip_past_char (str, ',')

/* A list of attributes that have been explicitly set by the assembly code.
   VENDOR is the vendor id, BASE is the tag shifted right by the number
   of bits in MASK, and bit N of MASK is set if tag BASE+N has been set.  */
struct recorded_attribute_info {
  struct recorded_attribute_info *next;
  int vendor;
  unsigned int base;
  unsigned long mask;
};
static struct recorded_attribute_info *recorded_attributes;

/* Record that we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

#include <limits.h>

static void record_attribute(int vendor, unsigned int tag)
{
    struct recorded_attribute_info *rai;
    const unsigned int mask_bits = (unsigned int)(CHAR_BIT * sizeof(((struct recorded_attribute_info *)0)->mask));
    const unsigned int base = tag / mask_bits;
    const unsigned long mask = 1UL << (tag % mask_bits);

    for (rai = recorded_attributes; rai != NULL; rai = rai->next) {
        if (rai->vendor == vendor && rai->base == base) {
            rai->mask |= mask;
            return;
        }
    }

    rai = XNEW(struct recorded_attribute_info);
    rai->next = recorded_attributes;
    rai->vendor = vendor;
    rai->base = base;
    rai->mask = mask;
    recorded_attributes = rai;
}

/* Return true if we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

bool
obj_elf_seen_attribute (int vendor, unsigned int tag)
{
  struct recorded_attribute_info *rai;
  unsigned int bits_per_mask = 8U * (unsigned int) sizeof (rai->mask);
  unsigned int base = tag / bits_per_mask;
  unsigned int offset = tag % bits_per_mask;
  unsigned long bitmask = 1UL << offset;

  for (rai = recorded_attributes; rai != NULL; rai = rai->next)
    if (rai->vendor == vendor && rai->base == base)
      return (rai->mask & bitmask) != 0UL;

  return false;
}

/* Parse an attribute directive for VENDOR.
   Returns the attribute number read, or zero on error.  */

int
obj_elf_vendor_attribute (int vendor)
{
  expressionS exp;
  int type;
  int tag;
  unsigned int int_val = 0;
  char *str_val = NULL;

  skip_whitespace (input_line_pointer);
  char *token_start = input_line_pointer;

  if (ISDIGIT (*input_line_pointer))
    {
      expression (&exp);
      if (exp.X_op != O_constant)
        {
          as_bad (_("expected <tag> , <value>"));
          ignore_rest_of_line ();
          return 0;
        }
      tag = exp.X_add_number;
    }
  else
    {
      unsigned int name_len = 0;
      for (; ISALNUM (*input_line_pointer) || *input_line_pointer == '_';
           ++input_line_pointer)
        name_len++;
      if (name_len == 0)
        {
          as_bad (_("expected <tag> , <value>"));
          ignore_rest_of_line ();
          return 0;
        }

      char *name = xmemdup0 (token_start, name_len);

#ifndef CONVERT_SYMBOLIC_ATTRIBUTE
#define CONVERT_SYMBOLIC_ATTRIBUTE(a) -1
#endif

      tag = CONVERT_SYMBOLIC_ATTRIBUTE (name);
      if (tag == -1)
        {
          as_bad (_("Attribute name not recognised: %s"), name);
          ignore_rest_of_line ();
          free (name);
          return 0;
        }
      free (name);
    }

  type = _bfd_elf_obj_attrs_arg_type (stdoutput, vendor, tag);

  if (skip_past_comma (&input_line_pointer) == -1)
    {
      as_bad (_("expected <tag> , <value>"));
      ignore_rest_of_line ();
      return 0;
    }

  if (type & 1)
    {
      expression (&exp);
      if (exp.X_op != O_constant)
        {
          as_bad (_("expected numeric constant"));
          ignore_rest_of_line ();
          return 0;
        }
      int_val = exp.X_add_number;
    }

  if ((type & 3) == 3)
    {
      if (skip_past_comma (&input_line_pointer) == -1)
        {
          as_bad (_("expected comma"));
          ignore_rest_of_line ();
          return 0;
        }
    }

  if (type & 2)
    {
      int len;
      skip_whitespace (input_line_pointer);
      if (*input_line_pointer != '"')
        {
          as_bad (_("bad string constant"));
          ignore_rest_of_line ();
          return 0;
        }
      str_val = demand_copy_C_string (&len);
    }

  record_attribute (vendor, tag);

  int ok = 0;
  switch (type & 3)
    {
    case 3:
      ok = bfd_elf_add_obj_attr_int_string (stdoutput, vendor, tag, int_val, str_val);
      break;
    case 2:
      ok = bfd_elf_add_obj_attr_string (stdoutput, vendor, tag, str_val);
      break;
    case 1:
      ok = bfd_elf_add_obj_attr_int (stdoutput, vendor, tag, int_val);
      break;
    default:
      abort ();
    }

  if (!ok)
    as_fatal (_("error adding attribute: %s"),
              bfd_errmsg (bfd_get_error ()));

  demand_empty_rest_of_line ();
  return tag;
}

/* Parse a .gnu_attribute directive.  */

static void obj_elf_gnu_attribute(int ignored)
{
    (void)ignored;
    obj_elf_vendor_attribute(OBJ_ATTR_GNU);
}

void elf_obj_read_begin_hook(void)
{
#if defined(NEED_ECOFF_DEBUG) && defined(ECOFF_DEBUGGING)
    if (ECOFF_DEBUGGING != 0) {
        ecoff_read_begin_hook();
    }
#endif
}

void
elf_obj_symbol_new_hook (symbolS *symbolP)
{
  struct elf_obj_sy *sy_obj;

  if (symbolP == NULL)
    return;

  sy_obj = symbol_get_obj (symbolP);
  if (sy_obj != NULL)
    {
      sy_obj->size = NULL;
      sy_obj->versioned_name = NULL;
    }

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_symbol_new_hook (symbolP);
#endif
}

/* If size is unset, copy size from src.  Because we don't track whether
   .size has been used, we can't differentiate .size dest, 0 from the case
   where dest's size is unset.  */
void
elf_copy_symbol_size (symbolS *dest, symbolS *src)
{
  if (dest == NULL || src == NULL)
    return;

  struct elf_obj_sy *srcelf = symbol_get_obj (src);
  struct elf_obj_sy *destelf = symbol_get_obj (dest);

  if (destelf == NULL || srcelf == NULL)
    return;

  if (destelf->size != 0)
    return;

  if (S_GET_SIZE (dest) != 0)
    return;

  destelf->size = srcelf->size;
  S_SET_SIZE (dest, S_GET_SIZE (src));
}

void
elf_copy_symbol_attributes(symbolS *dest, symbolS *src)
{
  if (dest == NULL || src == NULL)
    return;

  elf_copy_symbol_size(dest, src);

  unsigned int dest_other = S_GET_OTHER(dest);
  unsigned int src_other = S_GET_OTHER(src);
  unsigned int visibility_bits = ELF_ST_VISIBILITY(dest_other);
  unsigned int non_visibility_mask = ~ELF_ST_VISIBILITY((unsigned int)-1);
  unsigned int combined_other = visibility_bits | (src_other & non_visibility_mask);

  S_SET_OTHER(dest, combined_other);
}

void
obj_elf_version (int ignore ATTRIBUTE_UNUSED)
{
  const char *name = NULL;
  unsigned int c;
  char *p;
  asection *saved_seg = now_seg;
  subsegT saved_subseg = now_subseg;
  Elf_Internal_Note i_note;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != '\"')
    {
      as_bad (_("expected quoted string"));
      demand_empty_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  name = input_line_pointer;

  while (is_a_char (c = next_char_of_string ()))
    ;

  {
    char curr = *input_line_pointer;
    if (input_line_pointer > name)
      *(input_line_pointer - 1) = '\0';
    *input_line_pointer = curr;
  }

  {
    asection *note_secp = subseg_new (".note", 0);
    if (note_secp == NULL)
      {
	subseg_set (saved_seg, saved_subseg);
	demand_empty_rest_of_line ();
	return;
      }
    bfd_set_section_flags (note_secp, SEC_HAS_CONTENTS | SEC_READONLY);
    record_alignment (note_secp, 2);
  }

  {
    unsigned int len = (unsigned int) (strlen (name) + 1);
    size_t namesz_size = sizeof (((Elf_External_Note *) 0)->namesz);
    size_t descsz_size = sizeof (((Elf_External_Note *) 0)->descsz);
    size_t type_size = sizeof (((Elf_External_Note *) 0)->type);

    i_note.namesz = len;
    i_note.descsz = 0;
    i_note.type = NT_VERSION;

    p = frag_more (namesz_size);
    md_number_to_chars (p, i_note.namesz, namesz_size);
    p = frag_more (descsz_size);
    md_number_to_chars (p, i_note.descsz, descsz_size);
    p = frag_more (type_size);
    md_number_to_chars (p, i_note.type, type_size);
    p = frag_more (len);
    memcpy (p, name, len);
  }

  frag_align (2, 0, 0);
  subseg_set (saved_seg, saved_subseg);
  demand_empty_rest_of_line ();
}

static void
obj_elf_size (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char delim = get_symbol_name (&name);
  char *line_pos = input_line_pointer;
  expressionS exp;
  symbolS *sym;

  restore_line_pointer (delim);
  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      char saved = *line_pos;
      *line_pos = 0;
      as_bad (_("expected comma after name `%s' in .size directive"), name);
      *line_pos = saved;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;
  expression (&exp);
  if (exp.X_op == O_absent)
    {
      as_bad (_("missing expression in .size directive"));
      exp.X_op = O_constant;
      exp.X_add_number = 0;
    }

  {
    char saved = *line_pos;
    *line_pos = 0;
    sym = symbol_find_or_make (name);
    *line_pos = saved;
  }

  if (exp.X_op == O_constant)
    {
      S_SET_SIZE (sym, exp.X_add_number);
      symbol_get_obj (sym)->size = NULL;
    }
  else
    {
      expressionS *sz = notes_alloc (sizeof (exp));
      symbol_get_obj (sym)->size = sz;
      *sz = exp;
    }

  if (flag_synth_cfi
      && S_IS_FUNCTION (sym)
      && sym == ginsn_data_func_symbol ())
    ginsn_data_end (symbol_temp_new_now ());

  demand_empty_rest_of_line ();
}

/* Handle the ELF .type pseudo-op.  This sets the type of a symbol.
   There are six syntaxes:

   The first (used on Solaris) is
       .type SYM,#function
   The second (used on UnixWare) is
       .type SYM,@function
   The third (reportedly to be used on Irix 6.0) is
       .type SYM STT_FUNC
   The fourth (used on NetBSD/Arm and Linux/ARM) is
       .type SYM,%function
   The fifth (used on SVR4/860) is
       .type SYM,"function"
   The sixth (emitted by recent SunPRO under Solaris) is
       .type SYM,[0-9]
   where the integer is the STT_* value.
   */

static char *
obj_elf_type_name(char *cp)
{
  if (cp == NULL || input_line_pointer == NULL)
    return NULL;

  char *start = input_line_pointer;

  if (*start >= '0' && *start <= '9')
    {
      char *cur = start;

      while (*cur >= '0' && *cur <= '9')
        ++cur;

      *cp = *cur;
      *cur = '\0';
      input_line_pointer = cur;

      return start;
    }
  else
    {
      *cp = get_symbol_name(&start);
      return start;
    }
}

static int type_matches(const char *type_name, const char *a, const char *b, const char *c) {
  return (strcmp(type_name, a) == 0)
      || (strcmp(type_name, b) == 0)
      || (strcmp(type_name, c) == 0);
}

static void handle_common_symbol(symbolS **psym) {
  symbolS *sym = *psym;

  if (!S_IS_COMMON(sym)) {
    if (S_IS_VOLATILE(sym)) {
      sym = symbol_clone(sym, 1);
      S_SET_SEGMENT(sym, bfd_com_section_ptr);
      S_SET_VALUE(sym, 0);
      S_SET_EXTERNAL(sym);
      symbol_set_frag(sym, &zero_address_frag);
      S_CLEAR_VOLATILE(sym);
      *psym = sym;
    } else if (S_IS_DEFINED(sym) || symbol_equated_p(sym)) {
      as_bad(_("symbol '%s' is already defined"), S_GET_NAME(sym));
    } else {
      S_SET_SEGMENT(sym, bfd_com_section_ptr);
      S_SET_VALUE(sym, 0);
      S_SET_EXTERNAL(sym);
    }
  }
}

static void
obj_elf_type (int ignore ATTRIBUTE_UNUSED)
{
  char c;
  int type;
  const char *type_name;
  symbolS *sym;
  elf_symbol_type *elfsym;

  sym = get_sym_from_input_line_and_check ();
  c = *input_line_pointer;
  elfsym = (elf_symbol_type *) symbol_get_bfdsym (sym);

  if (*input_line_pointer == ',')
    ++input_line_pointer;

  SKIP_WHITESPACE ();
  if (   *input_line_pointer == '#'
      || *input_line_pointer == '@'
      || *input_line_pointer == '"'
      || *input_line_pointer == '%')
    ++input_line_pointer;

  type_name = obj_elf_type_name (&c);

  type = 0;
  if (type_matches(type_name, "function", "2", "STT_FUNC"))
    type = BSF_FUNCTION;
  else if (type_matches(type_name, "object", "1", "STT_OBJECT"))
    type = BSF_OBJECT;
  else if (type_matches(type_name, "tls_object", "6", "STT_TLS"))
    type = BSF_OBJECT | BSF_THREAD_LOCAL;
  else if (type_matches(type_name, "notype", "0", "STT_NOTYPE"))
    ;
  else if (type_matches(type_name, "common", "5", "STT_COMMON"))
    {
      type = BSF_OBJECT;
      handle_common_symbol(&sym);
    }
  else if (type_matches(type_name, "gnu_indirect_function", "10", "STT_GNU_IFUNC"))
    {
      const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
      if (bed->elf_osabi != ELFOSABI_NONE
          && bed->elf_osabi != ELFOSABI_GNU
          && bed->elf_osabi != ELFOSABI_FREEBSD)
        as_bad (_("symbol type \"%s\" is supported only by GNU "
                  "and FreeBSD targets"), type_name);
      else if (bed->target_id == MIPS_ELF_DATA)
        as_bad (_("symbol type \"%s\" is not supported by "
                  "MIPS targets"), type_name);
      elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
      type = BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION;
    }
  else if (strcmp (type_name, "gnu_unique_object") == 0)
    {
      const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
      if (bed->elf_osabi != ELFOSABI_NONE
          && bed->elf_osabi != ELFOSABI_GNU)
        as_bad (_("symbol type \"%s\" is supported only by GNU targets"),
                type_name);
      elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_unique;
      type = BSF_OBJECT | BSF_GNU_UNIQUE;
    }
#ifdef md_elf_symbol_type
  else if ((type = md_elf_symbol_type (type_name, sym, elfsym)) != -1)
    ;
#endif
  else
    as_bad (_("unrecognized symbol type \"%s\""), type_name);

  *input_line_pointer = c;

  if (*input_line_pointer == '"')
    ++input_line_pointer;

#ifdef md_elf_symbol_type_change
  if (!md_elf_symbol_type_change (sym, elfsym, type))
#endif
    {
      flagword mask = BSF_FUNCTION | BSF_OBJECT;

      if (type != BSF_FUNCTION)
        mask |= BSF_GNU_INDIRECT_FUNCTION;
      if (type != BSF_OBJECT)
        {
          mask |= BSF_GNU_UNIQUE | BSF_THREAD_LOCAL;

          if (S_IS_COMMON (sym))
            {
              as_bad (_("cannot change type of common symbol '%s'"),
                      S_GET_NAME (sym));
              mask = type = 0;
            }
        }

      if (type)
        {
          flagword new_flags = (elfsym->symbol.flags & ~mask) | (flagword) type;

          if (new_flags != (elfsym->symbol.flags | (flagword) type))
            as_warn (_("symbol '%s' already has its type set"), S_GET_NAME (sym));
          elfsym->symbol.flags = new_flags;
        }
      else
        elfsym->symbol.flags &= ~mask;
    }

  if (S_IS_FUNCTION (sym) && flag_synth_cfi)
    {
      if (frchain_now->frch_ginsn_data)
        ginsn_data_end (symbol_temp_new_now ());
      ginsn_data_begin (sym);
    }

  demand_empty_rest_of_line ();
}

static segT comment_section;

static void
obj_elf_ident (int ignored ATTRIBUTE_UNUSED)
{
  segT old_section = now_seg;
  int old_subsection = now_subseg;

#ifdef md_flush_pending_output
  md_flush_pending_output();
#endif

  if (!comment_section)
    {
      comment_section = subseg_new(".comment", 0);
      if (!comment_section)
        goto restore;

      if (!bfd_set_section_flags(comment_section, (SEC_READONLY | SEC_HAS_CONTENTS | SEC_MERGE | SEC_STRINGS)))
        goto restore;

      comment_section->entsize = 1;
#ifdef md_elf_section_change_hook
      md_elf_section_change_hook();
#endif
      {
        char *p = frag_more(1);
        if (p)
          *p = 0;
      }
    }
  else
    {
      subseg_set(comment_section, 0);
#ifdef md_elf_section_change_hook
      md_elf_section_change_hook();
#endif
    }

  stringer(9);

restore:
  subseg_set(old_section, old_subsection);
#ifdef md_elf_section_change_hook
  md_elf_section_change_hook();
#endif
}

#ifdef INIT_STAB_SECTION

/* The first entry in a .stabs section is special.  */

void
obj_elf_init_stab_section (segT stab, segT stabstr)
{
  char *file;
  char *p;
  unsigned int stroff;

  /* Force the section to align to a longword boundary.  Without this,
     UnixWare ar crashes.  */
  bfd_set_section_alignment (stab, 2);

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  file = remap_debug_filename (as_where (NULL));
  stroff = get_stab_string_offset (file, stabstr);
  know (stroff == 1 || (stroff == 0 && file[0] == '\0'));
  md_number_to_chars (p, stroff, 4);
  seg_info (stab)->stabu.p = p;
  free (file);
}

#endif

/* Called via bfd_map_over_sections.  If SEC's linked_to_symbol_name
   isn't NULL, set up its linked-to section.
   For .stabs section, fill in the counts in the first entry.  */

static void
set_additional_section_info (bfd *abfd, asection *sec, void *inf ATTRIBUTE_UNUSED)
{
  if (sec->map_head.linked_to_symbol_name)
    {
      symbolS *linked_to_sym = symbol_find (sec->map_head.linked_to_symbol_name);
      if (!linked_to_sym || !S_IS_DEFINED (linked_to_sym))
        as_bad (_("undefined linked-to symbol `%s' on section `%s'"),
                sec->map_head.linked_to_symbol_name, bfd_section_name (sec));
      else
        elf_linked_to_section (sec) = S_GET_SEGMENT (linked_to_sym);
    }

  if (!startswith (sec->name, ".stab"))
    return;

  {
    size_t name_len = strlen (sec->name);
    if (name_len >= 3 && strcmp ("str", sec->name + name_len - 3) == 0)
      return;
  }

  {
    enum { STAB_ENTRY_SIZE = 12, NSYMS_OFFSET = 6, STRSZ_OFFSET = 8 };
    char *strsec_name = concat (sec->name, "str", (const char *) NULL);
    asection *strsec;
    int strsz, nsyms;
    char *p;

    if (!strsec_name)
      return;

    strsec = bfd_get_section_by_name (abfd, strsec_name);
    strsz = strsec ? (int) bfd_section_size (strsec) : 0;
    nsyms = (int) (bfd_section_size (sec) / STAB_ENTRY_SIZE) - 1;

    p = seg_info (sec)->stabu.p;
    gas_assert (p != 0);

    bfd_h_put_16 (abfd, nsyms, p + NSYMS_OFFSET);
    bfd_h_put_32 (abfd, strsz, p + STRSZ_OFFSET);

    free (strsec_name);
  }
}

#ifdef NEED_ECOFF_DEBUG

/* This function is called by the ECOFF code.  It is supposed to
   record the external symbol information so that the backend can
   write it out correctly.  The ELF backend doesn't actually handle
   this at the moment, so we do it ourselves.  We save the information
   in the symbol.  */

#ifdef OBJ_MAYBE_ELF
static
#endif
void
elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)
{
  symbol_get_bfdsym (sym)->udata.p = ext;
}

/* This function is called by bfd_ecoff_debug_externals.  It is
   supposed to *EXT to the external symbol information, and return
   whether the symbol should be used at all.  */

static bool
elf_get_extr (asymbol *sym, EXTR *ext)
{
  if (sym->udata.p == NULL)
    return false;
  *ext = *(EXTR *) sym->udata.p;
  return true;
}

/* This function is called by bfd_ecoff_debug_externals.  It has
   nothing to do for ELF.  */

static void
elf_set_index (asymbol *sym ATTRIBUTE_UNUSED,
	       bfd_size_type indx ATTRIBUTE_UNUSED)
{
}

#endif /* NEED_ECOFF_DEBUG */

void
elf_frob_symbol (symbolS *symp, int *puntp)
{
  struct elf_obj_sy *sy_obj;
  expressionS *size;
  struct elf_versioned_name_list *versioned_name;
  const char *sym_name;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_frob_symbol (symp);
#endif

  if (symp == NULL || puntp == NULL)
    return;

  sy_obj = symbol_get_obj (symp);
  if (sy_obj == NULL)
    return;

  sym_name = S_GET_NAME (symp);

  size = sy_obj->size;
  if (size != NULL)
    {
      int is_const = resolve_expression (size) && size->X_op == O_constant;
      if (is_const)
        S_SET_SIZE (symp, size->X_add_number);
      else
        {
          if (!flag_allow_nonconst_size)
            as_bad (_(".size expression for %s does not evaluate to a constant"), sym_name);
          else
            as_warn (_(".size expression for %s does not evaluate to a constant"), sym_name);
        }
      sy_obj->size = NULL;
    }

  versioned_name = sy_obj->versioned_name;
  if (versioned_name)
    {
      if (sy_obj->bad_version)
        *puntp = true;
      else if (sy_obj->rename)
        S_SET_NAME (symp, versioned_name->name);
      else if (S_IS_COMMON (symp))
        {
          as_bad (_("`%s' can't be versioned to common symbol '%s'"),
                  versioned_name->name, sym_name);
          *puntp = true;
        }
      else
        {
          symbolS *base_symp = symp;

          for (; versioned_name != NULL; versioned_name = versioned_name->next)
            {
              symbolS *symp2 = symbol_find_or_make (versioned_name->name);
              fragS *frag = symbol_get_frag (base_symp);
              valueT base_val = S_GET_VALUE (base_symp);
              addressT frag_addr = frag ? frag->fr_address : 0;

              S_SET_SEGMENT (symp2, S_GET_SEGMENT (base_symp));
              S_SET_VALUE (symp2, base_val - (frag_addr / OCTETS_PER_BYTE));
              symbol_set_frag (symp2, frag);

              copy_symbol_attributes (symp2, base_symp);
              S_SET_OTHER (symp2, S_GET_OTHER (base_symp));

              if (S_IS_WEAK (base_symp))
                S_SET_WEAK (symp2);

              if (S_IS_EXTERNAL (base_symp))
                S_SET_EXTERNAL (symp2);
            }

          switch (sy_obj->visibility)
            {
            case visibility_unchanged:
              break;
            case visibility_hidden:
              {
                asymbol *bfdsym = symbol_get_bfdsym (symp);
                elf_symbol_type *elfsym = elf_symbol_from (bfdsym);
                elfsym->internal_elf_sym.st_other &= ~3;
                elfsym->internal_elf_sym.st_other |= STV_HIDDEN;
                break;
              }
            case visibility_remove:
              if (symbol_used_in_reloc_p (symp))
                {
                  if (sy_obj->versioned_name->next != NULL)
                    as_bad (_("symbol '%s' with multiple versions cannot be used in relocation"),
                            sym_name);
                  symbol_mark_removed (symp);
                }
              else
                symbol_remove (symp, &symbol_rootP, &symbol_lastP);
              break;
            case visibility_local:
              S_CLEAR_EXTERNAL (symp);
              break;
            }
        }
    }

  if (S_IS_WEAK (symp) && S_IS_COMMON (symp))
    as_bad (_("symbol `%s' can not be both weak and common"), sym_name);
}

/* Fix up SYMPP which has been marked to be removed by .symver.  */

void
elf_fixup_removed_symbol(symbolS **sympp)
{
  if (sympp == NULL || *sympp == NULL)
    return;

  symbolS *symp = *sympp;
  struct elf_obj_sy *sy_obj = symbol_get_obj(symp);
  if (sy_obj == NULL || sy_obj->versioned_name == NULL || sy_obj->versioned_name->name == NULL)
    return;

  const char *name = sy_obj->versioned_name->name;
  symbolS *found = symbol_find(name);
  *sympp = found;
}

/* Create symbols for group signature.  */

void
elf_adjust_symtab (void)
{
  unsigned int i;

  for (i = 0; i < groups.num_group; i++)
    {
      asection *head = groups.head[i];
      const char *group_name;
      flagword flags;
      asection *group_sec;
      struct symbol *sy;

      if (head == NULL)
        continue;

      group_name = elf_group_name (head);

      flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;

      {
        int any_comdat = 0;
        asection *member;

        for (member = head; member != NULL; member = elf_next_in_group (member))
          {
            if ((member->flags & SEC_LINK_ONCE) != 0)
              {
                if (!any_comdat)
                  {
                    any_comdat = 1;
                    if (member != head)
                      {
                        as_warn (_("assuming all members of group `%s' are COMDAT"), group_name);
                        break;
                      }
                  }
              }
            else
              {
                if (any_comdat && member != head)
                  {
                    as_warn (_("assuming all members of group `%s' are COMDAT"), group_name);
                    break;
                  }
              }
          }

        if (any_comdat)
          flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
      }

      group_sec = subseg_force_new (".group", 0);
      if (group_sec == NULL
          || !bfd_set_section_flags (group_sec, flags)
          || !bfd_set_section_alignment (group_sec, 2))
        {
          as_fatal (_("can't create group: %s"),
                    bfd_errmsg (bfd_get_error ()));
        }
      elf_section_type (group_sec) = SHT_GROUP;

      elf_next_in_group (group_sec) = head;
      elf_sec_group (head) = group_sec;

      sy = symbol_find_exact (group_name);
      if (!sy || !symbol_on_chain (sy, symbol_rootP, symbol_lastP))
        {
          sy = symbol_new (group_name, now_seg, frag_now, 0);
          if (!sy)
            {
              as_fatal (_("can't create group: %s"),
                        bfd_errmsg (bfd_get_error ()));
            }
#ifdef TE_SOLARIS
          symbol_get_bfdsym (sy)->flags |= BSF_WEAK;
          S_SET_OTHER (sy, STV_HIDDEN);
#else
          symbol_get_obj (sy)->local = 1;
#endif
          symbol_table_insert (sy);
        }
      elf_group_id (group_sec) = symbol_get_bfdsym (sy);
      symbol_mark_used_in_reloc (sy);
    }
}

void elf_frob_file(void)
{
  if (stdoutput == NULL)
    return;

  bfd_map_over_sections(stdoutput, set_additional_section_info, NULL);

#ifdef elf_tc_final_processing
  elf_tc_final_processing();
#endif
}

/* It removes any unneeded versioned symbols from the symbol table.  */

void
elf_frob_file_before_adjust (void)
{
  symbolS *symp;

  if (!symbol_rootP)
    return;

  for (symp = symbol_rootP; symp; )
    {
      symbolS *next = symbol_next (symp);
      struct elf_obj_sy *sy_obj = symbol_get_obj (symp);
      int is_defined = S_IS_DEFINED (symp) ? 1 : 0;

      if (sy_obj && sy_obj->versioned_name)
        {
          char *vname = sy_obj->versioned_name->name;
          char *p = vname ? strchr (vname, ELF_VER_CHR) : NULL;

          if (sy_obj->rename && p && p[1] == ELF_VER_CHR && p[2] == ELF_VER_CHR)
            {
              size_t l = strlen (p + 3) + 1;
              memmove (p + 1 + is_defined, p + 3, l);
            }

          if (!is_defined)
            {
              if (p && !sy_obj->rename && p[1] == ELF_VER_CHR)
                {
                  as_bad (_("invalid attempt to declare external "
                            "version name as default in symbol `%s'"),
                          sy_obj->versioned_name->name);
                  return;
                }

              if (sy_obj->versioned_name->next)
                {
                  as_bad (_("multiple versions [`%s'|`%s'] for "
                            "symbol `%s'"),
                          sy_obj->versioned_name->name,
                          sy_obj->versioned_name->next->name,
                          S_GET_NAME (symp));
                  return;
                }

              sy_obj->rename = true;
            }
        }

      {
        int has_versioned_or_weak =
          (sy_obj && sy_obj->versioned_name) || S_IS_WEAK (symp);

        if (!is_defined
            && has_versioned_or_weak
            && symbol_used_p (symp) == 0
            && symbol_used_in_reloc_p (symp) == 0)
          symbol_remove (symp, &symbol_rootP, &symbol_lastP);
      }

      symp = next;
    }
}

/* It is required that we let write_relocs have the opportunity to
   optimize away fixups before output has begun, since it is possible
   to eliminate all fixups for a section and thus we never should
   have generated the relocation section.  */

void
elf_frob_file_after_relocs (void)
{
  unsigned int i;

  for (i = 0; i < groups.num_group; i++)
    {
      asection *head = groups.head[i];
      asection *s;
      asection *group;
      bfd_size_type size;

      if (head == NULL)
        continue;

      size = 4;
      for (s = head; s != NULL; s = elf_next_in_group (s))
        size += (s->flags & SEC_RELOC) ? 8 : 4;

      group = elf_sec_group (head);
      if (group == NULL)
        continue;

      subseg_set (group, 0);
      if (!bfd_set_section_size (group, size))
        as_fatal (_("failed to set SHT_GROUP section size: %s"),
                  bfd_errmsg (bfd_get_error ()));
      group->contents = (unsigned char *) frag_more (size);
      group->alloced = 1;
      frag_now->fr_fix = frag_now_fix_octets ();
      frag_wane (frag_now);
    }

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    {
      const struct ecoff_debug_swap *debug_swap;
      struct ecoff_debug_info debug;
      char *buf;
      asection *sec;

      debug_swap
        = get_elf_backend_data (stdoutput)->elf_backend_ecoff_debug_swap;
      know (debug_swap != NULL);
      ecoff_build_debug (&debug.symbolic_header, &buf, debug_swap);

      debug.alloc_syments = true;

      debug.line         = (unsigned char *) (buf + debug.symbolic_header.cbLineOffset);
      debug.external_dnr = (void *)          (buf + debug.symbolic_header.cbDnOffset);
      debug.external_pdr = (void *)          (buf + debug.symbolic_header.cbPdOffset);
      debug.external_sym = (void *)          (buf + debug.symbolic_header.cbSymOffset);
      debug.external_opt = (void *)          (buf + debug.symbolic_header.cbOptOffset);
      debug.external_aux = (union aux_ext *) (buf + debug.symbolic_header.cbAuxOffset);
      debug.ss           = (char *)          (buf + debug.symbolic_header.cbSsOffset);
      debug.external_fdr = (void *)          (buf + debug.symbolic_header.cbFdOffset);
      debug.external_rfd = (void *)          (buf + debug.symbolic_header.cbRfdOffset);

      debug.ssext = debug.ssext_end = NULL;
      debug.external_ext = debug.external_ext_end = NULL;
      if (! bfd_ecoff_debug_externals (stdoutput, &debug, debug_swap, true,
                                       elf_get_extr, elf_set_index))
        as_fatal (_("failed to set up debugging information: %s"),
                  bfd_errmsg (bfd_get_error ()));

      sec = bfd_get_section_by_name (stdoutput, ".mdebug");
      gas_assert (sec != NULL);

      know (!stdoutput->output_has_begun);

      if (!bfd_set_section_size (sec,
                                 bfd_ecoff_debug_size (stdoutput, &debug,
                                                       debug_swap)))
        as_fatal (_("failed to set .mdebug section size: %s"),
                  bfd_errmsg (bfd_get_error ()));

      if (! bfd_set_section_contents (stdoutput, sec, buf, 0, 0))
        as_fatal (_("can't start writing .mdebug section: %s"),
                  bfd_errmsg (bfd_get_error ()));

      know (stdoutput->output_has_begun);
      know (sec->filepos != 0);

      if (! bfd_ecoff_write_debug (stdoutput, &debug, debug_swap,
                                   sec->filepos))
        as_fatal (_("could not write .mdebug section: %s"),
                  bfd_errmsg (bfd_get_error ()));
    }
#endif
}

/* This is called when the assembler starts.  */

static void insert_section_symbol_if_exists(const char *name)
{
  asection *s;
  if (name == NULL)
    return;

  s = bfd_get_section_by_name(stdoutput, name);
  if (s != NULL)
    symbol_table_insert(section_symbol(s));
}

void
elf_begin(void)
{
  insert_section_symbol_if_exists(TEXT_SECTION_NAME);
  insert_section_symbol_if_exists(DATA_SECTION_NAME);
  insert_section_symbol_if_exists(BSS_SECTION_NAME);

  elf_com_section_ptr = bfd_com_section_ptr;
  previous_section = NULL;
  previous_subsection = 0;
  comment_section = NULL;
  memset(&groups, 0, sizeof(groups));
}

void
elf_end(void)
{
  while (section_stack)
    {
      struct section_stack *next = section_stack->next;
      free(section_stack);
      section_stack = next;
    }

  while (recorded_attributes)
    {
      struct recorded_attribute_info *next = recorded_attributes->next;
      free(recorded_attributes);
      recorded_attributes = next;
    }

  if (groups.indexes)
    {
      htab_delete(groups.indexes);
      groups.indexes = NULL;
    }

  free(groups.head);
  groups.head = NULL;
}

#ifdef USE_EMULATIONS

static bfd_vma
elf_s_get_size (symbolS *sym)
{
  return S_GET_SIZE (sym);
}

static void
elf_s_set_size (symbolS *sym, bfd_vma sz)
{
  S_SET_SIZE (sym, sz);
}

static bfd_vma
elf_s_get_align (symbolS *sym)
{
  return S_GET_ALIGN (sym);
}

static void
elf_s_set_align (symbolS *sym, bfd_vma align)
{
  S_SET_ALIGN (sym, align);
}

int
elf_s_get_other (symbolS *sym)
{
  return elf_symbol (symbol_get_bfdsym (sym))->internal_elf_sym.st_other;
}

static void
elf_s_set_other (symbolS *sym, int other)
{
  S_SET_OTHER (sym, other);
}

static int
elf_sec_sym_ok_for_reloc (asection *sec)
{
  return obj_sec_sym_ok_for_reloc (sec);
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_process_stab (int what ATTRIBUTE_UNUSED,
		  const char *string ATTRIBUTE_UNUSED,
		  int type ATTRIBUTE_UNUSED,
		  int other ATTRIBUTE_UNUSED,
		  int desc ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_stab (what, string, type, other, desc);
}
#else
# define elf_process_stab NULL
#endif

static int
elf_separate_stab_sections (void)
{
#ifdef NEED_ECOFF_DEBUG
  return (!ECOFF_DEBUGGING);
#else
  return 1;
#endif
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_init_stab_section (segT stab, segT stabstr)
{
  if (!ECOFF_DEBUGGING)
    obj_elf_init_stab_section (stab, stabstr);
}
#endif

const struct format_ops elf_format_ops =
{
  bfd_target_elf_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  elf_begin,
  elf_end,
  elf_file_symbol,
  NULL, /* assign_symbol */
  elf_frob_symbol,
  elf_frob_file,
  elf_frob_file_before_adjust,
  0,	/* obj_frob_file_before_fix */
  elf_frob_file_after_relocs,
  elf_s_get_size, elf_s_set_size,
  elf_s_get_align, elf_s_set_align,
  elf_s_get_other,
  elf_s_set_other,
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  elf_copy_symbol_attributes,
  elf_process_stab,
  elf_separate_stab_sections,
#ifdef NEED_ECOFF_DEBUG
  elf_init_stab_section,
#else
  obj_elf_init_stab_section,
#endif
  elf_sec_sym_ok_for_reloc,
  elf_pop_insert,
#ifdef NEED_ECOFF_DEBUG
  elf_ecoff_set_ext,
#else
  0,	/* ecoff_set_ext */
#endif
  elf_obj_read_begin_hook,
  elf_obj_symbol_new_hook,
  0,
  elf_adjust_symtab
};

#endif /* USE_EMULATIONS */
