/* ELF object file format
   Copyright (C) 1992-2025 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 3,
   or (at your option) any later version.

   GAS is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#define OBJ_HEADER "obj-elf.h"
#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "obstack.h"
#include "dwarf2dbg.h"
#include "ginsn.h"

#ifndef ECOFF_DEBUGGING
#define ECOFF_DEBUGGING 0
#else
#define NEED_ECOFF_DEBUG
#endif

#ifdef NEED_ECOFF_DEBUG
#include "ecoff.h"
#include "bfd/ecoff-bfd.h"
#endif

#ifdef TC_ALPHA
#include "elf/alpha.h"
#endif

#ifdef TC_MIPS
#include "elf/mips.h"
#endif

#ifdef TC_PPC
#include "elf/ppc.h"
#endif

#ifdef TC_I386
#include "elf/x86-64.h"
#endif

#ifdef TC_MEP
#include "elf/mep.h"
#endif

#ifdef TC_PRU
#include "elf/pru.h"
#endif

static void obj_elf_line (int);
static void obj_elf_size (int);
static void obj_elf_type (int);
static void obj_elf_ident (int);
static void obj_elf_weak (int);
static void obj_elf_local (int);
static void obj_elf_visibility (int);
static void obj_elf_symver (int);
static void obj_elf_subsection (int);
static void obj_elf_popsection (int);
static void obj_elf_gnu_attribute (int);
static void obj_elf_tls_common (int);
static void obj_elf_lcomm (int);
static void obj_elf_struct (int);
static void obj_elf_attach_to_group (int);

static const pseudo_typeS elf_pseudo_table[] =
{
  {"attach_to_group", obj_elf_attach_to_group, 0},
  {"comm", obj_elf_common, 0},
  {"common", obj_elf_common, 1},
  {"ident", obj_elf_ident, 0},
  {"lcomm", obj_elf_lcomm, 0},
  {"local", obj_elf_local, 0},
  {"previous", obj_elf_previous, 0},
  {"section", obj_elf_section, 0},
  {"section.s", obj_elf_section, 0},
  {"sect", obj_elf_section, 0},
  {"sect.s", obj_elf_section, 0},
  {"pushsection", obj_elf_section, 1},
  {"popsection", obj_elf_popsection, 0},
  {"size", obj_elf_size, 0},
  {"type", obj_elf_type, 0},
  {"version", obj_elf_version, 0},
  {"weak", obj_elf_weak, 0},

  /* These define symbol visibility.  */
  {"internal", obj_elf_visibility, STV_INTERNAL},
  {"hidden", obj_elf_visibility, STV_HIDDEN},
  {"protected", obj_elf_visibility, STV_PROTECTED},

  /* These are used for stabs-in-elf configurations.  */
  {"line", obj_elf_line, 0},

  /* This is a GNU extension to handle symbol versions.  */
  {"symver", obj_elf_symver, 0},

  /* A GNU extension to change subsection only.  */
  {"subsection", obj_elf_subsection, 0},

  /* These are GNU extensions to aid in garbage collecting C++ vtables.  */
  {"vtable_inherit", obj_elf_vtable_inherit, 0},
  {"vtable_entry", obj_elf_vtable_entry, 0},

  /* A GNU extension for object attributes.  */
  {"gnu_attribute", obj_elf_gnu_attribute, 0},

  /* These are used for dwarf2.  */
  { "file", dwarf2_directive_file, 0 },
  { "loc",  dwarf2_directive_loc,  0 },
  { "loc_mark_labels", dwarf2_directive_loc_mark_labels, 0 },

  /* We need to trap the section changing calls to handle .previous.  */
  {"data", obj_elf_data, 0},
  {"offset", obj_elf_struct, 0},
  {"struct", obj_elf_struct, 0},
  {"text", obj_elf_text, 0},
  {"bss", obj_elf_bss, 0},

  {"tls_common", obj_elf_tls_common, 0},

  /* End sentinel.  */
  {NULL, NULL, 0},
};

static const pseudo_typeS ecoff_debug_pseudo_table[] =
{
#ifdef NEED_ECOFF_DEBUG
  /* COFF style debugging information for ECOFF. .ln is not used; .loc
     is used instead.  */
  { "def",	ecoff_directive_def,	0 },
  { "dim",	ecoff_directive_dim,	0 },
  { "endef",	ecoff_directive_endef,	0 },
  { "file",	ecoff_directive_file,	0 },
  { "scl",	ecoff_directive_scl,	0 },
  { "tag",	ecoff_directive_tag,	0 },
  { "val",	ecoff_directive_val,	0 },

  /* COFF debugging requires pseudo-ops .size and .type, but ELF
     already has meanings for those.  We use .esize and .etype
     instead.  These are only generated by gcc anyhow.  */
  { "esize",	ecoff_directive_size,	0 },
  { "etype",	ecoff_directive_type,	0 },

  /* ECOFF specific debugging information.  */
  { "aent",	ecoff_directive_ent,	1 },
  { "begin",	ecoff_directive_begin,	0 },
  { "bend",	ecoff_directive_bend,	0 },
  { "end",	ecoff_directive_end,	0 },
  { "ent",	ecoff_directive_ent,	0 },
  { "fmask",	ecoff_directive_fmask,	0 },
  { "frame",	ecoff_directive_frame,	0 },
  { "loc",	ecoff_directive_loc,	0 },
  { "mask",	ecoff_directive_mask,	0 },

  /* Other ECOFF directives.  */
  { "extern",	ecoff_directive_extern,	0 },

  /* These are used on Irix.  I don't know how to implement them.  */
  { "alias",	s_ignore,		0 },
  { "bgnb",	s_ignore,		0 },
  { "endb",	s_ignore,		0 },
  { "lab",	s_ignore,		0 },
  { "noalias",	s_ignore,		0 },
  { "verstamp",	s_ignore,		0 },
  { "vreg",	s_ignore,		0 },
#endif

  {NULL, NULL, 0}			/* end sentinel */
};

#undef NO_RELOC
#include "aout/aout64.h"

asection *elf_com_section_ptr;

void
elf_pop_insert (void)
{
  pop_insert (elf_pseudo_table);
  if (ECOFF_DEBUGGING)
    {
      pop_insert (ecoff_debug_pseudo_table);
    }
}

void
elf_file_symbol (const char *s)
{
  size_t name_length = strlen (s);

  symbolS *sym = symbol_new (s, absolute_section, &zero_address_frag, 0);
  if (sym == NULL)
    {
      return;
    }

  char *obstack_name_ptr = (char *) obstack_alloc (&notes, name_length + 1);
  if (obstack_name_ptr == NULL)
    {
      return;
    }
  memcpy (obstack_name_ptr, s, name_length);
  obstack_name_ptr[name_length] = '\0';
  S_SET_NAME (sym, obstack_name_ptr);

  asymbol *current_bsym = symbol_get_bfdsym (sym);
  if (current_bsym == NULL)
    {
      return;
    }
  current_bsym->flags |= BSF_FILE;

  if (symbol_rootP != sym)
    {
      int root_is_file_symbol = 0;
      asymbol *root_bfd_sym = NULL;

      if (symbol_rootP != NULL)
        {
          root_bfd_sym = symbol_get_bfdsym (symbol_rootP);
          if (root_bfd_sym != NULL)
            {
              if ((root_bfd_sym->flags & BSF_FILE) != 0)
                {
                  root_is_file_symbol = 1;
                }
            }
        }

      if (symbol_rootP == NULL || root_bfd_sym == NULL || !root_is_file_symbol)
        {
          symbol_remove (sym, &symbol_rootP, &symbol_lastP);
          symbol_insert (sym, symbol_rootP, &symbol_rootP, &symbol_lastP);
        }
    }

#ifdef DEBUG
  verify_symbol_chain (symbol_rootP, symbol_lastP);
#endif

#ifdef NEED_ECOFF_DEBUG
  ecoff_new_file (s);
#endif
}

/* Called from read.c:s_comm after we've parsed .comm symbol, size.
   Parse a possible alignment value.  */

symbolS *
elf_common_parse (int ignore ATTRIBUTE_UNUSED, symbolS *symbolP, addressT size)
{
  addressT align = 0;
  int is_local = symbol_get_obj (symbolP)->local;
  int parsing_failed = 0;

  if (*input_line_pointer == ',')
    {
      char *save_input_line_pointer = input_line_pointer;

      input_line_pointer++; // Consume the comma
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '"')
	{
	  // Handle quoted segment type, e.g., ,"bss" or ,"data"
	  input_line_pointer++; // Consume the opening '"'

	  // Some use the dot, some don't.
	  if (*input_line_pointer == '.')
	    input_line_pointer++;

	  // Store pointer to the beginning of the segment name for error reporting.
	  char *segment_name_begin_for_error = input_line_pointer;

	  if (startswith (input_line_pointer, "bss\""))
	    {
	      input_line_pointer += 4; // Advance past "bss\""
	      is_local = 0; // "bss" implies global
	    }
	  else if (startswith (input_line_pointer, "data\""))
	    {
	      input_line_pointer += 5; // Advance past "data\""
	      is_local = 0; // "data" implies global
	    }
	  else
	    {
	      // Error: bad segment name.
	      // Backtrack to the opening quote for the error message display.
	      char *error_msg_ptr = segment_name_begin_for_error;
	      // Loop back until the opening quote is found.
              // The condition `error_msg_ptr > save_input_line_pointer` ensures we don't go past the comma.
	      while (error_msg_ptr > save_input_line_pointer && *--error_msg_ptr != '"')
                ; // error_msg_ptr now points to the opening quote.

	      // Advance input_line_pointer to the end of the current statement,
	      // or until the closing quote is found and consumed.
	      while (!is_end_of_stmt (*input_line_pointer) && *input_line_pointer != '"')
		input_line_pointer++;
              if (*input_line_pointer == '"') // If loop stopped at a quote, advance past it.
                  input_line_pointer++;

	      char original_char_at_pos = *input_line_pointer; // Save char at current position
	      *input_line_pointer = '\0'; // Temporarily null-terminate for as_bad
	      as_bad (_("bad .common segment %s"), error_msg_ptr); // Report the error
	      *input_line_pointer = original_char_at_pos; // Restore the character
	      ignore_rest_of_line (); // Discard rest of the erroneous line
	      parsing_failed = 1;
	    }
	}
      else
	{
	  // Not a quoted string, so it must be an alignment value.
	  // Reset input_line_pointer to its state immediately after the comma and any whitespace,
	  // so parse_align can correctly process the alignment token.
	  input_line_pointer = save_input_line_pointer; // Reset to the comma
	  input_line_pointer++; // Move past the comma
	  SKIP_WHITESPACE ();   // Skip any whitespace after the comma

	  align = parse_align (is_local);
	  if (align == (addressT) -1) // Check for parse_align error
	    {
	      parsing_failed = 1;
	    }
	}
    }

  if (parsing_failed)
    {
      return NULL; // Exit early if any parsing error occurred
    }

  // Apply symbol properties based on whether it's local or global
  if (is_local)
    {
      bss_alloc (symbolP, size, align);
      S_CLEAR_EXTERNAL (symbolP);
    }
  else
    {
      S_SET_VALUE (symbolP, size);
      S_SET_ALIGN (symbolP, align);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, elf_com_section_ptr);
    }

  // Mark the symbol as an object
  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  return symbolP;
}

void
obj_elf_common (int is_common)
{
  const int default_subroutine_arg = 0;

  if (flag_mri && is_common)
    s_mri_common (default_subroutine_arg);
  else
    s_comm_internal (default_subroutine_arg, elf_common_parse);
}

static void
obj_elf_tls_common (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = s_comm_internal (0, elf_common_parse);

  if (symbolP)
  {
    bfd_symbol *bfdsymP = symbol_get_bfdsym (symbolP);
    if (bfdsymP)
    {
      bfdsymP->flags |= BSF_THREAD_LOCAL;
    }
  }
}

static void
obj_elf_lcomm (void)
{
  symbolS *symbolP = s_comm_internal (0, s_lcomm_internal);

  if (symbolP)
    {
      bfd_symbol *bfd_sym = symbol_get_bfdsym (symbolP);
      if (bfd_sym)
        {
          bfd_sym->flags |= BSF_OBJECT;
        }
    }
}

static symbolS *
get_sym_from_input_line_and_check (void)
{
  char *name = NULL;
  char c_state;
  symbolS *sym = NULL;

  c_state = get_symbol_name (&name);
  restore_line_pointer (c_state);
  SKIP_WHITESPACE ();

  /* There is no symbol name if input_line_pointer has not moved,
     which is indicated by 'name' (start of symbol) being equal
     to 'input_line_pointer' (current position after parsing and skipping). */
  if (name == input_line_pointer)
    {
      as_bad (_("Missing symbol name in directive"));
      return NULL; /* Indicate failure by returning NULL. */
    }

  sym = symbol_find_or_make (name);
  return sym;
}

static void
obj_elf_local (void)
{
  symbolS *symbolP;
  char current_line_char;

  while (1)
    {
      symbolP = get_sym_from_input_line_and_check ();
      S_CLEAR_EXTERNAL (symbolP);
      symbol_get_obj (symbolP)->local = 1;

      current_line_char = *input_line_pointer;

      if (current_line_char != ',')
        break;

      input_line_pointer++;
      SKIP_WHITESPACE ();

      if (*input_line_pointer == '\n')
        break;
    }

  demand_empty_rest_of_line ();
}

static void
obj_elf_weak (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;
  int current_char_peek;

  while (1)
    {
      symbolP = get_sym_from_input_line_and_check ();
      S_SET_WEAK (symbolP);

      current_char_peek = *input_line_pointer;

      if (current_char_peek == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    {
	      break;
	    }
	}
      else
	{
	  break;
	}
    }

  demand_empty_rest_of_line ();
}

static void
obj_elf_visibility (int visibility)
{
  symbolS *symbolP;
  asymbol *bfdsym;
  elf_symbol_type *elfsym;
  int current_char_after_symbol;

  while (1)
    {
      symbolP = get_sym_from_input_line_and_check ();

      bfdsym = symbol_get_bfdsym (symbolP);
      elfsym = elf_symbol_from (bfdsym);

      gas_assert (elfsym);

      elfsym->internal_elf_sym.st_other &= ~3;
      elfsym->internal_elf_sym.st_other |= visibility;

      current_char_after_symbol = *input_line_pointer;

      if (current_char_after_symbol == ',')
        {
          input_line_pointer++;

          SKIP_WHITESPACE ();

          if (*input_line_pointer == '\n')
            {
              break;
            }
        }
      else
        {
          break;
        }
    }

  demand_empty_rest_of_line ();
}

static segT previous_section;
static int previous_subsection;

struct section_stack
{
  struct section_stack *next;
  segT seg, prev_seg;
  int subseg, prev_subseg;
};

static struct section_stack *section_stack;

/* ELF section flags for unique sections.  */
#define SEC_ASSEMBLER_SHF_MASK SHF_GNU_RETAIN

struct group_list
{
  asection **head;		/* Section lists.  */
  unsigned int num_group;	/* Number of lists.  */
  htab_t indexes; /* Maps group name to index in head array.  */
};

static struct group_list groups;

static bool
match_section (const asection *sec, const struct elf_section_match *match)
{
  const struct elf_section_data *sec_data = elf_section_data (sec);

  const char *linked_to_symbol_name = sec->map_head.linked_to_symbol_name;
  unsigned int sh_info = sec_data->this_hdr.sh_info;
  bfd_vma sh_flags_masked = (sec_data->this_hdr.sh_flags
                             & SEC_ASSEMBLER_SHF_MASK);
  bfd_flags sec_flags_masked = (bfd_section_flags (sec)
                                & SEC_ASSEMBLER_SECTION_ID);
  bfd_flags match_flags_masked = (match->flags
                                  & SEC_ASSEMBLER_SECTION_ID);

  if (sh_info != match->sh_info)
    return false;

  if (sh_flags_masked != match->sh_flags)
    return false;

  if (sec_flags_masked != match_flags_masked)
    return false;

  if (sec->section_id != match->section_id)
    return false;

  /* Compare linked_to_symbol_name.
     The original logic is:
     (pointers are identical || (both are non-NULL AND strcmp returns 0)) */
  if (linked_to_symbol_name == match->linked_to_symbol_name)
    {
      /* They match: both NULL, or both point to the same string. */
    }
  else if (linked_to_symbol_name == NULL || match->linked_to_symbol_name == NULL)
    {
      /* One is NULL and the other is not. They do not match. */
      return false;
    }
  else if (strcmp (linked_to_symbol_name, match->linked_to_symbol_name) != 0)
    {
      /* Both are non-NULL but the string content differs. They do not match. */
      return false;
    }

  return true;
}

/* Return TRUE iff SEC matches the section info INF.  */

static inline bool
are_strings_equal_or_both_null (const char *s1, const char *s2)
{
  if (s1 == s2)
    return true;
  if (s1 == NULL || s2 == NULL)
    return false;
  return strcmp (s1, s2) == 0;
}

static bool
get_section_by_match (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *inf)
{
  struct elf_section_match *match = (struct elf_section_match *) inf;
  const char *gname = match->group_name;
  const char *group_name = elf_group_name (sec);

  return are_strings_equal_or_both_null (group_name, gname)
         && match_section (sec, match);
}

/* Go look in section lists kept per group for SEC_NAME with
   properties given by MATCH.  If info for the group named by
   MATCH->GROUP_NAME has been initialised, set GROUP_IDX.  */

static asection *
group_section_find (const struct elf_section_match *match,
		    const char *sec_name,
		    unsigned int *group_idx)
{
  if (!groups.indexes)
    {
      groups.num_group = 0;
      groups.head = NULL;
      groups.indexes = htab_create_alloc (16, hash_string_tuple, eq_string_tuple,
					  NULL, notes_calloc, NULL);
      *group_idx = ~0u;
      return NULL;
    }

  *group_idx = str_hash_find_int (groups.indexes, match->group_name);
  if (*group_idx == ~0u)
    return NULL;

  asection *s;
  for (s = groups.head[*group_idx]; s != NULL; s = elf_next_in_group (s))
    if ((strcmp (s->name, sec_name) == 0)
	&& match_section (s, match))
      break;
  return s;
}

/* Insert SEC into section lists kept per group.  MATCH and GROUP_IDX
   must be from a prior call to group_section_find.  */

static void
group_section_insert (const struct elf_section_match *match,
		      asection *sec,
		      unsigned int *group_idx)
{
  if (*group_idx != ~0u)
    {
      elf_next_in_group (sec) = groups.head[*group_idx];
      groups.head[*group_idx] = sec;
      return;
    }

  unsigned int new_group_index = groups.num_group;
  if ((new_group_index & 127) == 0)
    groups.head = XRESIZEVEC (asection *, groups.head, new_group_index + 128);
  groups.head[new_group_index] = sec;
  groups.num_group += 1;

  str_hash_insert_int (groups.indexes, match->group_name, new_group_index, 0);
}

/* Handle the .section pseudo-op.  This code supports two different
   syntaxes.

   The first is found on Solaris, and looks like
       .section ".sec1",#alloc,#execinstr,#write
   Here the names after '#' are the SHF_* flags to turn on for the
   section.  I'm not sure how it determines the SHT_* type (BFD
   doesn't really give us control over the type, anyhow).

   The second format is found on UnixWare, and probably most SVR4
   machines, and looks like
       .section .sec1,"a",@progbits
   The quoted string may contain any combination of a, w, x, and
   represents the SHF_* flags to turn on for the section.  The string
   beginning with '@' can be progbits or nobits.  There should be
   other possibilities, but I don't know what they are.  In any case,
   BFD doesn't really let us set the section type.  */

static void handle_section_stack_push(bool push) {
  if (push) {
    struct section_stack *elt = XNEW(struct section_stack);
    elt->next = section_stack;
    elt->seg = now_seg;
    elt->prev_seg = previous_section;
    elt->subseg = now_subseg;
    elt->prev_subseg = previous_subsection;
    section_stack = elt;
  }
}

static segT get_or_create_section_internal(const char *name,
                                         struct elf_section_match *match_p,
                                         subsegT new_subsection,
                                         asection **old_sec_out,
                                         bool *is_new_section_out) {
  asection *old_sec_val = NULL;
  segT sec_val;
  unsigned int group_idx = ~0u;

  if (match_p->group_name) {
    old_sec_val = group_section_find(match_p, name, &group_idx);
  } else {
    old_sec_val = bfd_get_section_by_name_if(stdoutput, name, get_section_by_match, match_p);
  }

  if (old_sec_val) {
    sec_val = old_sec_val;
    subseg_set(sec_val, new_subsection);
    *is_new_section_out = false;
  } else {
    sec_val = subseg_force_new(name, new_subsection);
    if (match_p->group_name) {
      group_section_insert(match_p, sec_val, &group_idx);
    }
    *is_new_section_out = true;
  }
  *old_sec_out = old_sec_val;
  return sec_val;
}

static void validate_special_section_type(unsigned int *type_ptr, const char *name,
                                          const struct bfd_elf_special_section *ssect,
                                          const struct elf_backend_data *bed,
                                          bool is_new_section) {
  unsigned int provided_type = *type_ptr;
  unsigned int ssect_type = ssect->type;

  if (provided_type == SHT_NULL) {
    *type_ptr = ssect_type;
    return;
  }

  if (provided_type != ssect_type) {
    bool apply_ssect_type = false;

    if (is_new_section) {
#ifdef TC_I386
      bool x86_64_large_bss_case = (bed->s->arch_size == 64 && (ssect->attr & SHF_X86_64_LARGE));
#else
      bool x86_64_large_bss_case = false;
#endif
      if (!(x86_64_large_bss_case || ssect_type == SHT_INIT_ARRAY
            || ssect_type == SHT_FINI_ARRAY || ssect_type == SHT_PREINIT_ARRAY)) {
        if (!(ssect_type == SHT_NOTE || provided_type < SHT_LOPROC)) {
          as_warn(_("setting incorrect section type for %s"), name);
        }
      } else {
        as_warn(_("ignoring incorrect section type for %s"), name);
        apply_ssect_type = true;
      }
    } else {
      as_warn(_("ignoring incorrect section type for %s"), name);
      apply_ssect_type = true;
    }

    if (apply_ssect_type) {
      *type_ptr = ssect_type;
    }
  }
}

static bool validate_special_section_attributes(bfd_vma *attr_ptr, const char *name,
                                                const struct bfd_elf_special_section *ssect,
                                                const struct elf_backend_data *bed,
                                                struct elf_section_match *match_p) {
  bfd_vma current_attr = *attr_ptr;
  bfd_vma ssect_attr = ssect->attr;
  bool override_attr = false;

  bfd_vma generic_attr = current_attr;
  if (elf_tdata(stdoutput)->has_gnu_osabi) {
    generic_attr &= ~SHF_GNU_RETAIN;
  }

  bfd_vma unexpected_attrs_mask = ~(SHF_LINK_ORDER | SHF_MASKOS | SHF_MASKPROC);
  if ((generic_attr & unexpected_attrs_mask & ~ssect_attr) != 0) {
    if (ssect->type == SHT_NOTE && (generic_attr == SHF_ALLOC || generic_attr == SHF_EXECINSTR)) {
      /* Allowed for .note sections */
    } else if (ssect->suffix_length == -2 && name[ssect->prefix_length] == '.' &&
               (generic_attr & ~ssect_attr & ~SHF_MERGE & ~SHF_STRINGS) == 0) {
      /* Allowed for .rodata.str like sections */
    } else if (generic_attr == SHF_ALLOC &&
               (strcmp(name, ".interp") == 0 || strcmp(name, ".strtab") == 0 || strcmp(name, ".symtab") == 0)) {
      override_attr = true;
    } else if (generic_attr == SHF_EXECINSTR && strcmp(name, ".note.GNU-stack") == 0) {
      override_attr = true;
    }
#ifdef TC_ALPHA
    else if ((generic_attr & ~ssect_attr) == SHF_ALPHA_GPREL) {
      override_attr = true;
    }
#endif
#ifdef TC_RX
    else if (generic_attr == (SHF_EXECINSTR | SHF_WRITE | SHF_ALLOC) &&
             (ssect->type == SHT_INIT_ARRAY || ssect->type == SHT_FINI_ARRAY || ssect->type == SHT_PREINIT_ARRAY)) {
      /* RX init/fini arrays */
    }
#endif
    else {
      if (match_p->group_name == NULL) {
        as_warn(_("setting incorrect section attributes for %s"), name);
      }
      override_attr = true;
    }
  }
  return override_attr;
}

static flagword calculate_bfd_flags(bfd_vma attr, unsigned int type, bool linkonce, const char *name) {
  flagword flags = (SEC_RELOC
                    | ((attr & SHF_WRITE) ? 0 : SEC_READONLY)
                    | ((attr & SHF_ALLOC) ? SEC_ALLOC : 0)
                    | (((attr & SHF_ALLOC) && type != SHT_NOBITS) ? SEC_LOAD : 0)
                    | ((attr & SHF_EXECINSTR) ? SEC_CODE : 0)
                    | ((attr & SHF_MERGE) ? SEC_MERGE : 0)
                    | ((attr & SHF_STRINGS) ? SEC_STRINGS : 0)
                    | ((attr & SHF_EXCLUDE) ? SEC_EXCLUDE: 0)
                    | ((attr & SHF_TLS) ? SEC_THREAD_LOCAL : 0));

#ifdef md_elf_section_flags
  flags = md_elf_section_flags(flags, attr, type);
#endif

  if (linkonce) {
    flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
  }

  if ((flags & SEC_ALLOC) == 0 && name[0] == '.') {
    if (startswith(name, ".debug")
        || startswith(name, ".zdebug")
        || startswith(name, ".gnu.debuglto_.debug_")
        || startswith(name, ".gnu.linkonce.wi.")
        || startswith(name, GNU_BUILD_ATTRS_SECTION_NAME)
        || startswith(name, ".note.gnu")) {
      flags |= SEC_ELF_OCTETS;
    }
  }
  return flags;
}

static void configure_new_section(segT sec, unsigned int type, bfd_vma attr, int entsize,
                                  flagword flags, struct elf_section_match *match_p,
                                  const char *name) {
  if (type == SHT_NULL) {
    type = bfd_elf_get_default_section_type(flags);
  }
  elf_section_type(sec) = type;
  elf_section_flags(sec) = attr;
  elf_section_data(sec)->this_hdr.sh_info = match_p->sh_info;

  if (type == SHT_NOBITS) {
    seg_info(sec)->bss = 1;
  }

  sec->section_id = match_p->section_id;
  flags |= match_p->flags;

  sec->map_head.linked_to_symbol_name = match_p->linked_to_symbol_name;

  bfd_set_section_flags(sec, flags);
  if (entsize != 0) {
    sec->entsize = entsize;
  }
  elf_group_name(sec) = match_p->group_name;

  symbolS *secsym = symbol_find(name);
  if (secsym != NULL) {
    static const expressionS exp = { .X_op = O_constant };
    symbol_set_value_expression(secsym, &exp);
    symbol_set_bfdsym(secsym, sec->symbol);
  } else {
    symbol_table_insert(section_symbol(sec));
  }
}

static void validate_existing_section_properties(asection *old_sec, unsigned int provided_type,
                                                 bfd_vma provided_attr, int entsize,
                                                 flagword new_bfd_flags, const struct bfd_elf_special_section *ssect,
                                                 const char *name) {
  if (provided_type != SHT_NULL && (unsigned)provided_type != elf_section_type(old_sec)) {
    if (ssect != NULL) {
      as_warn(_("ignoring changed section type for %s"), name);
    } else {
      as_bad(_("changed section type for %s"), name);
    }
  }

  if (provided_attr != 0) {
    flagword old_bfd_flags = old_sec->flags;
    flagword relevant_flags_mask = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
                                    | SEC_EXCLUDE | SEC_SORT_ENTRIES | SEC_MERGE | SEC_STRINGS
                                    | SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
                                    | SEC_THREAD_LOCAL);

    if (((old_bfd_flags ^ new_bfd_flags) & relevant_flags_mask) != 0) {
      if (ssect != NULL) {
        as_warn(_("ignoring changed section attributes for %s"), name);
      } else {
        as_bad(_("changed section attributes for %s"), name);
      }
    } else {
      elf_section_flags(old_sec) = provided_attr;
    }
  }

  if (entsize != 0 && old_sec->entsize != (unsigned)entsize) {
    as_bad(_("changed section entity size for %s"), name);
  }
}


static void
change_section (const char *name,
		unsigned int type,
		bfd_vma attr,
		int entsize,
		struct elf_section_match *match_p,
		bool linkonce,
		bool push,
		subsegT new_subsection)
{
  asection *old_sec;
  segT sec;
  bool is_new_section;
  unsigned int current_type = type;
  bfd_vma current_attr = attr;
  const struct bfd_elf_special_section *ssect = NULL;

  if (match_p == NULL)
    {
      static struct elf_section_match unused_match;
      match_p = &unused_match;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  handle_section_stack_push(push);

  obj_elf_section_change_hook();

  sec = get_or_create_section_internal(name, match_p, new_subsection, &old_sec, &is_new_section);

  const struct elf_backend_data *bed = get_elf_backend_data(stdoutput);
  ssect = (*bed->get_sec_type_attr)(stdoutput, sec);

  if (ssect != NULL) {
    validate_special_section_type(&current_type, name, ssect, bed, is_new_section);

    if (is_new_section) {
      bool override_attr = validate_special_section_attributes(&current_attr, name, ssect, bed, match_p);
      if (!override_attr) {
        current_attr |= ssect->attr;
      }
    }
  }

  flagword flags = calculate_bfd_flags(current_attr, current_type, linkonce, name);

  if (is_new_section) {
    configure_new_section(sec, current_type, current_attr, entsize, flags, match_p, name);
  } else {
    validate_existing_section_properties(old_sec, current_type, current_attr, entsize, flags, ssect, name);
  }

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

void
obj_elf_change_section (const char *name,
			unsigned int type,
			bfd_vma attr,
			int entsize,
			struct elf_section_match *match_p,
			bool linkonce)
{
  change_section (name, type, attr, entsize, match_p, linkonce, false, 0);
}

static bfd_vma
obj_elf_parse_section_letters (char *str, size_t len, bool push,
			       bool *is_clone, int *inherit, bfd_vma *gnu_attr,
			       bool *has_entsize)
{
  bfd_vma attr = 0;

  *is_clone = false;
  *inherit = 0;

  while (len > 0)
    {
      size_t chars_processed_this_iter = 1;
      bool recognized_this_iter = true;
      char current_char = *str;

      switch (current_char)
	{
	case 'a':
	  attr |= SHF_ALLOC;
	  if (len >= 2 && str[1] == 'm')
	    {
	      attr |= SHF_MERGE;
	      chars_processed_this_iter++;
	      if (len >= 3 && str[2] == 's')
		{
		  attr |= SHF_STRINGS;
		  chars_processed_this_iter++;
		}
	    }
	  break;
	case 'd':
	  if (gnu_attr == NULL) { recognized_this_iter = false; break; }
	  *gnu_attr |= SHF_GNU_MBIND;
	  break;
	case 'e':
	  attr |= SHF_EXCLUDE;
	  break;
	case 'o':
	  attr |= SHF_LINK_ORDER;
	  break;
	case 'w':
	  attr |= SHF_WRITE;
	  break;
	case 'x':
	  attr |= SHF_EXECINSTR;
	  break;
	case 'E':
	  *has_entsize = true;
	  break;
	case 'G':
	  attr |= SHF_GROUP;
	  break;
	case 'M':
	  attr |= SHF_MERGE;
	  break;
	case 'R':
	  if (gnu_attr == NULL) { recognized_this_iter = false; break; }
	  *gnu_attr |= SHF_GNU_RETAIN;
	  break;
	case 'S':
	  attr |= SHF_STRINGS;
	  break;
	case 'T':
	  attr |= SHF_TLS;
	  break;
	case '?':
	  *is_clone = true;
	  break;
	default:
	  recognized_this_iter = false;
	  break;
	}

      if (!recognized_this_iter)
	{
	  const char *md_extra_for_err = "";
	  bool handled_by_target_specific = false;

#ifdef md_elf_section_letter
	  bfd_vma md_attr_result = md_elf_section_letter (current_char, &md_extra_for_err);
	  if (md_attr_result != (bfd_vma) -1)
	    {
	      attr |= md_attr_result;
	      handled_by_target_specific = true;
	    }
#endif

	  if (handled_by_target_specific)
	    {
	      recognized_this_iter = true;
	    }
	  else if (ISDIGIT ((unsigned char)current_char))
	    {
	      char *endptr;
	      unsigned long numeric_val = strtoul (str, &endptr, 0);

	      if (endptr == str)
		{
		  // ISDIGIT was true, but strtoul found no digits. This indicates an invalid numeric format.
		  // It will correctly fall through to the final error reporting.
		}
	      else
		{
		  attr |= (bfd_vma)numeric_val;
		  if (gnu_attr != NULL)
		    *gnu_attr |= (numeric_val & SHF_MASKOS);

		  chars_processed_this_iter = endptr - str;
		  recognized_this_iter = true;
		}
	    }
	  else if (!*inherit && !attr
		   && (gnu_attr == NULL || !*gnu_attr)
		   && (current_char == '+' || current_char == '-'))
	    {
	      *inherit = (current_char == '+') ? 1 : -1;
	      recognized_this_iter = true;
	    }
	}

      if (!recognized_this_iter)
	{
	  // If still not recognized after all attempts (switch, target-specific, numeric, inherit), report error.
	  const char *md_extra_display = "";
#ifdef md_elf_section_letter
	  // If md_elf_section_letter was defined, md_extra_for_err would have been set.
	  md_extra_display = md_extra_for_err;
#endif
	  as_bad (_("unrecognized .%ssection attribute: want %s%s%s,? or number"),
		  push ? "push" : "",
		  gnu_attr != NULL ? "a,d,e,o,w,x,E,G,M,R,S,T" : "a,e,o,w,x,E,G,M,S,T",
		  md_extra_display != NULL && *md_extra_display != '\0' ? "," : "", md_extra_display);
	  return attr;
	}

      str += chars_processed_this_iter;
      len -= chars_processed_this_iter;
    }

  return attr;
}

#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdbool.h>
#include <limits.h>

struct NamedSectionType {
  const char *name;
  size_t len;
  int type;
};

static const struct NamedSectionType named_section_types[] = {
  { "progbits", 8, SHT_PROGBITS },
  { "nobits", 6, SHT_NOBITS },
  { "note", 4, SHT_NOTE },
  { "init_array", 10, SHT_INIT_ARRAY },
  { "fini_array", 10, SHT_FINI_ARRAY },
  { "preinit_array", 13, SHT_PREINIT_ARRAY },
};
static const size_t num_named_section_types = sizeof(named_section_types) / sizeof(named_section_types[0]);

static int
obj_elf_section_type (char *str, size_t len, bool warn)
{
  for (size_t i = 0; i < num_named_section_types; ++i) {
    if (len == named_section_types[i].len &&
        strncmp(str, named_section_types[i].name, len) == 0) {
      return named_section_types[i].type;
    }
  }

#ifdef md_elf_section_type
  {
    int md_type = md_elf_section_type (str, len);
    if (md_type >= 0)
      return md_type;
  }
#endif

  if (len > 0 && isdigit((unsigned char)*str))
    {
      char *tmp_buf = NULL;
      int type = 0;
      bool conversion_successful = false;
      char *endptr;

      tmp_buf = (char *) malloc(len + 1);
      if (tmp_buf == NULL) {
        if (warn) {
          as_warn(_("memory allocation failed for section type conversion"));
        }
        return 0;
      }

      memcpy(tmp_buf, str, len);
      tmp_buf[len] = '\0';

      unsigned long val = strtoul(tmp_buf, &endptr, 0);

      if (endptr != tmp_buf && *endptr == '\0') {
        if (val <= INT_MAX) {
          type = (int)val;
          conversion_successful = true;
        } else {
            if (warn) {
                as_warn(_("numeric section type out of range"));
            }
        }
      } else {
        if (warn && *endptr != '\0') {
          as_warn(_("extraneous characters at end of numeric section type"));
        }
      }

      free(tmp_buf);

      if (conversion_successful) {
        return type;
      }
    }

  if (warn) {
    as_warn (_("unrecognized section type"));
  }
  return 0;
}

#ifdef TC_SPARC
static bfd_vma
obj_elf_section_word (char *str, size_t len, int *type)
{
  int ret;

  if (len == 5 && startswith (str, "write"))
    return SHF_WRITE;
  if (len == 5 && startswith (str, "alloc"))
    return SHF_ALLOC;
  if (len == 9 && startswith (str, "execinstr"))
    return SHF_EXECINSTR;
  if (len == 7 && startswith (str, "exclude"))
    return SHF_EXCLUDE;
  if (len == 3 && startswith (str, "tls"))
    return SHF_TLS;

  ret = obj_elf_section_type (str, len, false);
  if (ret != 0)
    *type = ret;
  else
    as_warn (_("unrecognized section attribute"));

  return 0;
}
#endif

/* Get name of section.  */
const char *
obj_elf_section_name (void)
{
  char *section_name = NULL;

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      // The second parameter to demand_copy_C_string is not used later,
      // so a local variable is provided to satisfy the function's signature.
      int string_length_discard;
      section_name = demand_copy_C_string(&string_length_discard);
      if (section_name == NULL)
        {
          ignore_rest_of_line();
          return NULL;
        }
    }
  else
    {
      char *name_start_ptr = input_line_pointer;
      char *name_end_ptr = name_start_ptr;

      // Find the end of the unquoted section name
      while (!is_whitespace (*name_end_ptr) && !is_end_of_stmt (*name_end_ptr) && *name_end_ptr != ',')
        name_end_ptr++;

      // Handle empty name error
      if (name_end_ptr == name_start_ptr)
        {
          as_bad (_("missing name"));
          ignore_rest_of_line();
          return NULL;
        }

      // Copy the identified section name to the obstack, ensuring null termination
      size_t name_length = name_end_ptr - name_start_ptr;
      obstack_grow0 (&notes, name_start_ptr, name_length);
      section_name = (char *) obstack_base (&notes);

      // Apply section name substitution if flag_sectname_subst is enabled
      while (flag_sectname_subst)
        {
          char *substitution_marker = strchr (section_name, '%');

          // Check for the specific '%S' substitution pattern
          if (substitution_marker != NULL && substitution_marker[1] == 'S')
            {
              size_t prefix_segment_length = substitution_marker - section_name;
              size_t tail_segment_length = strlen (substitution_marker + 2) + 1; // +1 for null terminator
              size_t current_segment_name_length = strlen (now_seg->name);

              // Adjust the size of the current obstack object if the replacement string is longer than "%S" (2 chars)
              // obstack_blank requires a non-negative size argument.
              if (current_segment_name_length > 2)
                {
                  size_t growth_amount = current_segment_name_length - 2;
                  obstack_blank (&notes, growth_amount);
                  // Update section_name pointer in case obstack_blank caused reallocation
                  section_name = (char *) obstack_base (&notes);
                }

              // Shift the part of the string after '%S' to accommodate the new segment name.
              // memmove is used to correctly handle overlapping memory regions.
              memmove (section_name + prefix_segment_length + current_segment_name_length,
                       section_name + prefix_segment_length + 2,
                       tail_segment_length);

              // Copy the actual segment name into the space created/adjusted
              memcpy (section_name + prefix_segment_length, now_seg->name, current_segment_name_length);

              // Loop continues to check for further '%S' substitutions in the modified string
            }
          else
            {
              // No more '%S' found in the current string, or flag_sectname_subst is off, exit loop
              break;
            }
        }

      // Finalize the current object on the obstack after all modifications
      obstack_finish (&notes);

#ifdef tc_canonicalize_section_name
      section_name = tc_canonicalize_section_name (section_name);
#endif
      // Advance the global input pointer past the parsed section name
      input_line_pointer = name_end_ptr;
    }

  SKIP_WHITESPACE ();
  return section_name;
}

/* Arrange to put SEC, known to be in group GNAME into the per-group
   section lists kept by gas.  */

void
elf_set_group_name (asection *sec, const char *gname)
{
  elf_group_name (sec) = gname;
  elf_section_flags (sec) |= SHF_GROUP;

  struct bfd_elf_section_data * const section_data = elf_section_data (sec);

  struct elf_section_match match;
  match.group_name = gname;
  match.linked_to_symbol_name = sec->map_head.linked_to_symbol_name;
  match.section_id = sec->section_id;
  match.sh_info = section_data->this_hdr.sh_info;
  match.sh_flags = (section_data->this_hdr.sh_flags
		    & SEC_ASSEMBLER_SHF_MASK);
  match.flags = bfd_section_flags (sec) & SEC_ASSEMBLER_SECTION_ID;

  unsigned int group_idx;
  if (!group_section_find (&match, sec->name, &group_idx))
    group_section_insert (&match, sec, &group_idx);
}

static void
obj_elf_attach_to_group (int dummy ATTRIBUTE_UNUSED)
{
  const char *gname = obj_elf_section_name();

  if (gname == NULL)
    {
      as_warn(_("group name not parseable"));
      return;
    }

  const char *existing_group_name = elf_group_name(now_seg);
  if (existing_group_name != NULL)
    {
      if (strcmp(existing_group_name, gname) != 0)
        {
          as_warn(_("section %s already has a group (%s)"),
                  bfd_section_name(now_seg), existing_group_name);
        }
      return;
    }

  elf_set_group_name(now_seg, gname);
}

/* Handle section related directives.

   Note on support for SFrame sections: These are generally expected to be
   generated by the assembler.  However, this function permits their direct
   creation by the user.  At the moment though, we go no extra mile by adding
   an explicit @sframe for SHT_GNU_SFRAME (using the numeric value of section
   type should suffice); Nor do we implement any outright refusal for
   non-supported targets via ELFOSABI-specific checks.  */

void
obj_elf_section (int push)
{
  const char *name;
  char *beg;
  int type, dummy;
  bfd_vma attr;
  bfd_vma gnu_attr;
  int entsize;
  bool linkonce, has_entsize;
  subsegT new_subsection = 0;
  struct elf_section_match match;
  unsigned long linked_to_section_index = -1UL;
  int inherit = 0; /* Declared here to be available throughout parsing blocks.  */

  if (flag_mri)
    {
      char mri_type;

#ifdef md_flush_pending_output
      md_flush_pending_output ();
#endif

      obj_elf_section_change_hook ();

      s_mri_sect (&mri_type);

#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif

      return;
    }

  name = obj_elf_section_name ();
  if (name == NULL)
    return;

  memset (&match, 0, sizeof (match));

  symbolS * sym;
  if ((sym = symbol_find (name)) != NULL
      && ! symbol_section_p (sym)
      && S_IS_DEFINED (sym)
      && ! S_IS_VOLATILE (sym)
      && ! S_CAN_BE_REDEFINED (sym))
    {
      as_bad (_("section name '%s' already defined as another symbol"), name);
      ignore_rest_of_line ();
      return;
    }
  type = SHT_NULL;
  attr = 0;
  gnu_attr = 0;
  entsize = 0;
  has_entsize = false;
  linkonce = false;

  if (*input_line_pointer == ',')
    {
      /* Skip the comma.  */
      ++input_line_pointer;
      SKIP_WHITESPACE ();

      /* 1. Optional subsection for .pushsection.  */
      if (push && ISDIGIT (*input_line_pointer))
	{
	  new_subsection = get_absolute_expression ();

	  SKIP_WHITESPACE ();

	  /* Stop if we don't see a comma.  */
	  if (*input_line_pointer != ',')
	    goto parsing_done; /* Corresponds to original `goto done`.  */

	  /* Skip the comma.  */
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	}

      /* 2. Attributes (quoted string) OR TC_SPARC special handling.  */
      if (*input_line_pointer == '"')
	{
	  bool is_clone;

	  beg = demand_copy_C_string (&dummy);
	  if (beg == NULL)
	    {
	      ignore_rest_of_line ();
	      return;
	    }

	  const struct elf_backend_data *bed = get_elf_backend_data (stdoutput);
	  attr = obj_elf_parse_section_letters (beg, strlen (beg), push,
						&is_clone, &inherit,
						bed->elf_osabi == ELFOSABI_NONE
						|| (bed->elf_osabi
						    == ELFOSABI_GNU)
						|| (bed->elf_osabi
						    == ELFOSABI_FREEBSD)
						? &gnu_attr : NULL,
						&has_entsize);

	  if (inherit > 0)
	    attr |= elf_section_flags (now_seg);
	  else if (inherit < 0)
	    attr = elf_section_flags (now_seg) & ~attr;
	  if (inherit)
	    type = elf_section_type (now_seg);

	  if ((attr & (SHF_MERGE | SHF_STRINGS)) != 0)
	    has_entsize = true;

	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      char *save_ptr_type = input_line_pointer;

	      ++input_line_pointer;
	      SKIP_WHITESPACE ();
	      char c_type = *input_line_pointer;

	      /* 3. Type.  */
	      if (c_type == '"')
		{
		  beg = demand_copy_C_string (&dummy);
		  if (beg == NULL)
		    {
		      ignore_rest_of_line ();
		      return;
		    }
		  type = obj_elf_section_type (beg, strlen (beg), true);
		}
	      else if (c_type == '@' || c_type == '%')
		{
		  ++input_line_pointer;

		  if (ISDIGIT (* input_line_pointer))
		    type = strtoul (input_line_pointer, &input_line_pointer, 0);
		  else
		    {
		      char c_sym = get_symbol_name (& beg);
		      (void) restore_line_pointer (c_sym);
		      type = obj_elf_section_type (beg,
						   input_line_pointer - beg,
						   true);
		    }
		}
	      else
		/* Restore if comma was present but no type syntax matched.  */
		input_line_pointer = save_ptr_type;
	    }

	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      char *save_ptr_entsize = input_line_pointer;

	      ++input_line_pointer;
	      SKIP_WHITESPACE ();

	      /* 4. Entsize.  */
	      bool entsize_handled = false;
	      if (has_entsize)
		{
		  /* Original `goto fetch_entsize` implies `inherit && *input_line_pointer == ','` for this.  */
		  if (inherit && *input_line_pointer == ','
		      && ((bfd_section_flags (now_seg)
			   & (SEC_MERGE | SEC_STRINGS)) != 0
			  || now_seg->entsize))
		    {
		      ++input_line_pointer; /* Skip the second comma.  */
		      SKIP_WHITESPACE();
		      entsize = now_seg->entsize;
		      entsize_handled = true;
		    }
		  else if (is_end_of_stmt (*input_line_pointer)
			   && (bfd_section_flags (now_seg)
			       & (SEC_MERGE | SEC_STRINGS)) != 0)
		    {
		      as_tsktsk (_("missing section entity size, 1 assumed"));
		      entsize = 1;
		      entsize_handled = true;
		    }
		  else
		    {
		      entsize = get_absolute_expression ();
		      SKIP_WHITESPACE ();
		      if (entsize <= 0)
			{
			  as_warn (_("invalid section entity size"));
			  attr &= ~(SHF_MERGE | SHF_STRINGS);
			  has_entsize = false;
			  entsize = 0;
			}
		      entsize_handled = true;
		    }
		}
	      /* Handle `fetch_entsize` if no explicit comma for entsize.  */
	      else if (inherit
		       && ((bfd_section_flags (now_seg)
			    & (SEC_MERGE | SEC_STRINGS)) != 0
			   || now_seg->entsize))
		{
		  entsize = now_seg->entsize;
		  entsize_handled = true;
		}

	      /* Apply warnings/defaults if not parsed/inherited.  */
	      if (!entsize_handled)
		{
		  if ((attr & SHF_MERGE) != 0)
		    {
		      as_warn (_("entity size for SHF_MERGE not specified"));
		      attr &= ~(SHF_MERGE | SHF_STRINGS);
		      has_entsize = false;
		    }
		  else if ((attr & SHF_STRINGS) != 0)
		    {
		      entsize = 1;
		    }
		  else if (has_entsize)
		    {
		      as_warn (_("entity size not specified"));
		      has_entsize = false;
		    }
		}
	      /* Restore if comma present but no entsize logic applied.  */
	      if (!entsize_handled)
		input_line_pointer = save_ptr_entsize;
	    }

	  if ((attr & (SHF_MERGE | SHF_STRINGS)) != 0 && type == SHT_NOBITS)
	    as_warn (_("bogus SHF_MERGE / SHF_STRINGS for SHT_NOBITS section"));

	  SKIP_WHITESPACE ();
	  if ((attr & SHF_LINK_ORDER) != 0 && *input_line_pointer == ',')
	    {
	      char *save_ptr_linked_to = input_line_pointer;
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();

	      /* 5. Linked-to section.  */
	      bool linked_to_handled = false;
	      if (inherit && *input_line_pointer == ','
		  && (elf_section_flags (now_seg) & SHF_LINK_ORDER) != 0)
		{
		  ++input_line_pointer; /* Skip second comma.  */
		  SKIP_WHITESPACE();
		  if (now_seg->map_head.linked_to_symbol_name)
		    match.linked_to_symbol_name = now_seg->map_head.linked_to_symbol_name;
		  else
		    linked_to_section_index = elf_section_data (now_seg)->this_hdr.sh_link;
		  linked_to_handled = true;
		}
	      else
		{
		  if (ISDIGIT (* input_line_pointer))
		    {
		      linked_to_section_index = strtoul (input_line_pointer, & input_line_pointer, 0);
		      linked_to_handled = true;
		    }
		  else
		    {
		      char c_sym = get_symbol_name (& beg);
		      (void) restore_line_pointer (c_sym);
		      unsigned int length = input_line_pointer - beg;
		      if (length)
			match.linked_to_symbol_name = notes_memdup (beg, length, length + 1);
		      linked_to_handled = true;
		    }
		}
	      /* Restore if comma present but no linked-to logic applied.  */
	      if (!linked_to_handled)
		input_line_pointer = save_ptr_linked_to;
	    }
	  /* Handle `fetch_linked_to` if no explicit comma was present.  */
	  else if ((attr & SHF_LINK_ORDER) != 0 && inherit
		   && (elf_section_flags (now_seg) & SHF_LINK_ORDER) != 0)
	    {
	      if (now_seg->map_head.linked_to_symbol_name)
		match.linked_to_symbol_name = now_seg->map_head.linked_to_symbol_name;
	      else
		linked_to_section_index = elf_section_data (now_seg)->this_hdr.sh_link;
	    }

	  SKIP_WHITESPACE ();
	  if ((attr & SHF_GROUP) != 0 && *input_line_pointer == ',')
	    {
	      char *save_ptr_group = input_line_pointer;
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();

	      /* 6. Group.  */
	      if (is_clone)
		{
		  as_warn (_("? section flag ignored with G present"));
		  is_clone = false;
		}

	      bool group_handled = false;
	      if (inherit && *input_line_pointer == ','
		  && (elf_section_flags (now_seg) & SHF_GROUP) != 0)
		{
		  ++input_line_pointer; /* Skip second comma.  */
		  SKIP_WHITESPACE();
		  match.group_name = elf_group_name (now_seg);
		  linkonce = (bfd_section_flags (now_seg) & SEC_LINK_ONCE) != 0;
		  group_handled = true;
		}
	      else
		{
		  match.group_name = obj_elf_section_name ();
		  if (match.group_name == NULL)
		    {
		      attr &= ~SHF_GROUP;
		    }
		  else
		    {
		      group_handled = true;
		      SKIP_WHITESPACE ();
		      if (*input_line_pointer == ',')
			{
			  ++input_line_pointer;
			  SKIP_WHITESPACE ();
			  if (startswith (input_line_pointer, "comdat"))
			    {
			      input_line_pointer += 6;
			      linkonce = true;
			    }
			}
		    }
		}
	      /* Restore if comma present but no group logic applied.  */
	      if (!group_handled)
		input_line_pointer = save_ptr_group;
	    }
	  /* Handle `fetch_group` if no explicit comma was present.  */
	  else if ((attr & SHF_GROUP) != 0 && inherit
		   && (elf_section_flags (now_seg) & SHF_GROUP) != 0)
	    {
	      match.group_name = elf_group_name (now_seg);
	      linkonce = (bfd_section_flags (now_seg) & SEC_LINK_ONCE) != 0;
	    }
	  else if ((attr & SHF_GROUP) != 0)
	    {
	      as_warn (_("group name for SHF_GROUP not specified"));
	      attr &= ~SHF_GROUP;
	    }

	  if (startswith (name, ".gnu.linkonce"))
	    linkonce = true;

	  if (is_clone)
	    {
	      const char *now_group = elf_group_name (now_seg);
	      if (now_group != NULL)
		{
		  match.group_name = now_group;
		  linkonce = (now_seg->flags & SEC_LINK_ONCE) != 0;
		}
	    }

	  SKIP_WHITESPACE ();
	  if ((gnu_attr & SHF_GNU_MBIND) != 0 && *input_line_pointer == ',')
	    {
	      char *save_ptr_mbind = input_line_pointer;
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();

	      /* 7. GNU MBIND info.  */
	      if (ISDIGIT (* input_line_pointer))
		{
		  char *t = input_line_pointer;
		  match.sh_info = strtoul (input_line_pointer,
					&input_line_pointer, 0);
		  if (match.sh_info == -1U) /* -1U is UINT_MAX.  */
		    {
		      as_warn (_("unsupported mbind section info: %s"), t);
		      match.sh_info = 0;
		    }
		}
	      else
		/* Restore if comma present but not a digit (for value).  */
		input_line_pointer = save_ptr_mbind;
	    }

	  if ((gnu_attr & SHF_GNU_RETAIN) != 0)
	    match.sh_flags |= SHF_GNU_RETAIN;

	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == ',')
	    {
	      char *save_ptr_unique = input_line_pointer;
	      ++input_line_pointer;
	      SKIP_WHITESPACE ();

	      /* 8. "unique" section ID.  */
	      if (startswith (input_line_pointer, "unique"))
		{
		  input_line_pointer += 6;
		  SKIP_WHITESPACE ();
		  if (*input_line_pointer == ',')
		    {
		      ++input_line_pointer;
		      SKIP_WHITESPACE ();
		      if (ISDIGIT (* input_line_pointer))
			{
			  bfd_vma id;
			  bool overflow;
			  char *t = input_line_pointer;
			  if (sizeof (bfd_vma) <= sizeof (unsigned long))
			    {
			      errno = 0;
			      id = strtoul (input_line_pointer,
					    &input_line_pointer, 0);
			      overflow = id == ~0UL && errno == ERANGE;
			    }
			  else
			    {
			      id = bfd_scan_vma
				(input_line_pointer,
				 (const char **) &input_line_pointer, 0);
			      overflow = id == ~(bfd_vma) 0;
			    }
			  /* Check for overflow or value larger than 32-bit unsigned int.  */
			  if (overflow || id > (bfd_vma)-1U)
			    {
			      char *linefeed, saved_char = 0;
			      if ((linefeed = strchr (t, '\n')) != NULL)
				{
				  saved_char = *linefeed;
				  *linefeed = '\0';
				}
			      as_bad (_("unsupported section id: %s"), t);
			      if (saved_char)
				*linefeed = saved_char;
			    }
			  else
			    {
			      match.section_id = id;
			      match.flags |= SEC_ASSEMBLER_SECTION_ID;
			    }
			}
		    }
		}
	      else
		/* Restore if comma present but not "unique".  */
		input_line_pointer = save_ptr_unique;
	    }
	}
#ifdef TC_SPARC
      else /* This is the ELSE branch of `if (*input_line_pointer == '"')`.  */
	{
	  do
	    {
	      char c_sparc;

	      SKIP_WHITESPACE ();
	      if (*input_line_pointer != '#')
		{
		  as_bad (_("character following name is not '#'"));
		  ignore_rest_of_line ();
		  return;
		}
	      ++input_line_pointer;
	      c_sparc = get_symbol_name (& beg);
	      (void) restore_line_pointer (c_sparc);

	      attr |= obj_elf_section_word (beg, input_line_pointer - beg,
					    &type);

	      SKIP_WHITESPACE ();
	    }
	  while (*input_line_pointer++ == ',');
	  --input_line_pointer; /* Decrement one too many increment from while condition.  */
	}
#endif
    }

parsing_done:; /* Target for the `goto` that means "finished parsing arguments".  */

  demand_empty_rest_of_line ();

  if ((gnu_attr & (SHF_GNU_MBIND | SHF_GNU_RETAIN)) != 0)
    {
      bool mbind_p = (gnu_attr & SHF_GNU_MBIND) != 0;

      if (mbind_p && (attr & SHF_ALLOC) == 0)
	as_bad (_("SHF_ALLOC isn't set for GNU_MBIND section: %s"), name);

      if (mbind_p)
	elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_mbind;
      if ((gnu_attr & SHF_GNU_RETAIN) != 0)
	elf_tdata (stdoutput)->has_gnu_osabi |= elf_gnu_osabi_retain;

      attr |= gnu_attr;
    }

  change_section (name, type, attr, entsize, &match, linkonce, push,
		  new_subsection);

  if (linked_to_section_index != -1UL)
    {
      elf_section_flags (now_seg) |= SHF_LINK_ORDER;
      elf_section_data (now_seg)->this_hdr.sh_link = linked_to_section_index;
    }
}

/* Change to the .bss section.  */

void
obj_elf_bss (int i ATTRIBUTE_UNUSED)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();

  int temp = get_absolute_expression ();
  subseg_set (bss_section, temp);
  demand_empty_rest_of_line ();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* Change to the .data section.  */

void
obj_elf_data (const int i)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();

  s_data (i);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* Change to the .text section.  */

void
obj_elf_text (int i)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();

  s_text (i);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* Change to the *ABS* section.  */

void
obj_elf_struct (int i)
{
  md_flush_pending_output ();

  obj_elf_section_change_hook ();

  s_struct (i);

  md_elf_section_change_hook ();
}

static void
obj_elf_subsection (int ignore ATTRIBUTE_UNUSED)
{
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();

  const int temp = get_absolute_expression ();
  subseg_set (now_seg, temp);
  demand_empty_rest_of_line ();

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

/* This can be called from the processor backends if they change
   sections.  */

void
obj_elf_section_change_hook (void)
{
  int current_seg_snapshot = now_seg;
  int current_subseg_snapshot = now_subseg;

  previous_section = current_seg_snapshot;
  previous_subsection = current_subseg_snapshot;
}

void
obj_elf_previous (int ignore ATTRIBUTE_UNUSED)
{
  if (previous_section == 0)
    {
      as_warn (_(".previous without corresponding .section; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  obj_elf_section_change_hook ();

  subseg_set (previous_section, previous_subsection);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_popsection (int xxx ATTRIBUTE_UNUSED)
{
  struct section_stack *top = section_stack;

  if (top == NULL)
    {
      as_warn (_(".popsection without corresponding .pushsection; ignored"));
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  section_stack = top->next;
  previous_section = top->prev_seg;
  previous_subsection = top->prev_subseg;
  subseg_set (top->seg, top->subseg);
  free (top);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

static void
obj_elf_line (int ignore ATTRIBUTE_UNUSED)
{
  char *expression = get_absolute_expression();

  if (expression == NULL) {
    log_error("Failed to parse or retrieve absolute expression.");
    return;
  }

  new_logical_line(NULL, expression);

  demand_empty_rest_of_line();

  free(expression);
}

static struct elf_versioned_name_list *
obj_elf_find_and_add_versioned_name (const char *version_name,
				     const char *sym_name,
				     const char *ver,
				     struct elf_obj_sy *sy_obj)
{
  const char *p_prefix_end = ver + 1;
  while (*p_prefix_end == ELF_VER_CHR)
    {
      p_prefix_end++;
    }
  int ver_prefix_len = (int)(p_prefix_end - ver);

  switch (ver_prefix_len)
    {
    case 1:
    case 2:
      /* Versions with one or two '@' prefixes are generally allowed. */
      break;
    case 3:
      /* Special handling for '@@@' (triple-at) versions.
         Only one '@@@' version is allowed per symbol. */
      if (sy_obj->rename)
	{
          /* If `rename` flag is set, an '@@@' version was previously processed.
             We assume `sy_obj->versioned_name` points to this '@@@' version. */
          if (sy_obj->versioned_name == NULL)
            {
              /* This indicates an inconsistent internal state:
                 `sy_obj->rename` is true but the list of versioned names is empty. */
              as_bad (_("internal error: `rename` flag set but no versioned name found for symbol `%s`"), sym_name);
              return NULL;
            }

	  if (strcmp (sy_obj->versioned_name->name, version_name) == 0)
	    {
	      return sy_obj->versioned_name; /* Return the existing matching entry. */
	    }
	  else
	    {
	      as_bad (_("only one version name with `@@@` is allowed for symbol `%s`"), sym_name);
	      return NULL;
	    }
	}
      sy_obj->rename = true; /* Mark that an '@@@' version has been encountered. */
      break;
    default:
      /* Any other prefix length is invalid. */
      as_bad (_("invalid version name '%s' for symbol `%s`"), version_name, sym_name);
      return NULL;
    }

  /* Search for an existing versioned name in the linked list. */
  struct elf_versioned_name_list *current_versioned_name = sy_obj->versioned_name;
  while (current_versioned_name != NULL)
    {
      if (strcmp (current_versioned_name->name, version_name) == 0)
	{
	  return current_versioned_name; /* Found existing, return it. */
	}
      current_versioned_name = current_versioned_name->next;
    }

  /* If the name was not found, add a new entry to the head of the list. */
  struct elf_versioned_name_list *new_versioned_name;

  new_versioned_name = notes_alloc (sizeof (*new_versioned_name));
  /* Assuming notes_alloc does not return NULL or handles errors internally. */

  new_versioned_name->name = notes_strdup (version_name);
  /* Assuming notes_strdup does not return NULL or handles errors internally. */

  new_versioned_name->next = sy_obj->versioned_name;
  sy_obj->versioned_name = new_versioned_name;

  return new_versioned_name;
}

/* This handles the .symver pseudo-op, which is used to specify a
   symbol version.  The syntax is ``.symver NAME,SYMVERNAME''.
   SYMVERNAME may contain ELF_VER_CHR ('@') characters.  This
   pseudo-op causes the assembler to emit a symbol named SYMVERNAME
   with the same value as the symbol NAME.  */

static void
obj_elf_symver (int ignore ATTRIBUTE_UNUSED)
{
  char *parsed_versioned_name = NULL;
  const char *base_symbol_name;
  char line_restore_char_val = 0;
  char old_at_char_lex_type;
  symbolS *symbol_entry;
  struct elf_obj_sy *elf_symbol_obj = NULL;
  char *version_separator_pointer;
  bool had_error = false;

  symbol_entry = get_sym_from_input_line_and_check ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .symver"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();

  old_at_char_lex_type = lex_type[(unsigned char) '@'];
  lex_type[(unsigned char) '@'] |= LEX_NAME;

  line_restore_char_val = get_symbol_name (&parsed_versioned_name);

  base_symbol_name = S_GET_NAME (symbol_entry);

  if (S_IS_COMMON (symbol_entry))
    {
      as_bad (_("`%s' can't be versioned to common symbol '%s'"),
	      parsed_versioned_name, base_symbol_name);
      had_error = true;
      goto cleanup;
    }

  version_separator_pointer = strchr (parsed_versioned_name, ELF_VER_CHR);
  if (version_separator_pointer == NULL)
    {
      as_bad (_("missing version name in `%s' for symbol `%s'"),
	      parsed_versioned_name, base_symbol_name);
      had_error = true;
      goto cleanup;
    }

  elf_symbol_obj = symbol_get_obj (symbol_entry);
  if (elf_symbol_obj == NULL)
    {
      as_bad (_("internal error: failed to get ELF object for symbol `%s'"), base_symbol_name);
      had_error = true;
      goto cleanup;
    }

  if (obj_elf_find_and_add_versioned_name (parsed_versioned_name,
                                           base_symbol_name,
                                           version_separator_pointer,
                                           elf_symbol_obj) == NULL)
    {
      elf_symbol_obj->bad_version = true;
      had_error = true;
      goto cleanup;
    }

  if (*input_line_pointer == ',')
    {
      char *saved_line_pointer_for_visibility = input_line_pointer;

      ++input_line_pointer;
      SKIP_WHITESPACE ();

      if (elf_symbol_obj != NULL)
        {
          if (startswith (input_line_pointer, "local"))
            {
              input_line_pointer += (sizeof("local") - 1);
              elf_symbol_obj->visibility = visibility_local;
            }
          else if (startswith (input_line_pointer, "hidden"))
            {
              input_line_pointer += (sizeof("hidden") - 1);
              elf_symbol_obj->visibility = visibility_hidden;
            }
          else if (startswith (input_line_pointer, "remove"))
            {
              input_line_pointer += (sizeof("remove") - 1);
              elf_symbol_obj->visibility = visibility_remove;
            }
          else
            {
              input_line_pointer = saved_line_pointer_for_visibility;
            }
        }
    }

  demand_empty_rest_of_line ();

cleanup:
  lex_type[(unsigned char) '@'] = old_at_char_lex_type;

  if (parsed_versioned_name != NULL)
    {
      (void) restore_line_pointer (line_restore_char_val);
    }

  if (had_error)
    {
      ignore_rest_of_line ();
    }
}

/* This handles the .vtable_inherit pseudo-op, which is used to indicate
   to the linker the hierarchy in which a particular table resides.  The
   syntax is ".vtable_inherit CHILDNAME, PARENTNAME".  */

static void
advance_past_hash(void)
{
  if (*input_line_pointer == '#')
    ++input_line_pointer;
}

struct fix *
obj_elf_get_vtable_inherit (void)
{
  char *cname = NULL;
  symbolS *csym = NULL;
  char *pname = NULL;
  symbolS *psym = NULL;

  advance_past_hash();
  (void) get_symbol_name(&cname);

  csym = symbol_find(cname);

  if (csym == NULL || symbol_get_frag(csym) == NULL)
    {
      as_bad(_("expected `%s' to have already been set for .vtable_inherit"), cname);
      return NULL;
    }

  SKIP_WHITESPACE();
  if (*input_line_pointer != ',')
    {
      as_bad(_("expected comma after name in .vtable_inherit"));
      ignore_rest_of_line();
      return NULL;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE();

  advance_past_hash();
  if (input_line_pointer[0] == '0' &&
      (is_end_of_stmt(input_line_pointer[1]) || is_whitespace(input_line_pointer[1])))
    {
      psym = section_symbol(absolute_section);
      ++input_line_pointer;
    }
  else
    {
      (void) get_symbol_name(&pname);
      psym = symbol_find_or_make(pname);
    }

  if (!demand_empty_rest_of_line())
    {
      return NULL;
    }

  gas_assert(symbol_get_value_expression(csym)->X_op == O_constant);
  return fix_new(symbol_get_frag(csym),
                 symbol_get_value_expression(csym)->X_add_number,
                 0, psym, 0, 0, BFD_RELOC_VTABLE_INHERIT);
}

/* This is a version of obj_elf_get_vtable_inherit() that is
   suitable for use in struct _pseudo_type tables.  */

void
obj_elf_vtable_inherit ()
{
  (void) obj_elf_get_vtable_inherit ();
}

/* This handles the .vtable_entry pseudo-op, which is used to indicate
   to the linker that a vtable slot was used.  The syntax is
   ".vtable_entry tablename, offset".  */

static void
skip_hash_if_present (void)
{
  if (*input_line_pointer == '#')
    ++input_line_pointer;
}

struct fix *
obj_elf_get_vtable_entry (void)
{
  symbolS *sym;
  offsetT offset;

  skip_hash_if_present ();

  sym = get_sym_from_input_line_and_check ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after name in .vtable_entry"));
      ignore_rest_of_line ();
      return NULL;
    }

  ++input_line_pointer;

  skip_hash_if_present ();

  offset = get_absolute_expression ();

  demand_empty_rest_of_line ();

  return fix_new (frag_now, frag_now_fix (), 0, sym, offset, 0,
		  BFD_RELOC_VTABLE_ENTRY);
}

/* This is a version of obj_elf_get_vtable_entry() that is
   suitable for use in struct _pseudo_type tables.  */

void
obj_elf_vtable_entry (int ignore)
{
  (void)ignore;
  (void) obj_elf_get_vtable_entry ();
}

#define skip_whitespace(str)  do { if (is_whitespace (*(str))) ++(str); } while (0)

static inline int
skip_past_char (char ** str, char c)
{
  if (str == NULL || *str == NULL)
    {
      return -1;
    }

  if (**str == c)
    {
      (*str)++;
      return 0;
    }
  else
    {
      return -1;
    }
}
#define skip_past_comma(str) skip_past_char (str, ',')

/* A list of attributes that have been explicitly set by the assembly code.
   VENDOR is the vendor id, BASE is the tag shifted right by the number
   of bits in MASK, and bit N of MASK is set if tag BASE+N has been set.  */
struct recorded_attribute_info {
  struct recorded_attribute_info *next;
  int vendor;
  unsigned int base;
  unsigned long mask;
};
static struct recorded_attribute_info *recorded_attributes;

/* Record that we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

static void
record_attribute (int vendor, unsigned int tag)
{
  const unsigned int BITS_IN_MASK_FIELD = 8 * sizeof(unsigned long);

  unsigned int base_index = tag / BITS_IN_MASK_FIELD;
  unsigned long bit_mask = 1UL << (tag % BITS_IN_MASK_FIELD);

  struct recorded_attribute_info *current_entry;

  for (current_entry = recorded_attributes; current_entry != NULL; current_entry = current_entry->next)
    {
      if (current_entry->vendor == vendor && current_entry->base == base_index)
        {
          current_entry->mask |= bit_mask;
          return;
        }
    }

  struct recorded_attribute_info *new_entry = XNEW(struct recorded_attribute_info);

  new_entry->next = recorded_attributes;
  new_entry->vendor = vendor;
  new_entry->base = base_index;
  new_entry->mask = bit_mask;

  recorded_attributes = new_entry;
}

/* Return true if we have seen an explicit specification of attribute TAG
   for vendor VENDOR.  */

bool
obj_elf_seen_attribute (int vendor, unsigned int tag)
{
  const unsigned int bits_per_mask_word = 8 * sizeof(unsigned long);

  const unsigned int base_index = tag / bits_per_mask_word;

  const unsigned long bit_mask = 1UL << (tag % bits_per_mask_word);

  for (struct recorded_attribute_info *current_rai = recorded_attributes;
       current_rai != NULL;
       current_rai = current_rai->next)
  {
    if (current_rai->vendor == vendor && current_rai->base == base_index)
    {
      return (current_rai->mask & bit_mask) != 0;
    }
  }

  return false;
}

/* Parse an attribute directive for VENDOR.
   Returns the attribute number read, or zero on error.  */

#ifndef CONVERT_SYMBOLIC_ATTRIBUTE
#define CONVERT_SYMBOLIC_ATTRIBUTE(a) -1
#endif

int
obj_elf_vendor_attribute (int vendor)
{
  expressionS exp;
  int type;
  int tag;
  unsigned int int_value = 0;
  char *name_start = NULL;
  char *name_str = NULL;
  char *attr_string_value = NULL;
  int name_len = 0;

  skip_whitespace (input_line_pointer);
  name_start = input_line_pointer;

  if (ISDIGIT (*input_line_pointer))
    {
      expression (&exp);
      if (exp.X_op != O_constant)
	{
	  as_bad (_("expected numeric constant for tag"));
	  ignore_rest_of_line ();
	  return 0;
	}
      tag = exp.X_add_number;
    }
  else
    {
      for (; ISALNUM (*input_line_pointer) || *input_line_pointer == '_';
	   ++input_line_pointer)
	name_len++;

      if (name_len == 0)
	{
	  as_bad (_("expected <tag> or symbolic name"));
	  ignore_rest_of_line ();
	  return 0;
	}

      name_str = xmemdup0 (name_start, name_len);
      tag = CONVERT_SYMBOLIC_ATTRIBUTE (name_str);
      if (tag == -1)
	{
	  as_bad (_("Attribute name not recognised: %s"), name_str);
	  ignore_rest_of_line ();
	  free (name_str);
	  return 0;
	}
      free (name_str);
      name_str = NULL;
    }

  type = _bfd_elf_obj_attrs_arg_type (stdoutput, vendor, tag);

  if (type & 1)
    {
      if (skip_past_comma (&input_line_pointer) == -1)
	{
	  as_bad (_("expected comma before numeric value"));
	  ignore_rest_of_line ();
	  return 0;
	}
      expression (&exp);
      if (exp.X_op != O_constant)
	{
	  as_bad (_("expected numeric constant"));
	  ignore_rest_of_line ();
	  return 0;
	}
      int_value = exp.X_add_number;
    }

  if ((type & 3) == 3)
    {
      if (skip_past_comma (&input_line_pointer) == -1)
	{
	  as_bad (_("expected comma before string value"));
	  ignore_rest_of_line ();
	  return 0;
	}
    }

  if (type & 2)
    {
      int len;
      skip_whitespace (input_line_pointer);
      if (*input_line_pointer != '"')
	{
	  as_bad (_("expected string constant"));
	  ignore_rest_of_line ();
	  return 0;
	}
      attr_string_value = demand_copy_C_string (&len);
    }

  record_attribute (vendor, tag);
  bool ok = false;
  switch (type & 3)
    {
    case 3:
      ok = bfd_elf_add_obj_attr_int_string (stdoutput, vendor, tag, int_value, attr_string_value);
      break;
    case 2:
      ok = bfd_elf_add_obj_attr_string (stdoutput, vendor, tag, attr_string_value);
      break;
    case 1:
      ok = bfd_elf_add_obj_attr_int (stdoutput, vendor, tag, int_value);
      break;
    case 0:
      ok = true;
      break;
    default:
      abort ();
    }

  if (!ok)
    {
      as_fatal (_("error adding attribute: %s"), bfd_errmsg (bfd_get_error ()));
    }

  demand_empty_rest_of_line ();

  if (attr_string_value != NULL)
    {
      free (attr_string_value);
    }
  
  return tag;
}

/* Parse a .gnu_attribute directive.  */

static void
obj_elf_gnu_attribute (int ignored)
{
  (void)ignored;
  obj_elf_vendor_attribute (OBJ_ATTR_GNU);
}

void
elf_obj_read_begin_hook (void)
{
#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING != 0)
    ecoff_read_begin_hook ();
#endif
}

void
elf_obj_symbol_new_hook (symbolS *symbolP)
{
  if (symbolP == NULL)
    {
      return;
    }

  struct elf_obj_sy *sy_obj = symbol_get_obj (symbolP);

  if (sy_obj == NULL)
    {
      return;
    }

  sy_obj->size = 0;
  sy_obj->versioned_name = NULL;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    {
      ecoff_symbol_new_hook (symbolP);
    }
#endif
}

/* If size is unset, copy size from src.  Because we don't track whether
   .size has been used, we can't differentiate .size dest, 0 from the case
   where dest's size is unset.  */
void
elf_copy_symbol_size (symbolS *dest, symbolS *src)
{
  if (dest == NULL || src == NULL)
    {
      return;
    }

  struct elf_obj_sy *srcelf = symbol_get_obj (src);
  struct elf_obj_sy *destelf = symbol_get_obj (dest);

  if (srcelf == NULL || destelf == NULL)
    {
      return;
    }

  if (!destelf->size && S_GET_SIZE (dest) == 0)
    {
      destelf->size = srcelf->size;
      S_SET_SIZE (dest, S_GET_SIZE (src));
    }
}

void
elf_copy_symbol_attributes (symbolS *dest, symbolS *src)
{
  if (dest == NULL || src == NULL)
    {
      return;
    }

  elf_copy_symbol_size (dest, src);

  unsigned int dest_other_value = S_GET_OTHER (dest);
  unsigned int src_other_value = S_GET_OTHER (src);

  unsigned int non_visibility_attributes_mask = ~ELF_ST_VISIBILITY (-1);

  unsigned int dest_visibility = ELF_ST_VISIBILITY (dest_other_value);

  unsigned int src_non_visibility_attributes = src_other_value & non_visibility_attributes_mask;

  S_SET_OTHER (dest, dest_visibility | src_non_visibility_attributes);
}

void
obj_elf_version (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char *p;
  asection *original_seg = now_seg;
  subsegT original_subseg = now_subseg;
  Elf_Internal_Note i_note;
  // Elf_External_Note is not declared as a variable, but its members' sizes
  // are used. Assuming 'e_note' in `sizeof (e_note.namesz)` refers to the
  // type Elf_External_Note, and its members are of the correct on-disk size.
  asection *note_secp = NULL;
  unsigned int len;

  SKIP_WHITESPACE ();
  if (*input_line_pointer == '\"')
    {
      char *string_content_start;
      char *closing_quote_position;
      char saved_char_after_string;

      ++input_line_pointer; // Advance past the opening quote.
      string_content_start = input_line_pointer;

      // Advance input_line_pointer until the end of the string content.
      // `next_char_of_string()` is assumed to advance `input_line_pointer`
      // and return the character at the new position.
      // The loop terminates when `is_a_char` returns false (e.g., at a closing quote
      // or end-of-line character that is not part of the string content).
      // After the loop, `input_line_pointer` points to the character *after*
      // the one that caused `is_a_char` to return false.
      while (is_a_char (next_char_of_string ()))
	;

      // `input_line_pointer` is now positioned *after* the closing quote
      // (or after the character that terminated the string scanning).
      // The character at `input_line_pointer - 1` should be the closing quote.
      closing_quote_position = input_line_pointer - 1;

      // Save the character that was originally at `input_line_pointer`'s current position.
      saved_char_after_string = *input_line_pointer;
      // Temporarily null-terminate the buffer at `input_line_pointer`'s current position.
      // This is for the `demand_empty_rest_of_line` check later, if the original
      // buffer needs to be pristine *after* the extracted string's actual content.
      *input_line_pointer = '\0';

      // Overwrite the closing quote character with a null terminator.
      // This ensures `strlen(name)` calculates the length of the string content.
      *closing_quote_position = '\0';

      name = string_content_start;

      // Create the .note section.
      note_secp = subseg_new (".note", 0);
      bfd_set_section_flags (note_secp, SEC_HAS_CONTENTS | SEC_READONLY);
      record_alignment (note_secp, 2);

      // Process the version string.
      // namesz includes the null terminator, as per PR 3456.
      len = strlen (name) + 1;

      i_note.namesz = len;
      i_note.descsz = 0;	/* No description.  */
      i_note.type = NT_VERSION;

      // Write ELF note header fields.
      // The `sizeof (e_note.namesz)` syntax implies `e_note` refers to the type
      // `Elf_External_Note` (or similar external representation), and its members
      // specify the on-disk sizes, usually `Elf_Word` (4 bytes).
      p = frag_more (sizeof (i_note.namesz));
      md_number_to_chars (p, i_note.namesz, sizeof (i_note.namesz));
      p = frag_more (sizeof (i_note.descsz));
      md_number_to_chars (p, i_note.descsz, sizeof (i_note.descsz));
      p = frag_more (sizeof (i_note.type));
      md_number_to_chars (p, i_note.type, sizeof (i_note.type));
      p = frag_more (len);
      memcpy (p, name, len);

      // Restore the characters that were temporarily overwritten in the input buffer.
      *closing_quote_position = '\"'; // Restore the closing quote.
      *input_line_pointer = saved_char_after_string; // Restore char after the quote.

      // Align the current fragment to a 2-byte boundary.
      frag_align (2, 0, 0);

      // Restore the original section and subsegment context.
      subseg_set (original_seg, original_subseg);
    }
  else
    {
      as_bad (_("expected quoted string"));
    }

  demand_empty_rest_of_line ();
}

static void
obj_elf_size (int ignore ATTRIBUTE_UNUSED)
{
  char *symbol_name_ptr = NULL;
  char original_char_at_symbol_end;
  char *symbol_end_pos = NULL;

  original_char_at_symbol_end = get_symbol_name(&symbol_name_ptr);
  
  symbol_end_pos = input_line_pointer;
  
  restore_line_pointer(original_char_at_symbol_end);

  SKIP_WHITESPACE();

  if (*input_line_pointer != ',')
    {
      *symbol_end_pos = '\0';
      as_bad(_("expected comma after name `%s' in .size directive"), symbol_name_ptr);
      *symbol_end_pos = original_char_at_symbol_end;
      ignore_rest_of_line();
      return;
    }

  input_line_pointer++;

  expressionS exp;
  expression(&exp);

  if (exp.X_op == O_absent)
    {
      as_bad(_("missing expression in .size directive"));
      exp.X_op = O_constant;
      exp.X_add_number = 0;
    }

  *symbol_end_pos = '\0';
  symbolS *sym = symbol_find_or_make(symbol_name_ptr);
  *symbol_end_pos = original_char_at_symbol_end;

  if (exp.X_op == O_constant)
    {
      S_SET_SIZE(sym, exp.X_add_number);
      symbol_get_obj(sym)->size = NULL;
    }
  else
    {
      symbol_object *obj = symbol_get_obj(sym);
      obj->size = notes_alloc(sizeof(exp));
      if (obj->size == NULL)
        {
          *symbol_end_pos = '\0';
          as_bad(_("memory exhausted for .size expression for symbol `%s'"), symbol_name_ptr);
          *symbol_end_pos = original_char_at_symbol_end;
          obj->size = NULL;
        }
      else
        {
          *obj->size = exp;
        }
    }

  if (flag_synth_cfi && S_IS_FUNCTION(sym) && sym == ginsn_data_func_symbol())
    {
      ginsn_data_end(symbol_temp_new_now());
    }

  demand_empty_rest_of_line();
}

/* Handle the ELF .type pseudo-op.  This sets the type of a symbol.
   There are six syntaxes:

   The first (used on Solaris) is
       .type SYM,#function
   The second (used on UnixWare) is
       .type SYM,@function
   The third (reportedly to be used on Irix 6.0) is
       .type SYM STT_FUNC
   The fourth (used on NetBSD/Arm and Linux/ARM) is
       .type SYM,%function
   The fifth (used on SVR4/860) is
       .type SYM,"function"
   The sixth (emitted by recent SunPRO under Solaris) is
       .type SYM,[0-9]
   where the integer is the STT_* value.
   */

#include <ctype.h>

static char *
obj_elf_type_name (char *cp)
{
  char *p = input_line_pointer;

  if (isdigit((unsigned char)*input_line_pointer))
    {
      while (isdigit((unsigned char)*input_line_pointer))
	++input_line_pointer;
      *cp = *input_line_pointer;
      *input_line_pointer = '\0';
    }
  else
    *cp = get_symbol_name (&p);

  return p;
}

static void handle_common_type(symbolS *sym) {
  if (!S_IS_COMMON(sym)) {
    if (S_IS_VOLATILE(sym)) {
      sym = symbol_clone(sym, 1);
      S_SET_SEGMENT(sym, bfd_com_section_ptr);
      S_SET_VALUE(sym, 0);
      S_SET_EXTERNAL(sym);
      symbol_set_frag(sym, &zero_address_frag);
      S_CLEAR_VOLATILE(sym);
    } else if (S_IS_DEFINED(sym) || symbol_equated_p(sym)) {
      as_bad(_("symbol '%s' is already defined"), S_GET_NAME(sym));
    } else {
      S_SET_SEGMENT(sym, bfd_com_section_ptr);
      S_SET_VALUE(sym, 0);
      S_SET_EXTERNAL(sym);
    }
  }
}

static void handle_gnu_ifunc_type(const char *type_name) {
  const struct elf_backend_data *bed = get_elf_backend_data(stdoutput);
  if (bed->elf_osabi != ELFOSABI_NONE &&
      bed->elf_osabi != ELFOSABI_GNU &&
      bed->elf_osabi != ELFOSABI_FREEBSD) {
    as_bad(_("symbol type \"%s\" is supported only by GNU "
             "and FreeBSD targets"), type_name);
  } else if (bed->target_id == MIPS_ELF_DATA) {
    as_bad(_("symbol type \"%s\" is not supported by "
             "MIPS targets"), type_name);
  }
  elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_ifunc;
}

static void handle_gnu_unique_object_type(const char *type_name) {
  const struct elf_backend_data *bed = get_elf_backend_data(stdoutput);
  if (bed->elf_osabi != ELFOSABI_NONE && bed->elf_osabi != ELFOSABI_GNU) {
    as_bad(_("symbol type \"%s\" is supported only by GNU targets"),
           type_name);
  }
  elf_tdata(stdoutput)->has_gnu_osabi |= elf_gnu_osabi_unique;
}

static int get_symbol_flags_from_type_name(symbolS *sym, elf_symbol_type *elfsym, const char *type_name) {
  int type_flags = 0;

  if (strcmp(type_name, "function") == 0 || strcmp(type_name, "2") == 0 || strcmp(type_name, "STT_FUNC") == 0) {
    type_flags = BSF_FUNCTION;
  } else if (strcmp(type_name, "object") == 0 || strcmp(type_name, "1") == 0 || strcmp(type_name, "STT_OBJECT") == 0) {
    type_flags = BSF_OBJECT;
  } else if (strcmp(type_name, "tls_object") == 0 || strcmp(type_name, "6") == 0 || strcmp(type_name, "STT_TLS") == 0) {
    type_flags = BSF_OBJECT | BSF_THREAD_LOCAL;
  } else if (strcmp(type_name, "notype") == 0 || strcmp(type_name, "0") == 0 || strcmp(type_name, "STT_NOTYPE") == 0) {
    /* type_flags remains 0 for STT_NOTYPE */
  } else if (strcmp(type_name, "common") == 0 || strcmp(type_name, "5") == 0 || strcmp(type_name, "STT_COMMON") == 0) {
    type_flags = BSF_OBJECT;
    handle_common_type(sym);
  } else if (strcmp(type_name, "gnu_indirect_function") == 0 || strcmp(type_name, "10") == 0 || strcmp(type_name, "STT_GNU_IFUNC") == 0) {
    handle_gnu_ifunc_type(type_name);
    type_flags = BSF_FUNCTION | BSF_GNU_INDIRECT_FUNCTION;
  } else if (strcmp(type_name, "gnu_unique_object") == 0) {
    handle_gnu_unique_object_type(type_name);
    type_flags = BSF_OBJECT | BSF_GNU_UNIQUE;
  }
#ifdef md_elf_symbol_type
  else {
    int md_type_val = md_elf_symbol_type(type_name, sym, elfsym);
    if (md_type_val != -1) {
      type_flags = md_type_val;
    } else {
      as_bad(_("unrecognized symbol type \"%s\""), type_name);
      type_flags = 0; /* On error, proceed as if type was 0 (notype) */
    }
  }
#else
  else {
    as_bad(_("unrecognized symbol type \"%s\""), type_name);
    type_flags = 0; /* On error, proceed as if type was 0 (notype) */
  }
#endif
  return type_flags;
}

static void apply_elf_symbol_flags(symbolS *sym, elf_symbol_type *elfsym, int type_flags_to_apply) {
#ifdef md_elf_symbol_type_change
  if (md_elf_symbol_type_change(sym, elfsym, type_flags_to_apply)) {
    return; /* Machine dependent hook handled it */
  }
#endif

  flagword mask = BSF_FUNCTION | BSF_OBJECT;
  int effective_type_flags = type_flags_to_apply;

  if (!(type_flags_to_apply & BSF_FUNCTION)) {
    mask |= BSF_GNU_INDIRECT_FUNCTION;
  }
  if (!(type_flags_to_apply & BSF_OBJECT)) {
    mask |= BSF_GNU_UNIQUE | BSF_THREAD_LOCAL;

    if (S_IS_COMMON(sym)) {
      as_bad(_("cannot change type of common symbol '%s'"), S_GET_NAME(sym));
      /* Critical: reset type_flags and mask to effectively cancel the change */
      mask = 0;
      effective_type_flags = 0;
    }
  }

  /* Don't warn when changing to STT_NOTYPE (effective_type_flags == 0). */
  if (effective_type_flags != 0) {
    flagword new_flags = (elfsym->symbol.flags & ~mask) | effective_type_flags;

    /* Warn if the symbol already has an incompatible type set. */
    if (new_flags != (elfsym->symbol.flags | effective_type_flags)) {
      as_warn(_("symbol '%s' already has its type set"), S_GET_NAME(sym));
    }
    elfsym->symbol.flags = new_flags;
  } else { /* Setting STT_NOTYPE (effective_type_flags == 0) */
    elfsym->symbol.flags &= ~mask;
  }
}

static void
obj_elf_type (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *sym = get_sym_from_input_line_and_check();
  elf_symbol_type *elfsym = (elf_symbol_type *) symbol_get_bfdsym(sym);

  /* Save the character at input_line_pointer immediately after the symbol.
     This character is passed to obj_elf_type_name by reference and
     can be modified by it. Its (potentially modified) value will later be
     restored at the current input_line_pointer for demand_empty_rest_of_line. */
  char c_token_boundary_char = *input_line_pointer;

  if (*input_line_pointer == ',') {
    ++input_line_pointer;
  }
  SKIP_WHITESPACE();

  /* Skip optional prefixes like '#', '@', '"', '%' from the input stream. */
  if (*input_line_pointer == '#' || *input_line_pointer == '@' ||
      *input_line_pointer == '"' || *input_line_pointer == '%') {
    ++input_line_pointer;
  }

  /* obj_elf_type_name reads the type string from input_line_pointer,
     advances input_line_pointer, and may modify c_token_boundary_char. */
  const char *type_name_str = obj_elf_type_name(&c_token_boundary_char);

  /* Resolve desired BSF_ flags from the type name string and perform specific side effects. */
  int type_flags = get_symbol_flags_from_type_name(sym, elfsym, type_name_str);

  /* Restore the character at the current input_line_pointer position
     to the (potentially modified) value from c_token_boundary_char.
     This is crucial for demand_empty_rest_of_line to correctly parse
     the remainder of the line from a consistent logical starting point. */
  *input_line_pointer = c_token_boundary_char;

  /* If the type name was quoted, skip the closing quote using the restored
     input_line_pointer character. */
  if (*input_line_pointer == '"') {
    ++input_line_pointer;
  }

  /* Apply the determined type flags to the symbol, handling machine-dependent hooks. */
  apply_elf_symbol_flags(sym, elfsym, type_flags);

  if (S_IS_FUNCTION(sym) && flag_synth_cfi) {
    /* When using SCFI, .type directive indicates start of a new FDE for SCFI
       processing. So, demarcate previous block of ginsns if any. */
    if (frchain_now->frch_ginsn_data) {
      ginsn_data_end(symbol_temp_new_now());
    }
    ginsn_data_begin(sym);
  }

  demand_empty_rest_of_line();
}

static segT comment_section;

static void
obj_elf_ident (int ignore ATTRIBUTE_UNUSED)
{
  segT old_section = now_seg;
  int old_subsection = now_subseg;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (!comment_section)
    {
      comment_section = subseg_new (".comment", 0);
      if (!comment_section)
        {
          /* Error: Failed to create .comment section. Restore context and exit. */
          subseg_set (old_section, old_subsection);
#ifdef md_elf_section_change_hook
          md_elf_section_change_hook ();
#endif
          return;
        }

      bfd_set_section_flags (comment_section, (SEC_READONLY | SEC_HAS_CONTENTS
					       | SEC_MERGE | SEC_STRINGS));
      comment_section->entsize = 1;

      subseg_set (comment_section, 0); /* Make the newly created section current */
#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif

      char *p = frag_more (1);
      if (!p)
        {
          /* Error: Failed to allocate initial null byte. Restore context and exit. */
          subseg_set (old_section, old_subsection);
#ifdef md_elf_section_change_hook
          md_elf_section_change_hook ();
#endif
          return;
        }
      *p = 0;
    }
  else
    {
      subseg_set (comment_section, 0); /* Make the existing comment section current */
#ifdef md_elf_section_change_hook
      md_elf_section_change_hook ();
#endif
    }

  stringer (8 + 1);

  subseg_set (old_section, old_subsection); /* Restore original section context */
#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

#ifdef INIT_STAB_SECTION

/* The first entry in a .stabs section is special.  */

void
obj_elf_init_stab_section (segT stab, segT stabstr)
{
  char *file;
  char *p;
  unsigned int stroff;

  /* Force the section to align to a longword boundary.  Without this,
     UnixWare ar crashes.  */
  bfd_set_section_alignment (stab, 2);

  /* Make space for this first symbol.  */
  p = frag_more (12);
  /* Zero it out.  */
  memset (p, 0, 12);
  file = remap_debug_filename (as_where (NULL));
  stroff = get_stab_string_offset (file, stabstr);
  know (stroff == 1 || (stroff == 0 && file[0] == '\0'));
  md_number_to_chars (p, stroff, 4);
  seg_info (stab)->stabu.p = p;
  free (file);
}

#endif

/* Called via bfd_map_over_sections.  If SEC's linked_to_symbol_name
   isn't NULL, set up its linked-to section.
   For .stabs section, fill in the counts in the first entry.  */

static void
set_additional_section_info (bfd *abfd,
                             asection *sec,
                             void *inf ATTRIBUTE_UNUSED)
{
  if (sec->map_head.linked_to_symbol_name)
    {
      symbolS *linked_to_sym = symbol_find (sec->map_head.linked_to_symbol_name);
      if (!linked_to_sym || !S_IS_DEFINED (linked_to_sym))
        {
          as_bad (_("undefined linked-to symbol `%s' on section `%s'"),
                  sec->map_head.linked_to_symbol_name,
                  bfd_section_name (sec));
        }
      else
        {
          elf_linked_to_section (sec) = S_GET_SEGMENT (linked_to_sym);
        }
    }

  const char *sec_name = sec->name;
  if (!startswith (sec_name, ".stab"))
    {
      return;
    }

  size_t name_len = strlen (sec_name);
  if (name_len >= 3 && strcmp ("str", sec_name + name_len - 3) == 0)
    {
      return;
    }

  char *str_section_name = concat (sec_name, "str", (const char *) NULL);
  if (str_section_name == NULL)
    {
      /* Handle allocation failure, if concat can return NULL. */
      /* For now, assuming concat always returns a valid pointer or crashes. */
      /* If not, this needs more robust error handling or a different concat implementation. */
      return;
    }

  asection *strsec = bfd_get_section_by_name (abfd, str_section_name);
  int strsz = 0;
  if (strsec)
    {
      strsz = bfd_section_size (strsec);
    }
  free (str_section_name);

  /* Assuming stab entries are 12 bytes as per nsyms calculation. */
  long section_size = bfd_section_size (sec);
  int nsyms = (section_size > 0) ? (section_size / 12 - 1) : 0;
  if (nsyms < 0) nsyms = 0; /* Ensure nsyms is non-negative */

  void *p = seg_info (sec)->stabu.p;
  gas_assert (p != NULL); /* Ensure p is not NULL before dereferencing */

  /* Assuming p points to a buffer of sufficient size for 8 + 4 = 12 bytes. */
  /* The offsets 6 and 8 suggest specific fields in a structure within p. */
  bfd_h_put_16 (abfd, nsyms, (unsigned char *)p + 6);
  bfd_h_put_32 (abfd, strsz, (unsigned char *)p + 8);
}

#ifdef NEED_ECOFF_DEBUG

/* This function is called by the ECOFF code.  It is supposed to
   record the external symbol information so that the backend can
   write it out correctly.  The ELF backend doesn't actually handle
   this at the moment, so we do it ourselves.  We save the information
   in the symbol.  */

#ifdef OBJ_MAYBE_ELF
static
#endif
void
elf_ecoff_set_ext (symbolS *sym, struct ecoff_extr *ext)
{
  symbol_get_bfdsym (sym)->udata.p = ext;
}

/* This function is called by bfd_ecoff_debug_externals.  It is
   supposed to *EXT to the external symbol information, and return
   whether the symbol should be used at all.  */

static bool
elf_get_extr (asymbol *sym, EXTR *ext)
{
  if (sym->udata.p == NULL)
    return false;
  *ext = *(EXTR *) sym->udata.p;
  return true;
}

/* This function is called by bfd_ecoff_debug_externals.  It has
   nothing to do for ELF.  */

static void
elf_set_index (asymbol *sym ATTRIBUTE_UNUSED,
	       bfd_size_type indx ATTRIBUTE_UNUSED)
{
}

#endif /* NEED_ECOFF_DEBUG */

static void handle_symbol_size(symbolS *symp, struct elf_obj_sy *sy_obj)
{
  expressionS *size = sy_obj->size;
  if (size != NULL)
    {
      if (resolve_expression(size) && size->X_op == O_constant)
	S_SET_SIZE(symp, size->X_add_number);
      else
	{
	  if (!flag_allow_nonconst_size)
	    as_bad(_(".size expression for %s does not evaluate to a constant"), S_GET_NAME(symp));
	  else
	    as_warn(_(".size expression for %s does not evaluate to a constant"), S_GET_NAME(symp));
	}
      sy_obj->size = NULL;
    }
}

static bool process_versioned_symbol_prechecks(symbolS *symp, struct elf_obj_sy *sy_obj, int *puntp, struct elf_versioned_name_list *versioned_name)
{
  if (sy_obj->bad_version)
    {
      *puntp = true;
      return false;
    }

  if (sy_obj->rename)
    {
      S_SET_NAME(symp, versioned_name->name);
      return false;
    }

  if (S_IS_COMMON(symp))
    {
      as_bad(_("`%s' can't be versioned to common symbol '%s'"),
	     versioned_name->name, S_GET_NAME(symp));
      *puntp = true;
      return false;
    }

  return true;
}

static void create_version_aliases(symbolS *original_symp, struct elf_versioned_name_list *versions)
{
  for (struct elf_versioned_name_list *current_version = versions;
       current_version != NULL;
       current_version = current_version->next)
    {
      symbolS *alias_symp = symbol_find_or_make(current_version->name);

      S_SET_SEGMENT(alias_symp, S_GET_SEGMENT(original_symp));

      /* Subtracting out the frag address here is a hack
	 because we are in the middle of the final loop.  */
      unsigned long frag_address_offset = symbol_get_frag(original_symp)->fr_address / OCTETS_PER_BYTE;
      S_SET_VALUE(alias_symp, S_GET_VALUE(original_symp) - frag_address_offset);

      symbol_set_frag(alias_symp, symbol_get_frag(original_symp));
      copy_symbol_attributes(alias_symp, original_symp);
      S_SET_OTHER(alias_symp, S_GET_OTHER(original_symp));

      if (S_IS_WEAK(original_symp))
	S_SET_WEAK(alias_symp);

      if (S_IS_EXTERNAL(original_symp))
	S_SET_EXTERNAL(alias_symp);
    }
}

static void apply_visibility(symbolS *symp, struct elf_obj_sy *sy_obj, int *puntp)
{
  switch (sy_obj->visibility)
    {
    case visibility_unchanged:
      break;
    case visibility_hidden:
      {
	bfd_symbol *bfdsym = symbol_get_bfdsym(symp);
	elf_symbol_type *elfsym = elf_symbol_from(bfdsym);
	elfsym->internal_elf_sym.st_other &= (unsigned char)~3;
	elfsym->internal_elf_sym.st_other |= STV_HIDDEN;
      }
      break;
    case visibility_remove:
      if (symbol_used_in_reloc_p(symp))
	{
	  if (sy_obj->versioned_name->next != NULL)
	    as_bad(_("symbol '%s' with multiple versions cannot be used in relocation"),
		   S_GET_NAME(symp));
	  symbol_mark_removed(symp);
	}
      else
	{
	  symbol_remove(symp, &symbol_rootP, &symbol_lastP);
	}
      break;
    case visibility_local:
      S_CLEAR_EXTERNAL(symp);
      break;
    }
}

static void check_weak_symbol_consistency(symbolS *symp)
{
  if (S_IS_WEAK(symp) && S_IS_COMMON(symp))
    {
      as_bad(_("symbol `%s' can not be both weak and common"), S_GET_NAME(symp));
    }
}


void
elf_frob_symbol (symbolS *symp, int *puntp)
{
  struct elf_obj_sy *sy_obj;

#ifdef NEED_ECOFF_DEBUG
  if (ECOFF_DEBUGGING)
    ecoff_frob_symbol (symp);
#endif

  sy_obj = symbol_get_obj (symp);

  handle_symbol_size (symp, sy_obj);

  if (sy_obj->versioned_name)
    {
      if (process_versioned_symbol_prechecks(symp, sy_obj, puntp, sy_obj->versioned_name))
        {
          create_version_aliases(symp, sy_obj->versioned_name);
          apply_visibility(symp, sy_obj, puntp);
        }
    }

  check_weak_symbol_consistency (symp);
}

/* Fix up SYMPP which has been marked to be removed by .symver.  */

void
elf_fixup_removed_symbol (symbolS **sympp)
{
  if (sympp == NULL)
    {
      return;
    }

  symbolS *symp = *sympp;
  if (symp == NULL)
    {
      return;
    }

  struct elf_obj_sy *sy_obj = symbol_get_obj (symp);
  if (sy_obj == NULL)
    {
      return;
    }

  if (sy_obj->versioned_name == NULL)
    {
      return;
    }

  const char *versioned_name_str = sy_obj->versioned_name->name;
  if (versioned_name_str == NULL)
    {
      return;
    }

  symp = symbol_find (versioned_name_str);
  *sympp = symp;
}

/* Create symbols for group signature.  */

static flagword
determine_group_flags (asection *group_head, const char *group_name)
{
  flagword flags = SEC_READONLY | SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_GROUP;
  asection *s;

  for (s = group_head; s != NULL; s = elf_next_in_group (s))
    {
      if (s->flags & SEC_LINK_ONCE)
        {
          flags |= SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD;
          if (s != group_head)
            {
              as_warn (_("assuming all members of group `%s' are COMDAT"),
                       group_name);
            }
          break;
        }
    }
  return flags;
}

static asection *
create_and_link_group_section (flagword flags, asection *group_head)
{
  const char *sec_name = ".group";
  asection *group_section = subseg_force_new (sec_name, 0);

  if (group_section == NULL)
    {
      as_fatal (_("can't create group section '%s': %s"),
                sec_name, bfd_errmsg (bfd_get_error ()));
    }

  if (!bfd_set_section_flags (group_section, flags))
    {
      as_fatal (_("can't set flags for group section '%s': %s"),
                sec_name, bfd_errmsg (bfd_get_error ()));
    }

  if (!bfd_set_section_alignment (group_section, 2))
    {
      as_fatal (_("can't set alignment for group section '%s': %s"),
                sec_name, bfd_errmsg (bfd_get_error ()));
    }

  elf_section_type (group_section) = SHT_GROUP;
  elf_next_in_group (group_section) = group_head;
  elf_sec_group (group_head) = group_section;

  return group_section;
}

static struct symbol *
find_or_create_group_signature_symbol (const char *group_name)
{
  struct symbol *sy = symbol_find_exact (group_name);

  if (sy == NULL || !symbol_on_chain (sy, symbol_rootP, symbol_lastP))
    {
      sy = symbol_new (group_name, now_seg, frag_now, 0);
      if (sy == NULL)
        {
          as_fatal (_("can't create group signature symbol '%s'"), group_name);
        }
#ifdef TE_SOLARIS
      symbol_get_bfdsym (sy)->flags |= BSF_WEAK;
      S_SET_OTHER (sy, STV_HIDDEN);
#else
      symbol_get_obj (sy)->local = 1;
#endif
      symbol_table_insert (sy);
    }
  return sy;
}

void
elf_adjust_symtab (void)
{
  unsigned int i;

  for (i = 0; i < groups.num_group; i++)
    {
      asection *group_head = groups.head[i];
      const char *group_name = elf_group_name (group_head);

      flagword flags = determine_group_flags (group_head, group_name);
      asection *group_section = create_and_link_group_section (flags, group_head);
      struct symbol *group_signature_symbol = find_or_create_group_signature_symbol (group_name);

      elf_group_id (group_section) = symbol_get_bfdsym (group_signature_symbol);
      symbol_mark_used_in_reloc (group_signature_symbol);
    }
}

void
elf_frob_file (void)
{
  if (stdoutput == NULL)
    {
      fprintf(stderr, "Error: stdoutput BFD handle is NULL in elf_frob_file.\n");
      return;
    }

  if (bfd_map_over_sections (stdoutput, set_additional_section_info, NULL) == -1)
    {
      fprintf(stderr, "Error: Failed to map over sections: %s\n", bfd_errmsg(bfd_get_error()));
      return;
    }

#ifdef elf_tc_final_processing
  elf_tc_final_processing ();
#endif
}

/* It removes any unneeded versioned symbols from the symbol table.  */

void
elf_frob_file_before_adjust (void)
{
  if (symbol_rootP)
    {
      symbolS *current_sym = symbol_rootP;
      symbolS *next_sym = NULL;

      while (current_sym)
	{
	  next_sym = symbol_next (current_sym);

	  struct elf_obj_sy *sy_obj = symbol_get_obj (current_sym);
	  int is_defined = !!S_IS_DEFINED (current_sym);

	  if (sy_obj->versioned_name)
	    {
	      char *symbol_name_str = sy_obj->versioned_name->name;
	      char *at_char_ptr = strchr (symbol_name_str, ELF_VER_CHR);

	      if (at_char_ptr)
		{
		  if (sy_obj->rename)
		    {
		      // The @@@ syntax is a special case.
		      // We need to ensure the string contains at least "@@@"
		      // after the first '@' found by strchr.
		      if (strlen(at_char_ptr) >= 3
			  && at_char_ptr[1] == ELF_VER_CHR
			  && at_char_ptr[2] == ELF_VER_CHR)
			{
			  // If symbol is not defined, 2 '@'s will be removed.
			  // Otherwise, 1 '@' will be removed.
			  size_t shift_target_index = (size_t) (1 + is_defined);
			  size_t suffix_length = strlen (&at_char_ptr[3]) + 1; // +1 for null terminator
			  memmove (&at_char_ptr[shift_target_index], &at_char_ptr[3], suffix_length);
			}
		    }

		  if (!is_defined)
		    {
		      // Verify that the name isn't using the @@ syntax.
		      // This is reserved for definitions of the default version to link against.
		      // We need to ensure the string contains at least "@@"
		      // after the first '@' found by strchr.
		      if (!sy_obj->rename
			  && strlen(at_char_ptr) >= 2
			  && at_char_ptr[1] == ELF_VER_CHR)
			{
			  as_bad (_("invalid attempt to declare external "
					    "version name as default in symbol `%s'"),
				  symbol_name_str);
			  return;
			}

		      // Only one version symbol is allowed for undefined symbols.
		      if (sy_obj->versioned_name->next)
			{
			  as_bad (_("multiple versions [`%s'|`%s'] for "
					    "symbol `%s'"),
				  sy_obj->versioned_name->name,
				  sy_obj->versioned_name->next->name,
				  S_GET_NAME (current_sym));
			  return;
			}

		      sy_obj->rename = true;
		    }
		}
	    }

	  // If there was .symver or .weak, but symbol was neither
	  // defined nor used anywhere, remove it.
	  if (!is_defined
	      && (sy_obj->versioned_name || S_IS_WEAK (current_sym))
	      && symbol_used_p (current_sym) == 0
	      && symbol_used_in_reloc_p (current_sym) == 0)
	    {
	      symbol_remove (current_sym, &symbol_rootP, &symbol_lastP);
	    }

	  current_sym = next_sym;
	}
    }
}

/* It is required that we let write_relocs have the opportunity to
   optimize away fixups before output has begun, since it is possible
   to eliminate all fixups for a section and thus we never should
   have generated the relocation section.  */

#define SHT_GROUP_HEADER_SIZE           4
#define SHT_GROUP_ENTRY_SIZE_DEFAULT    4
#define SHT_GROUP_ENTRY_SIZE_RELOC      8

static bfd_size_type
calculate_group_section_size (asection *head_section)
{
  bfd_size_type size = SHT_GROUP_HEADER_SIZE;
  asection *s_current_in_group;

  for (s_current_in_group = head_section; s_current_in_group != NULL;
       s_current_in_group = elf_next_in_group (s_current_in_group))
    {
      size += (s_current_in_group->flags & SEC_RELOC) != 0
              ? SHT_GROUP_ENTRY_SIZE_RELOC
              : SHT_GROUP_ENTRY_SIZE_DEFAULT;
    }
  return size;
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_process_ecoff_debug_info (void)
{
  if (!ECOFF_DEBUGGING)
    return;

  const struct ecoff_debug_swap *debug_swap;
  struct ecoff_debug_info debug_data;
  char *debug_buffer = NULL;

  debug_swap = get_elf_backend_data (stdoutput)->elf_backend_ecoff_debug_swap;
  if (debug_swap == NULL)
    as_fatal (_("ECOFF debug swap data is missing."));

  ecoff_build_debug (&debug_data.symbolic_header, &debug_buffer, debug_swap);
  if (debug_buffer == NULL)
    as_fatal (_("Failed to allocate buffer for ECOFF debug information."));

#define SET(ptr, offset, type) \
    debug_data.ptr = (type) (debug_buffer + debug_data.symbolic_header.offset)

  SET (line, cbLineOffset, unsigned char *);
  SET (external_dnr, cbDnOffset, void *);
  SET (external_pdr, cbPdOffset, void *);
  SET (external_sym, cbSymOffset, void *);
  SET (external_opt, cbOptOffset, void *);
  SET (external_aux, cbAuxOffset, union aux_ext *);
  SET (ss, cbSsOffset, char *);
  SET (external_fdr, cbFdOffset, void *);
  SET (external_rfd, cbRfdOffset, void *);
  /* ssext and external_ext are set up just below.  */

#undef SET

  debug_data.ssext = debug_data.ssext_end = NULL;
  debug_data.external_ext = debug_data.external_ext_end = NULL;
  debug_data.alloc_syments = 1;

  if (! bfd_ecoff_debug_externals (stdoutput, &debug_data, debug_swap, 1,
				   elf_get_extr, elf_set_index))
    {
      free (debug_buffer);
      as_fatal (_("Failed to set up ECOFF debugging externals: %s"),
                bfd_errmsg (bfd_get_error ()));
    }

  asection *mdebug_section = bfd_get_section_by_name (stdoutput, ".mdebug");
  if (mdebug_section == NULL)
    {
      free (debug_buffer);
      as_fatal (_("Debug section '.mdebug' not found."));
    }

  if (stdoutput->output_has_begun)
    {
      free (debug_buffer);
      as_fatal (_("Output already begun before processing .mdebug section."));
    }

  bfd_set_section_size (mdebug_section, bfd_ecoff_debug_size (stdoutput, &debug_data,
                                                              debug_swap));

  if (! bfd_set_section_contents (stdoutput, mdebug_section, debug_buffer, 0, 0))
    {
      free (debug_buffer);
      as_fatal (_("Can't start writing .mdebug section: %s"),
                bfd_errmsg (bfd_get_error ()));
    }

  if (!stdoutput->output_has_begun)
    {
      free (debug_buffer);
      as_fatal (_("Output did not begin after setting .mdebug section contents."));
    }
  if (mdebug_section->filepos == 0)
    {
      free (debug_buffer);
      as_fatal (_("Section '.mdebug' file position is zero after setting contents."));
    }

  if (! bfd_ecoff_write_debug (stdoutput, &debug_data, debug_swap,
                               mdebug_section->filepos))
    {
      free (debug_buffer);
      as_fatal (_("Could not write .mdebug section: %s"),
                bfd_errmsg (bfd_get_error ()));
    }

  free(debug_buffer);
}
#endif /* NEED_ECOFF_DEBUG */

void
elf_frob_file_after_relocs (void)
{
  unsigned int i;

  /* Set SHT_GROUP section size.  */
  for (i = 0; i < groups.num_group; i++)
    {
      asection *current_group_head = groups.head[i];
      bfd_size_type calculated_size;
      asection *target_group_section;

      calculated_size = calculate_group_section_size (current_group_head);

      target_group_section = elf_sec_group (current_group_head);

      subseg_set (target_group_section, 0);
      bfd_set_section_size (target_group_section, calculated_size);
      target_group_section->contents = (unsigned char *) frag_more (calculated_size);
      target_group_section->alloced = 1;
      frag_now->fr_fix = frag_now_fix_octets ();
      frag_wane (frag_now);
    }

#ifdef NEED_ECOFF_DEBUG
  elf_process_ecoff_debug_info ();
#endif /* NEED_ECOFF_DEBUG */
}

/* This is called when the assembler starts.  */

static void
insert_section_if_found(void *abfd, const char *section_name)
{
  asection *s = bfd_get_section_by_name(abfd, section_name);
  if (s != NULL) {
    void *sym = section_symbol(s);
    if (sym != NULL) {
      symbol_table_insert(sym);
    }
  }
}

void
elf_begin (void)
{
  insert_section_if_found(stdoutput, TEXT_SECTION_NAME);
  insert_section_if_found(stdoutput, DATA_SECTION_NAME);
  insert_section_if_found(stdoutput, BSS_SECTION_NAME);
  elf_com_section_ptr = bfd_com_section_ptr;
  previous_section = NULL;
  previous_subsection = 0;
  comment_section = NULL;
  memset (&groups, 0, sizeof (groups));
}

void
elf_end (void)
{
  while (section_stack)
    {
      struct section_stack *top = section_stack;
      section_stack = top->next;
      free (top);
    }
  while (recorded_attributes)
    {
      struct recorded_attribute_info *rai = recorded_attributes;
      recorded_attributes = rai->next;
      free (rai);
    }
  if (groups.indexes)
    {
      htab_delete (groups.indexes);
      groups.indexes = NULL;

      if (groups.head)
        {
          free (groups.head);
          groups.head = NULL;
        }
    }
}

#ifdef USE_EMULATIONS

static bfd_vma
elf_s_get_size (symbolS *sym)
{
  return S_GET_SIZE (sym);
}

static void
elf_s_set_size (symbolS *sym, bfd_vma sz)
{
  S_SET_SIZE (sym, sz);
}

static bfd_vma
elf_s_get_align (symbolS *sym)
{
  return S_GET_ALIGN (sym);
}

static void
elf_s_set_align (symbolS *sym, bfd_vma align)
{
  S_SET_ALIGN (sym, align);
}

int
elf_s_get_other (symbolS *sym)
{
  return elf_symbol (symbol_get_bfdsym (sym))->internal_elf_sym.st_other;
}

static void
elf_s_set_other (symbolS *sym, int other)
{
  S_SET_OTHER (sym, other);
}

static int
elf_sec_sym_ok_for_reloc (asection *sec)
{
  return obj_sec_sym_ok_for_reloc (sec);
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_process_stab (int what ATTRIBUTE_UNUSED,
		  const char *string ATTRIBUTE_UNUSED,
		  int type ATTRIBUTE_UNUSED,
		  int other ATTRIBUTE_UNUSED,
		  int desc ATTRIBUTE_UNUSED)
{
  if (ECOFF_DEBUGGING)
    ecoff_stab (what, string, type, other, desc);
}
#else
# define elf_process_stab NULL
#endif

static int
elf_separate_stab_sections (void)
{
#ifdef NEED_ECOFF_DEBUG
  return (!ECOFF_DEBUGGING);
#else
  return 1;
#endif
}

#ifdef NEED_ECOFF_DEBUG
static void
elf_init_stab_section (segT stab, segT stabstr)
{
  if (!ECOFF_DEBUGGING)
    obj_elf_init_stab_section (stab, stabstr);
}
#endif

const struct format_ops elf_format_ops =
{
  bfd_target_elf_flavour,
  0,	/* dfl_leading_underscore */
  1,	/* emit_section_symbols */
  elf_begin,
  elf_end,
  elf_file_symbol,
  NULL, /* assign_symbol */
  elf_frob_symbol,
  elf_frob_file,
  elf_frob_file_before_adjust,
  0,	/* obj_frob_file_before_fix */
  elf_frob_file_after_relocs,
  elf_s_get_size, elf_s_set_size,
  elf_s_get_align, elf_s_set_align,
  elf_s_get_other,
  elf_s_set_other,
  0,	/* s_get_desc */
  0,	/* s_set_desc */
  0,	/* s_get_type */
  0,	/* s_set_type */
  elf_copy_symbol_attributes,
  elf_process_stab,
  elf_separate_stab_sections,
#ifdef NEED_ECOFF_DEBUG
  elf_init_stab_section,
#else
  obj_elf_init_stab_section,
#endif
  elf_sec_sym_ok_for_reloc,
  elf_pop_insert,
#ifdef NEED_ECOFF_DEBUG
  elf_ecoff_set_ext,
#else
  0,	/* ecoff_set_ext */
#endif
  elf_obj_read_begin_hook,
  elf_obj_symbol_new_hook,
  0,
  elf_adjust_symtab
};

#endif /* USE_EMULATIONS */
